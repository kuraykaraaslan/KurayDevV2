=== ./index.tsx ===
'use client';

import { useRef, useState, useEffect } from 'react';
import { OTPMethodEnum, OTPMethod } from '@/types/UserSecurityTypes';
import { SafeUserSecurity, SafeUserSecurityDefault } from '@/types/UserSecurityTypes';
import axiosInstance from '@/libs/axios';
import useGlobalStore from '@/libs/zustand';
import { toast } from 'react-toastify';

import OTPMethodCard from './partials/OTPMethodCard';
import OTPConfirmModal from './partials/OTPConfirmModal';

export default function OTPTab() {

  const { user, setUser } = useGlobalStore();

  /* ---------------- STATE ---------------- */
  const [userSecurity, setUserSecurity] = useState<SafeUserSecurity>(
    SafeUserSecurityDefault
  );

  const [pendingMethod, setPendingMethod] = useState<OTPMethod | null>(null);
  const [pendingAction, setPendingAction] =
    useState<'enable' | 'disable' | null>(null);

  const [modalOpen, setModalOpen] = useState(false);
  const [otpCode, setOtpCode] = useState('');
  const [otpSent, setOtpSent] = useState(false);

  const [sendingOtp, setSendingOtp] = useState(false);
  const [verifying, setVerifying] = useState(false);

  const otpInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    const fetchUserSecurity = async () => {
      try {
        const res = await axiosInstance.get('/api/auth/me/security');
        setUserSecurity(res.data.userSecurity);
      } catch (err) {
        console.error('Kullanıcı güvenliği alınamadı', err);
      }
    };

    fetchUserSecurity();
  }, []);


  const openModalForMethod = (method: OTPMethod) => {
    const enabled = userSecurity.otpMethods.includes(method);
    setPendingMethod(method);
    setPendingAction(enabled ? 'disable' : 'enable');
    setOtpCode('');
    setOtpSent(false);
    setModalOpen(true);
  };

  /* ---------------- SEND OTP ---------------- */
  const sendOtp = async () => {
    if (!pendingMethod || !pendingAction) return;

    try {
      setSendingOtp(true);

      await axiosInstance.post('/api/auth/me/security/send', {
        method: pendingMethod,
        action: pendingAction
      });

      setOtpSent(true);
      toast.success('Doğrulama kodu gönderildi');

      setTimeout(() => otpInputRef.current?.focus(), 100);
    } catch {
      toast.error('OTP gönderilemedi');
    } finally {
      setSendingOtp(false);
    }
  };

  /* ---------------- VERIFY + APPLY ---------------- */
  const verifyAndApply = async () => {
    if (!pendingMethod || !pendingAction) return;

    try {
      setVerifying(true);

      const verifyRes = await axiosInstance.post('/api/auth/me/security/verify', { 
        otpToken: otpCode,
        method: pendingMethod,
        action: pendingAction
      });

      if (!verifyRes.data?.success) {
        toast.error('OTP doğrulanamadı');
        return;
      }

      const updated =
        pendingAction === 'enable'
          ? [...new Set([...userSecurity.otpMethods, pendingMethod])]
          : userSecurity.otpMethods.filter(m => m !== pendingMethod);

      const userRes = await axiosInstance.put('/api/users/me', {
        otpMethods: updated,
      });

      setUserSecurity(prev => ({ ...prev, otpMethods: updated }));
      setUser(userRes.data.user);

      toast.success('2FA ayarı güncellendi');
      setModalOpen(false);
    } catch (err: any) {
      console.error(err);
      toast.error(err?.response?.data?.message || 'Doğrulama başarısız');
    } finally {
      setVerifying(false);
    }
  };

  /* ---------------- RENDER ---------------- */
  return (
    <>
      <div className="bg-base-100 rounded-xl p-6 space-y-6">
        <h2 className="text-lg font-bold">İki Faktörlü Doğrulama</h2>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {Object.values(OTPMethodEnum.Enum).map(method => (
            <OTPMethodCard
              key={method}
              method={method}
              enabled={userSecurity.otpMethods.includes(method)}
              onClick={() => openModalForMethod(method)}
            />
          ))}
        </div>
      </div>

      <OTPConfirmModal
        open={modalOpen}
        method={pendingMethod ?? undefined}
        action={pendingAction ?? undefined}
        otpSent={otpSent}
        otpCode={otpCode}
        sendingOtp={sendingOtp}
        verifying={verifying}
        otpInputRef={otpInputRef as React.RefObject<HTMLInputElement>}
        onSendOtp={sendOtp}
        onVerify={verifyAndApply}
        onChangeCode={setOtpCode}
        onClose={() => setModalOpen(false)}
      />
    </>
  );
}


=== ./partials/OTPConfirmModal.tsx ===
import HeadlessModal from '@/components/common/Modal';

type Props = {
  open: boolean;
  method?: string;
  action?: 'enable' | 'disable';
  otpSent: boolean;
  otpCode: string;
  sendingOtp: boolean;
  verifying: boolean;
  otpInputRef: React.RefObject<HTMLInputElement>;
  onSendOtp: () => void;
  onVerify: () => void;
  onChangeCode: (v: string) => void;
  onClose: () => void;
};

export default function OTPConfirmModal(props: Props) {
  const {
    open,
    method,
    action,
    otpSent,
    otpCode,
    sendingOtp,
    verifying,
    otpInputRef,
    onSendOtp,
    onVerify,
    onChangeCode,
    onClose,
  } = props;

  return (
    <HeadlessModal
      open={open}
      onClose={onClose}
      title="Güvenlik Doğrulaması"
      size="sm"
      closeOnBackdrop={false}
      closeOnEsc={false}
    >
      <div className="space-y-4">
        {!otpSent && (
          <button
            onClick={onSendOtp}
            disabled={sendingOtp}
            className="btn btn-primary w-full"
          >
            {sendingOtp ? 'Kod Gönderiliyor…' : 'Doğrulama Kodu Gönder'}
          </button>
        )}

        {otpSent && (
          <>
            <input
              ref={otpInputRef}
              maxLength={6}
              value={otpCode}
              onChange={e => onChangeCode(e.target.value)}
              className="input input-bordered w-full text-center text-2xl tracking-widest font-mono"
              placeholder="123456"
            />

            <button
              onClick={onVerify}
              disabled={verifying || otpCode.length !== 6}
              className="btn btn-primary w-full"
            >
              {verifying ? 'Doğrulanıyor…' : 'Doğrula'}
            </button>
          </>
        )}
      </div>
    </HeadlessModal>
  );
}


=== ./partials/OTPMethodCard.tsx ===
import { OTPMethod } from '@/types/UserSecurityTypes';

type Props = {
  method: OTPMethod;
  enabled: boolean;
  onClick: () => void;
};

export default function OTPMethodCard({ method, enabled, onClick }: Props) {
  return (
    <div
      onClick={onClick}
      className={`p-4 rounded-lg border cursor-pointer transition
        ${enabled
          ? 'border-primary bg-primary/10'
          : 'border-base-300 hover:bg-base-200'
        }
      `}
    >
      <div className="flex justify-between items-center">
        <span className="font-semibold">{method}</span>
        <span className={`text-sm ${enabled ? 'text-primary' : 'text-base-content/60'}`}>
          {enabled ? 'Aktif' : 'Kapalı'}
        </span>
      </div>
    </div>
  );
}


