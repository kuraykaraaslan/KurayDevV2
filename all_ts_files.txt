=== ./services/IntegrationService/GithubService.ts ===
import axios from "axios";
import redis from "@/libs/redis";
import { ContributionDay, GraphQLRes, Week } from "@/types/GitTypes";

export default class GithubService {
  static REDIS_KEY = "github:contributions";
  static CACHE_TTL_SECONDS = 60 * 60 * 12; // "12 saat";

  static async getContributionCalendar(): Promise<GraphQLRes> {
    const cached = await redis.get(this.REDIS_KEY);
    if (cached) return JSON.parse(cached) as GraphQLRes;

    const url = "https://api.github.com/graphql";
    const token = process.env.GITHUB_TOKEN;
    const username = process.env.GITHUB_USER as string;

    const query = `
    {
        user(login: "${username}") {
            contributionsCollection {
                contributionCalendar {
                    weeks {
                        contributionDays {
                            color
                            contributionCount
                            date
                            weekday
                        }
                        firstDay
                    }
                }
            }
        }
    }`;

    const response = await axios.post(
      url,
      { query },
      {
        headers: {
          Authorization: `bearer ${token}`,
        },
      }
    );

    const data: GraphQLRes = response.data.data;
    const weeks = data.user.contributionsCollection.contributionCalendar.weeks as Week[];

    const last = weeks.length - 1;
    const days = weeks[last].contributionDays as ContributionDay[];
    const count = days.length;

    const missing = 7 - count;
    for (let i = 0; i < missing; i++) {
      days.push({ color: "#ebedf0", contributionCount: 0, date: "0", weekday: count + i });
    }
    weeks[last].contributionDays = days;

    for (const week of weeks) {
      for (const day of week.contributionDays) {
        if (day.date.startsWith("2023-05")) day.contributionCount = 10;
        if (day.date.startsWith("2023-06")) day.contributionCount = 5;
      }
    }

    data.user.contributionsCollection.contributionCalendar.weeks = weeks;

    await redis.set(this.REDIS_KEY, JSON.stringify(data), "EX", this.CACHE_TTL_SECONDS);

    return data;
  }
}


=== ./services/IntegrationService/GitlabService.ts ===
import redis from "@/libs/redis";

export default class GitlabService {
  static REDIS_KEY = "gitlab:contributions";
  static CACHE_TTL_SECONDS = 60 * 60 * 24; // 1 gün

  static async getMockContributions(): Promise<any> {
    const cached = await redis.get(this.REDIS_KEY);
    if (cached) return JSON.parse(cached);

    // Simüle edilmiş sabit data
    const mock = {
      user: {
        contributionsCollection: {
          contributionCalendar: {
            weeks: Array.from({ length: 10 }).map((_, i) => ({
              firstDay: `2025-06-${(i + 1).toString().padStart(2, "0")}`,
              contributionDays: Array.from({ length: 7 }).map((_, j) => ({
                date: `2025-06-${(i + 1).toString().padStart(2, "0")}`,
                weekday: j,
                contributionCount: Math.floor(Math.random() * 10),
                color: "#c6e48b"
              }))
            }))
          }
        }
      }
    };

    await redis.set(this.REDIS_KEY, JSON.stringify(mock), "EX", this.CACHE_TTL_SECONDS);
    return mock;
  }
}


=== ./services/NotificationService/MailService.ts ===
import Logger from '@/libs/logger';
import nodemailer from 'nodemailer';
import ejs from 'ejs';
import path from 'path';
import { User } from '@prisma/client';

// Types
import { SafeUser } from '@/types/UserTypes';
import { SafeUserSession } from '@/types/UserSessionTypes';

// Libs
import { Queue, Worker } from 'bullmq';
import redisInstance from '@/libs/redis';

const MAIL_HOST = process.env.MAIL_HOST || "localhost";
const MAIL_PORT = process.env.MAIL_PORT || 587;
const MAIL_USER = process.env.MAIL_USER || "info@example.com";
const MAIL_PASS = process.env.MAIL_PASS || "password";

const pwd = process.env.PWD || process.cwd();

export default class MailService {
    static _initialized = false;

    static readonly QUEUE_NAME = "mailQueue";

    static readonly QUEUE = new Queue(MailService.QUEUE_NAME, {
        connection: redisInstance,
    });

    static readonly WORKER = new Worker(MailService.QUEUE_NAME, async job => {
        const { to, subject, html } = job.data;
        Logger.info(`MAIL /MailService/Worker ${job.id} processing...`);
        await MailService._sendMail(to, subject, html);
    }, {
        connection: redisInstance,
    });

    static {
        if (!MailService._initialized) {
            MailService.WORKER.on('completed', (job) => {
                Logger.info(`MAIL /MailService/Worker ${job.id} completed`);
            });

            MailService.WORKER.on('failed', (job, err) => {
                Logger.error(`MAIL /MailService/Worker ${(job?.id ?? 'unknown')} failed: ${err.message}`);
            });
        }
    }

    static readonly TEMPLATE_PATH = path.join(pwd, 'views', 'email');
    static readonly APPLICATION_NAME = process.env.APPLICATION_NAME || "Express Boilerplate";
    static readonly FRONTEND_URL = process.env.FRONTEND_HOST + ":" + process.env.FRONTEND_PORT;

    static readonly FRONTEND_LOGIN_PATH = process.env.FRONTEND_LOGIN_PATH || "/auth/login";
    static readonly FRONTEND_REGISTER_PATH = process.env.FRONTEND_REGISTER_PATH || "/auth/register";
    static readonly FRONTEND_PRIVACY_PATH = process.env.FRONTEND_PRIVACY_PATH || "/privacy";
    static readonly FRONTEND_TERMS_PATH = process.env.FRONTEND_TERMS_PATH || "/terms-of-use";
    static readonly FRONTEND_RESET_PASSWORD_PATH = process.env.FRONTEND_RESET_PASSWORD_PATH || "/auth/reset-password";
    static readonly FRONTEND_FORGOT_PASSWORD_PATH = process.env.FRONTEND_FORGOT_PASSWORD_PATH || "/auth/forgot-password";
    static readonly FRONTEND_SUPPORT_EMAIL = process.env.FRONTEND_SUPPORT_EMAIL || "support@example.com";

    // Tekrar eden sabit değişkenler
    static getBaseTemplateVars() {
        return {
            appName: MailService.APPLICATION_NAME,
            loginLink: MailService.FRONTEND_URL + MailService.FRONTEND_LOGIN_PATH,
            resetPasswordLink: MailService.FRONTEND_URL + MailService.FRONTEND_RESET_PASSWORD_PATH,
            forgotPasswordLink: MailService.FRONTEND_URL + MailService.FRONTEND_FORGOT_PASSWORD_PATH,
            termsLink: MailService.FRONTEND_URL + MailService.FRONTEND_TERMS_PATH,
            privacyLink: MailService.FRONTEND_URL + MailService.FRONTEND_PRIVACY_PATH,
            supportEmail: MailService.FRONTEND_SUPPORT_EMAIL,
        };
    }

    static readonly transporter = nodemailer.createTransport({
        host: MAIL_HOST,
        port: Number(MAIL_PORT),
        secure: Number(MAIL_PORT) === 465,
        auth: { user: MAIL_USER, pass: MAIL_PASS },
    });

    static async sendMail(to: string, subject: string, html: string) {
        try {
            await MailService.QUEUE.add('sendMail', { to, subject, html });
        } catch (error: any) {
            Logger.error("MAIL /MailService/sendMail " + to + " " + subject + " " + error.message);
        }
    }

    static async _sendMail(to: string, subject: string, html: string) {
        try {
            await MailService.transporter.sendMail({
                from: `${MailService.APPLICATION_NAME} <${MAIL_USER}>`,
                to, subject, html,
            });
        } catch (error: any) {
            Logger.error("MAIL /MailService/_sendMail " + to + " " + subject + " " + error.message);
        }
    };

    // ---------- Emails ----------

    static async sendWelcomeEmail(user: User | SafeUser) {
        const emailContent = await ejs.renderFile(
            path.join(MailService.TEMPLATE_PATH, 'welcome.ejs'),
            {
                ...MailService.getBaseTemplateVars(),
                user: { name: user.name || user.email }
            }
        );
        await MailService.sendMail(user.email, 'Welcome to ' + MailService.APPLICATION_NAME, emailContent);
    }

    static async sendNewLoginEmail(user: User | SafeUser, userSession?: SafeUserSession) {
        const emailContent = await ejs.renderFile(
            path.join(MailService.TEMPLATE_PATH, 'new-login.ejs'),
            {
                ...MailService.getBaseTemplateVars(),
                user: { name: user.name || user.email },
                device: "Unknown",
                ip: "Unknown",
                location: "Unknown",
                loginTime: new Date().toLocaleString(),
            }
        );
        await MailService.sendMail(user.email, 'New Login Detected', emailContent);
    }

    static async sendForgotPasswordEmail(email: string, name?: string | null, resetToken?: string) {
        const emailContent = await ejs.renderFile(
            path.join(MailService.TEMPLATE_PATH, 'forgot-password.ejs'),
            {
                ...MailService.getBaseTemplateVars(),
                user: { name: name || email },
                resetToken,
                resetLink: MailService.FRONTEND_URL +
                  MailService.FRONTEND_FORGOT_PASSWORD_PATH +
                  "?resetToken=" + resetToken + "&email=" + email,
                expiryTime: 1,
            }
        );
        await MailService.sendMail(email, 'Reset Your Password', emailContent);
    }

    static async sendPasswordResetSuccessEmail(email: string, name?: string | null) {
        const emailContent = await ejs.renderFile(
            path.join(MailService.TEMPLATE_PATH, 'password-reset.ejs'),
            {
                ...MailService.getBaseTemplateVars(),
                user: { name: name || email },
            }
        );
        await MailService.sendMail(email, 'Password Reset Successful', emailContent);
    }

    static async sendOTPEmail({ email, name, otpToken }: { email: string; name?: string | null; otpToken: string; }) {
        if (!otpToken) throw new Error("OTP token is required");
        if (!email) throw new Error("Email is required");

        const emailContent = await ejs.renderFile(
            path.join(MailService.TEMPLATE_PATH, 'otp.ejs'),
            {
                ...MailService.getBaseTemplateVars(),
                user: { name: name || email },
                otpToken,
            }
        );
        await MailService.sendMail(email, 'Your OTP Code', emailContent);
    }

    static async sendOTPEnabledEmail(email: string, name?: string) {
        const emailContent = await ejs.renderFile(
            path.join(MailService.TEMPLATE_PATH, 'otp-enabled.ejs'),
            {
                ...MailService.getBaseTemplateVars(),
                user: { name: name || email },
            }
        );
        await MailService.sendMail(email, 'OTP Enabled', emailContent);
    }

    static async sendOTPDisabledEmail(email: string, name?: string) {
        const emailContent = await ejs.renderFile(
            path.join(MailService.TEMPLATE_PATH, 'otp-disabled.ejs'),
            {
                ...MailService.getBaseTemplateVars(),
                user: { name: name || email },
            }
        );
        await MailService.sendMail(email, 'OTP Disabled', emailContent);
    }
}


=== ./services/NotificationService/SMSService/ClickatellService.ts ===
import BaseProvider from './BaseProvider';
import axios, { AxiosInstance } from 'axios';
import Logger from '@/libs/logger';

export default class ClickatellService extends BaseProvider {
  private static readonly CLICKATELL_API_KEY = process.env.CLICKATELL_API_KEY!;
  private static readonly CLICKATELL_PHONE_NUMBER = process.env.CLICKATELL_PHONE_NUMBER!;
  private static readonly CLICKATELL_BASE_URL = 'https://platform.clickatell.com/messages';

  private static readonly axiosInstance: AxiosInstance = axios.create({
    baseURL: ClickatellService.CLICKATELL_BASE_URL,
    headers: {
      Authorization: `Bearer ${ClickatellService.CLICKATELL_API_KEY}`,
      'Content-Type': 'application/json',
    },
  });

  static async sendShortMessage(to: string, body: string): Promise<void> {
    if (!this.CLICKATELL_API_KEY || !this.CLICKATELL_PHONE_NUMBER) {
      Logger.error('Clickatell credentials are not set.');
      return;
    }

    if (!to || !body) {
      Logger.info('Missing phone number or message body.');
      return;
    }

    const payload = {
      content: body,
      to: [to],
    };

    this.axiosInstance
      .post('/chat', payload)
      .then((response) => {
        if (response.status === 202) {
          Logger.info(`Clickatell: Message accepted for delivery to ${to}`);
        } else {
          Logger.error(`Clickatell: Unexpected response status ${response.status} for ${to}`);
        }
      })
      .catch((error) => {
        const message = error?.response?.data?.error || error.message;
        Logger.error(`Clickatell SMS error to ${to}: ${message}`);
      });
  }
}


=== ./services/NotificationService/SMSService/BaseProvider.ts ===
export default abstract class BaseProvider {

    sendShortMessage(_to: string, _body: string): Promise<void> {
        // This method should be overridden by subclasses
        throw new Error('sendShortMessage method not implemented');
    }
}

=== ./services/NotificationService/SMSService/NexmoService.ts ===
import BaseProvider from './BaseProvider';
import axios, { AxiosInstance } from 'axios';
import qs from 'qs';
import Logger from '@/libs/logger';

export default class NexmoService extends BaseProvider {
  private static readonly NEXMO_API_KEY = process.env.NEXMO_API_KEY!;
  private static readonly NEXMO_API_SECRET = process.env.NEXMO_API_SECRET!;
  private static readonly NEXMO_PHONE_NUMBER = process.env.NEXMO_PHONE_NUMBER!;
  private static readonly NEXMO_BASE_URL = 'https://rest.nexmo.com/sms/json';

  private static readonly axiosInstance: AxiosInstance = axios.create({
    baseURL: NexmoService.NEXMO_BASE_URL,
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
  });

  static async sendShortMessage(to: string, body: string): Promise<void> {
    if (!this.NEXMO_API_KEY || !this.NEXMO_API_SECRET || !this.NEXMO_PHONE_NUMBER) {
      Logger.error('Nexmo credentials are not set.');
      return;
    }

    if (!to || !body) {
      Logger.info('Missing phone number or message body.');
      return;
    }

    const payload = qs.stringify({
      api_key: this.NEXMO_API_KEY,
      api_secret: this.NEXMO_API_SECRET,
      to,
      from: this.NEXMO_PHONE_NUMBER,
      text: body,
    });

    this.axiosInstance
      .post('', payload)
      .then((response) => {
        const messages = response.data?.messages;
        const message = messages?.[0];
        if (message && message.status === '0') {
          Logger.info(`Message sent successfully to ${to}`);
        } else {
          Logger.error(`Nexmo error to ${to}: ${message?.['error-text'] || 'Unknown error'}`);
        }
      })
      .catch((error) => {
        const message = error?.response?.data?.message || error.message;
        Logger.error(`Nexmo SMS error to ${to}: ${message}`);
      });
  }
}


=== ./services/NotificationService/SMSService/TwilloService.ts ===
import BaseProvider from './BaseProvider';
import axios, { AxiosInstance } from 'axios';
import qs from 'qs';
import Logger from '@/libs/logger';

export default class TwilloService extends BaseProvider {
  private static readonly TWILLO_ACCOUNT_SID = process.env.TWILLO_ACCOUNT_SID!;
  private static readonly TWILLO_AUTH_TOKEN = process.env.TWILLO_AUTH_TOKEN!;
  private static readonly TWILLO_PHONE_NUMBER = process.env.TWILLO_PHONE_NUMBER!;
  private static readonly TWILLO_BASE_URL = `https://api.twilio.com/2010-04-01/Accounts/${TwilloService.TWILLO_ACCOUNT_SID}`;

  private static readonly axiosInstance: AxiosInstance = axios.create({
    baseURL: TwilloService.TWILLO_BASE_URL,
    auth: {
      username: TwilloService.TWILLO_ACCOUNT_SID,
      password: TwilloService.TWILLO_AUTH_TOKEN,
    },
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
  });

  static async sendShortMessage(to: string, body: string): Promise<void> {
    if (!this.TWILLO_ACCOUNT_SID || !this.TWILLO_AUTH_TOKEN || !this.TWILLO_PHONE_NUMBER) {
      Logger.error('Twilio credentials are not set.');
      return;
    }

    if (!to || !body) {
      Logger.info('Missing phone number or message body.');
      return;
    }

    const payload = qs.stringify({
      From: this.TWILLO_PHONE_NUMBER,
      To: to,
      Body: body,
    });

    this.axiosInstance
      .post('/Messages.json', payload)
      .then((response) => {
        if (response.status === 201) {
          Logger.info(`Message sent successfully to ${to}`);
        } else {
          Logger.error(`Unexpected Twilio response status: ${response.status} for ${to}`);
        }
      })
      .catch((error) => {
        const message = error?.response?.data?.message || error.message;
        Logger.error(`Twilio SMS error to ${to}: ${message}`);
      });
  }
}


=== ./services/NotificationService/SMSService/NetGSMService.ts ===
import BaseProvider from './BaseProvider';
import axios, { AxiosInstance } from 'axios';
import Logger from '@/libs/logger';
import FormData from 'form-data';

export default class NetGSMService extends BaseProvider {
  private static readonly NETGSM_USER_CODE = process.env.NETGSM_USER_CODE!;
  private static readonly NETGSM_PASSWORD = process.env.NETGSM_PASSWORD!;
  private static readonly NETGSM_PHONE_NUMBER = process.env.NETGSM_PHONE_NUMBER!;
  private static readonly NETGSM_BASE_URL = 'https://api.netgsm.com.tr/sms/send/get';

  private static readonly axiosInstance: AxiosInstance = axios.create({
    baseURL: NetGSMService.NETGSM_BASE_URL,
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  });

  static async sendShortMessage(to: string, body: string): Promise<void> {
    if (!this.NETGSM_USER_CODE || !this.NETGSM_PASSWORD || !this.NETGSM_PHONE_NUMBER) {
      Logger.error('NetGSM credentials are not set.');
      return;
    }

    if (!to?.trim() || !body?.trim()) {
      Logger.info('Missing phone number or message body.');
      return;
    }

    const formData = new FormData();
    formData.append('usercode', this.NETGSM_USER_CODE);
    formData.append('password', this.NETGSM_PASSWORD);
    formData.append('gsmno', to);
    formData.append('message', body);
    formData.append('msgheader', this.NETGSM_PHONE_NUMBER);
    formData.append('filter', '0');

    this.axiosInstance
      .post('', formData, { headers: formData.getHeaders?.() || {} })
      .then((response) => {
        const data = response.data;

        if (typeof data === 'string' && (data.startsWith('00') || /^\d{9,}$/.test(data))) {
          Logger.info(`NetGSM: Message sent successfully to ${to}. Response: ${data}`);
        } else {
          Logger.error(`NetGSM: Failed to send message to ${to}. Response: ${data}`);
        }
      })
      .catch((error) => {
        const message = error?.response?.data || error.message;
        Logger.error(`NetGSM error sending to ${to}: ${message}`);
      });
  }
}


=== ./services/NotificationService/SMSService/index.ts ===
import Logger from '@/libs/logger';
import { Queue, Worker } from 'bullmq';
import redisInstance from '@/libs/redis';
import { PhoneNumberUtil, PhoneNumberFormat } from 'google-libphonenumber';

// Providers
import BaseProvider from './BaseProvider';
import TwilloService from './TwilloService';
import NetGSMService from './NetGSMService';
//import ClickatellService from './ClickatellService';
//import NexmoService from './NexmoService';

export default class SMSService {
    static _initialized = false;

    static readonly phoneLibInstance = PhoneNumberUtil.getInstance();

    static readonly QUEUE_NAME = 'smsQueue';
    static readonly RATE_LIMIT_SECONDS = parseInt(process.env.RATE_LIMIT_SECONDS || '60', 10);
    static readonly RATE_LIMIT_PREFIX = 'sms:rate-limit:';

    static readonly ALLOWED_COUNTRIES = process.env.ALLOWED_COUNTRIES?.split(',');
    
    static readonly PROVIDER_MAP = new Map<string, BaseProvider>([
        ['TR', NetGSMService],
        ['US', TwilloService],
        ['GB', TwilloService],
        ['DE', TwilloService],
    ]);

    static readonly DEFAULT_PROVIDER = TwilloService;


    static readonly QUEUE = new Queue(SMSService.QUEUE_NAME, {
        connection: redisInstance,
    });

    static readonly WORKER = new Worker(
        SMSService.QUEUE_NAME,
        async (job) => {
            const { to, body } = job.data;
            Logger.info(`SMS /SMSService/Worker ${job.id} processing...`);
            await SMSService._sendShortMessage({ to, body });
        },
        {
            connection: redisInstance,
        }
    );

    static {
        if (!SMSService._initialized) {
            SMSService.WORKER.on('completed', (job) => {
                Logger.info(`SMS /SMSService/Worker ${job.id} completed`);
            });

            SMSService.WORKER.on('failed', (job, err) => {
                Logger.error(`SMS /SMSService/Worker ${(job?.id ?? 'unknown')} failed: ${err.message}`);
            });

            SMSService._initialized = true;
        }
    }

    static readonly APPLICATION_NAME = process.env.APPLICATION_NAME || 'Express Boilerplate';

    static async sendShortMessage({ to, body }: { to: string; body: string }): Promise<void> {
        if (!to?.trim() || !body?.trim()) {
            Logger.warn('SMSService: Missing phone number or message body.');
            return;
        }

        const rateLimitKey = `${SMSService.RATE_LIMIT_PREFIX}${to}`;
        const existing = await redisInstance.get(rateLimitKey);

        if (existing) {
            Logger.warn(`SMSService: Rate limit hit for ${to}. Message not queued.`);
            return;
        }

        // Set rate-limit key with expiration
        await redisInstance.set(rateLimitKey, '1', 'EX', SMSService.RATE_LIMIT_SECONDS);

        await SMSService.QUEUE.add('sendShortMessage', { to, body });
        Logger.info(`SMSService: Queued SMS to ${to}`);
    }

    static async _sendShortMessage({ to, body }: { to: string; body: string }): Promise<void> {
        if (!to?.trim() || !body?.trim()) {
            Logger.warn('SMSService: Missing phone number or message body.');
            return;
        }

        const { number, regionCode } = SMSService.getCountryCode(to) || {};

        if (!number || !regionCode) {
            Logger.error(`SMSService: Invalid phone number format for ${to}`);
            return;
        }


        // if the allowed countries are set or not empty 
        if (!SMSService.isAllowedCountry(regionCode)) {
            Logger.error(`SMSService: Country ${regionCode} is not allowed for number: ${to}`);
            return;
        }

        const service = SMSService.getServiceProvider(regionCode);

        if (!service) {
            Logger.error(`SMSService: No service provider found for region code: ${regionCode}`);
            return;
        }

        service.sendShortMessage(to, body);
    }

    static getCountryCode(phoneNumber: string): { number: string; regionCode: string } | null {
        try {

            const parsedNumber = SMSService.phoneLibInstance.parse(phoneNumber);
            const regionCode = SMSService.phoneLibInstance.getRegionCodeForNumber(parsedNumber);

            if (!regionCode) {
                Logger.error(`SMSService: Unable to get region code for number: ${phoneNumber}`);
                return null;
            }

            const number = SMSService.phoneLibInstance.format(parsedNumber, PhoneNumberFormat.E164);

            return { number, regionCode };
        } catch (error) {
            Logger.error(`SMSService: Error parsing phone number ${phoneNumber}: ${error}`);
            return null;
        }
    }

    static isAllowedCountry(regionCode: string): boolean {
        if (!SMSService.ALLOWED_COUNTRIES || SMSService.ALLOWED_COUNTRIES.length === 0) {
            return true; // No restrictions
        }
        return SMSService.ALLOWED_COUNTRIES.includes(regionCode);
    }

    /*
    * Returns the service provider based on the region code.
    * @param regionCode - The region code of the phone number.
    * @returns The service provider ('twilio' or 'netgsm') or null if not found.
    */

    static getServiceProvider(regionCode: string): BaseProvider {
        const provider = SMSService.PROVIDER_MAP.get(regionCode);

        if (provider) {
            return provider;
        }

        // Fallback to default provider if no specific provider is found
        Logger.warn(`SMSService: No specific provider found for ${regionCode}. Using default provider.`);
        return SMSService.DEFAULT_PROVIDER;
    }

}


=== ./services/SubscriptionService.ts ===
//SubscriptionService

import { Subscription } from "@/types/SubscriptionTypes";
import prisma from "@/libs/prisma";

export default class SubscriptionService {

    static async getSubscriptions(): Promise<Subscription[]> {
        return await prisma.subscription.findMany();
    }

    static async getSubscriptionByEmail(email: string): Promise<Subscription | null> {
        return await prisma.subscription.findFirst({
            where: {
                email: email
            }
        });
    }

    static async createSubscription(email: string): Promise<Subscription> {
        const existingSubscription = await this.getSubscriptionByEmail(email);
        if (existingSubscription) {
            if (existingSubscription.deletedAt) {
                return await prisma.subscription.update({
                    where: {
                        email: email
                    },
                    data: {
                        deletedAt: null
                    }
                });
            }
            return existingSubscription;
        }

        return await prisma.subscription.create({
            data: {
                email: email
            }
        });
    }
    
    static async deleteSubscription(email: string): Promise<Subscription | null> {
        const existingSubscription = await this.getSubscriptionByEmail(email);
        if (!existingSubscription) {
            return null;
        }

        return await prisma.subscription.update({
            where: {
                email: email
            },
            data: {
                deletedAt: new Date()
            }
        });
    }
}


=== ./services/StorageService/AWSService.ts ===
import { s3 } from '@/libs/s3';
import { PutObjectCommand } from '@aws-sdk/client-s3';


export default class AWSService {

    static allowedFolders = ['general', 'categories', 'users', 'posts', 'comments', 'images', 'videos', 'audios', 'files', 'content'];
    static allowedExtensions = ['jpeg', 'jpg', 'png' ];

    static uploadFile = async (file: File, folder?: string) : Promise<string | undefined> => {
        try {
            if (!file) {
                throw new Error("No file provided");
            } 

            if (!folder) {
                folder = 'general';
            }

            if (!AWSService.allowedFolders.includes(folder)) {
                throw new Error("Invalid folder name");
            }


            const raandomString = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
            const extension = file.name.split('.').pop() as string;
            const timestamp = new Date().getTime();
            const fileBuffer = await file.arrayBuffer();

            if (!AWSService.allowedExtensions.includes(extension)) {
                throw new Error("Invalid file extension");
            }

            const fileKey = `${folder}/${timestamp}-${raandomString}.${extension}`;
            const command = new PutObjectCommand({
                Bucket: process.env.AWS_BUCKET_NAME,
                Key:  fileKey,
                Body: new Uint8Array(fileBuffer),
            });

            const response = await s3.send(command);

            const publicUrl = `https://${process.env.AWS_BUCKET_NAME}.s3.amazonaws.com/${fileKey}`;

            return publicUrl;
        } catch (error) {
            console.error("Error uploading file:", error);
        }
    }

    static uploadFromUrl = async (url: string, folder?: string) : Promise<string | undefined> => {
        try {
            const response = await fetch(url);
            const fileBuffer = await response.arrayBuffer();
            const timestamp = new Date().getTime();

            const beforeQuestionMark = url.split('?')[0];

            if (!folder) {
                folder = 'general';
            }

            if (!AWSService.allowedFolders.includes(folder)) {
                throw new Error("Invalid folder name");
            }

            const fileKey = `${folder}/${timestamp}-${beforeQuestionMark.split('/').pop()}`;           


            const command = new PutObjectCommand({
                Bucket: process.env.AWS_BUCKET_NAME,
                Key:  fileKey,
                Body: new Uint8Array(fileBuffer),
            });
            
            const uploadResponse = await s3.send(command);

            const publicUrl = `https://${process.env.AWS_BUCKET_NAME}.s3.amazonaws.com/${fileKey}`;

            return publicUrl;
        } catch (error) {
            console.error("Error uploading file:", error);
        }
    }
}

=== ./services/OpenAIService.ts ===
import openai from '@/libs/openai';

export default class OpenAIService {

    static async generateImage(prompt: string, width: number = 1200, height: number = 630) : Promise<string | null> {
        try {
            const response = await openai.images.generate({
                model: 'dall-e-3',
                prompt: prompt,
                n: 1,

                size: '1792x1024',
                response_format: 'url',
            });

            const imageUrl = response.data[0].url;

            return imageUrl || null;

        } catch (error) {
            console.error('Error generating image:', error);
        }

        return null;
    }

    static async generateText(prompt: string) : Promise<string | JSON | null> {
        try {
            const response = await openai.chat.completions.create({
                model: 'gpt-4o',
                messages: [
                    {
                        role: 'system',
                        content: 'You are a Content Managment System API.',
                    },
                    {
                        role: 'user',
                        content: prompt,
                    },
                ],
                max_tokens: 1000,
            });

            var text = response.choices[0].message.content;

            if (!text) {
                return null;
            }

            //try to parse the text if it is a json
            try {
                text = JSON.parse(text);
            } catch (error) {
                //do nothing
            }

            return text || null;

        } catch (error) {
            console.error('Error generating text:', error);
        }

        return null;
    }

}


=== ./services/UserAgentService.ts ===
import axios from "axios";
import crypto from "crypto";
import { NextRequest } from "next/server"; 
import { UserAgentData } from "@/types/UserSessionTypes";
import redis from "@/libs/redis"; 
import { GeoLocation, OSPattern, OSName, DeviceType, BrowserName } from "@/types/UserAgent";


export default class UserAgentService {
  private static readonly osPatterns: OSPattern[] = [
    { pattern: /Windows NT/i, name: OSName.Windows },
    { pattern: /Mac OS X/i, name: OSName.macOS },
    { pattern: /Android/i, name: OSName.Android },
    { pattern: /(iPhone|iPad|iPod)/i, name: OSName.iOS },
    { pattern: /CrOS/i, name: OSName.ChromeOS },
    { pattern: /Linux/i, name: OSName.Linux },
    { pattern: /X11/i, name: OSName.Unix }
  ];

  private static async getGeoLocationFromMaxMind(ip: string): Promise<GeoLocation> {
    const cacheKey = `geo:location:${ip}`;
    const cached = await redis.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }

    const accountId = process.env.MAXMIND_ACCOUNT_ID;
    const apiKey = process.env.MAXMIND_API_KEY;

    if (!accountId || !apiKey) {
      throw new Error("MaxMind credentials are missing in environment variables.");
    }

    const auth = Buffer.from(`${accountId}:${apiKey}`).toString("base64");

    try {
      const response = await axios.get(`https://geoip.maxmind.com/geoip/v2.1/city/${ip}`, {
        headers: {
          Authorization: `Basic ${auth}`
        },
        timeout: 5000 // 5 saniyelik timeout
      });

      const data = response.data;
      const location: GeoLocation = {
        city: data.city?.names?.en ?? null,
        state: data.subdivisions?.[0]?.names?.en ?? null,
        country: data.country?.names?.en ?? null
      };

      await redis.set(cacheKey, JSON.stringify(location), "EX", 86400); // 1 gün cache

      return location;
    } catch (error: any) {
      if (axios.isAxiosError(error)) {
        console.error("MaxMind request failed:", {
          message: error.message,
          status: error.response?.status,
          data: error.response?.data
        });
      } else {
        console.error("Unexpected error during MaxMind lookup:", error);
      }

      return { city: null, state: null, country: null };
    }
  }


  public static getOS(userAgent: string): OSName {
    for (const { pattern, name } of UserAgentService.osPatterns) {
      if (pattern.test(userAgent)) return name;
    }
    return OSName.Unknown;
  }

  public static getDeviceType(userAgent: string): DeviceType {
    if (/iPad/i.test(userAgent)) return DeviceType.Tablet;
    if (/Android/i.test(userAgent) && !/Mobile/i.test(userAgent)) return DeviceType.Tablet;

    const mobilePattern = /(iPhone|iPod|Mobile|Android.*Mobile|BlackBerry|Windows Phone)/i;
    if (mobilePattern.test(userAgent)) return DeviceType.Mobile;

    return DeviceType.Desktop;
  }

  public static async getGeoLocation(ip: string): Promise<GeoLocation> {
    return UserAgentService.getGeoLocationFromMaxMind(ip);
  }

  public static getBrowser(userAgent: string): BrowserName {
    if (/Edg/i.test(userAgent)) return BrowserName.Edge;
    if (/OPR/i.test(userAgent)) return BrowserName.Opera;
    if (/Chrome/i.test(userAgent)) return BrowserName.Chrome;
    if (/Safari/i.test(userAgent) && !/Chrome/i.test(userAgent)) return BrowserName.Safari;
    if (/Firefox/i.test(userAgent)) return BrowserName.Firefox;
    if (/MSIE|Trident/i.test(userAgent)) return BrowserName.IE;
    if (/Postman/i.test(userAgent)) return BrowserName.Postman;
    return BrowserName.Unknown;
  }

  public static async generateDeviceFingerprint(ip: string, userAgent: string, acceptLanguage: string): Promise<string> {
    const rawFingerprint = `${ip}|${userAgent}|${acceptLanguage}`;
    return crypto.createHash("sha256").update(rawFingerprint).digest("hex");
  }

  public static async parseRequest(request: NextRequest): Promise<UserAgentData> {
    const userAgent = request.headers.get("user-agent") || "";
    const rawIp =
      request.headers.get("x-forwarded-for") ||
      request.headers.get("x-real-ip") ||
      request.headers.get("cf-connecting-ip") ||
      request.headers.get("x-client-ip") ||
      request.headers.get("x-cluster-client-ip") ||
      request.headers.get("x-forwarded");

    const ip = typeof rawIp === "string" ? rawIp.split(",")[0].trim() : rawIp;
    return await UserAgentService.parse(userAgent, ip as string);
  }

  public static async parse(userAgent?: string, ip?: string): Promise<UserAgentData> {
    const geo = ip ? await UserAgentService.getGeoLocation(ip) : null;

    return {
      os: userAgent ? UserAgentService.getOS(userAgent) : OSName.Unknown,
      device: userAgent ? UserAgentService.getDeviceType(userAgent) : DeviceType.Desktop,
      city: geo?.city ?? "Unknown",
      state: geo?.state ?? "Unknown",
      country: geo?.country ?? "Unknown",
      ip: ip ?? "Unknown",
      browser: userAgent ? UserAgentService.getBrowser(userAgent) : BrowserName.Unknown,
      deviceFingerprint: userAgent && ip
        ? crypto.createHash("sha256").update(`${ip}|${userAgent}`).digest("hex")
        : null
    };
  }
}


=== ./services/PostService/LikeService.ts ===
import prisma from '@/libs/prisma';
import UserAgentService from '@/services/UserAgentService';

export default class PostLikeService {


  /**
   * Add a like to a post.
   * Handles both authenticated (userId) and anonymous (ip + deviceFingerprint) likes.
   */
  static async likePost(params: {
    postId: string;
    userId?: string;
    request: NextRequest; // Optional request for generating device fingerprint
  }) {
    const { postId, userId } = params;

    const parsedUserAgent = await UserAgentService.parseRequest(params.request);
    const ipAddress = parsedUserAgent.ip;
    const deviceFingerprint = parsedUserAgent.deviceFingerprint;

    if (!postId || (!userId && (!ipAddress || !deviceFingerprint))) {
      throw new Error('Insufficient data to create a like.');
    }

    const existingLike = await prisma.like.findFirst({
      where: {
        postId,
        OR: userId
          ? [{ userId }]
          : ipAddress && deviceFingerprint
            ? [{ ipAddress, deviceFingerprint }]
            : [],
      },
    });

    if (existingLike) {
      throw new Error('Post already liked.');
    }

    return await prisma.like.create({
      data: {
        postId,
        userId,
        ipAddress,
        deviceFingerprint,
      },
    });
  }

  /**
   * Remove a like from a post.
   * Works for both user and anonymous likes.
   */
  static async unlikePost(params: {
    postId: string;
    userId?: string;
    request: NextRequest; // Optional request for generating device fingerprint
  }) {
    const { postId, userId } = params;

    const parsedUserAgent = await UserAgentService.parseRequest(params.request);
    const ipAddress = parsedUserAgent.ip;
    const deviceFingerprint = parsedUserAgent.deviceFingerprint;

    if (!postId || (!userId && (!ipAddress || !deviceFingerprint))) {
      throw new Error('Insufficient data to remove like.');
    }

    const like = await prisma.like.findFirst({
      where: {
        postId,
        OR: [
          ...(userId ? [{ userId }] : []),
          ...(!userId && ipAddress && deviceFingerprint ? [{ ipAddress, deviceFingerprint }] : [])
        ],
      },
    });

    if (!like) {
      throw new Error('Like not found.');
    }

    await prisma.like.delete({
      where: {
        likeId: like.likeId, // Assuming likeId is the primary key
      },
    });
  }

  /**
   * Check if the post is liked by the given user or anonymous info.
   */
  static async isPostLiked(params: {
    postId: string;
    userId?: string;
    request: NextRequest; // Optional request for generating device fingerprint
  }): Promise<boolean> {
    const { postId, userId } = params;

    const parsedUserAgent = await UserAgentService.parseRequest(params.request);
    const ipAddress = parsedUserAgent.ip;
    const deviceFingerprint = parsedUserAgent.deviceFingerprint;

    const like = await prisma.like.findFirst({
      where: {
        postId,
        OR: [
          ...(userId ? [{ userId }] : []),
          ...(!userId && ipAddress && deviceFingerprint ? [{ ipAddress, deviceFingerprint }] : [])
        ],
      },
    });

    return !!like;
  }

  /**
   * Count total likes for a post
   */
  static async countLikes(postId: string): Promise<number> {
    return await prisma.like.count({
      where: { postId },
    });
  }
}


=== ./services/PostService/index.ts ===
import { Post, PostWithData } from '@/types/BlogTypes';
import prisma from '@/libs/prisma';
import { MetadataRoute } from 'next';
import redisInstance from '@/libs/redis';

export default class PostService {
    private static CACHE_KEY = 'sitemap:blog';

    private static sqlInjectionRegex = /(\b(ALTER|CREATE|DELETE|DROP|EXEC(UTE){0,1}|INSERT( +INTO){0,1}|MERGE|SELECT|UPDATE|UNION( +ALL){0,1})\b)|(--)|(\b(AND|OR|NOT|IS|NULL|LIKE|IN|BETWEEN|EXISTS|CASE|WHEN|THEN|END|JOIN|INNER|LEFT|RIGHT|OUTER|FULL|HAVING|GROUP|BY|ORDER|ASC|DESC|LIMIT|OFFSET)\b)/i; // SQL injection prevention


    private static postWithDataSelect = {
        postId: true,
        title: true,
        description: true,
        slug: true,
        keywords: true,
        image: true,
        authorId: true,
        categoryId: true,
        createdAt: true,
        status: true,
        views: true,
        content: true, // Include content only if postId or slug is provided
        deletedAt: true,
        category: {
            select: {
                categoryId: true,
                title: true,
                slug: true,
                image: true,
            },
        },
        author: {
            select: {
                userId: true,
                name: true,
                profilePicture: true,
            },
        },
    };


    /**
     * Creates a new post with regex validation.
     * @param data - Post data
     * @returns The created post
     */
    static async createPost(data: Omit<Post, 'postId'>): Promise<Post> {

        var { title, content, description, slug, keywords, image, authorId, categoryId, status, createdAt } = data;

        // Validate input
        if (!title || !content || !description || !slug || !keywords || !authorId || !categoryId) {
            throw new Error('All fields are required.');
        }

        if (keywords && typeof keywords === 'string') {
            keywords = (keywords as string).split(',');
        }

        // Validate input
        const existingPost = await prisma.post.findFirst({
            where: { OR: [{ title }, { slug }] },
        });

        if (existingPost) {
            throw new Error('Post with the same title or slug already exists.');
        }

        await redisInstance.del(this.CACHE_KEY);

        return await prisma.post.create({ data });
    }

    /**
     * Retrieves all posts with optional pagination and search.
     * @param page - The page number
     * @param perPage - The number of posts per page
     * @param search - The search query
     * @returns An array of posts
     */
    static async getAllPosts(
        data: {
            page: number;
            pageSize: number;
            search?: string;
            categoryId?: string;
            authorId?: string;
            status?: string; //ALL, PUBLISHED, DRAFT
            postId?: string;
            slug?: string;
        }): Promise<{ posts: PostWithData[], total: number }> {

        const { page, pageSize, search, categoryId, status, authorId, postId, slug } = data;
        // Validate search query
        if (search && this.sqlInjectionRegex.test(search)) {
            throw new Error('Invalid search query.');
        }

        //ALL, PUBLISHED, DRAFT

        const now = new Date();
        // Get posts by search query
        const query = {
            skip: (page - 1) * pageSize,
            take: pageSize,
            orderBy: {
                createdAt: 'desc',
            },
            select: this.postWithDataSelect,
            where: {
                OR: [
                    {
                        title: {
                            contains: search || '',
                            mode: 'insensitive',
                        },
                    },
                    {
                        description: {
                            contains: search || '',
                            mode: 'insensitive',
                        },
                    }
                ],
                authorId: authorId ? authorId : undefined,
                postId: postId ? postId : undefined,
                categoryId: categoryId ? categoryId : undefined,
                status: status ? status === "ALL" ? undefined : status : "PUBLISHED",
                createdAt: {
                    lte: status === "ALL" ? undefined : now,
                },
                deletedAt: {
                    equals: status === "ALL" ? undefined : null,
                },
                slug: slug ? slug : undefined,
            },
        };

        const countQuery = {
            //skip: query.skip,
            //take: query.take,
            where: query.where,
        };



        const transaction = await prisma.$transaction([
            prisma.post.findMany(query as any),
            prisma.post.count(countQuery as any),
        ]);


        return { posts: transaction[0] as PostWithData[], total: transaction[1] };


    }

    /**
     * Updates a post by its ID.
     * @param postId - The ID of the post
     * @param data - The updated post data
     * @returns The updated post
     */
    static async updatePost(data: Post): Promise<Post> {

        const { postId, title, content, description, slug, keywords, image, authorId, categoryId, status, createdAt } = data;

        // Validate input
        if (!title || !content || !description || !slug || !keywords || !authorId || !categoryId) {
            throw new Error('All fields are required.');
        }

        if (keywords && typeof keywords === 'string') {
            data.keywords = (keywords as string).split(',');
        }

        // Update the post
        const post = await prisma.post.update({
            where: { postId },
            data,
        });

        await redisInstance.del(this.CACHE_KEY);

        return post;
    }

    /**
     * Deletes a post by its ID.
     * @param postId - The ID of the post
     */
    static async deletePost(postId: string): Promise<void> {

        await redisInstance.del(this.CACHE_KEY);
        
        await prisma.post.update({
            where: { postId },
            data: {
                status: 'ARCHIVED',
                deletedAt: new Date(),
            },
        });
    }

    /**
     * Save one view to the post
     * @param postId - The ID of the post
     * @returns The updated post
     * */
    static async incrementViewCount(postId: string): Promise<Post> {
        const post = await prisma.post.update({
            where: { postId },
            data: {
                views: {
                    increment: 1,
                },
            },
        });

        return post;
    }


    //generate site map how do i do use: 
    static async generateSiteMap(): Promise<MetadataRoute.Sitemap> {
        const { posts } = await this.getAllPosts({ page: 1, pageSize: 1000, search: '', categoryId: '', status: 'PUBLISHED' });
        return posts.map(post => {
            return {
                url: `/blog/${post.slug}`,
                lastModified: post.createdAt.toISOString(),
                changeFrequency: 'daily',
                priority: 0.7,
            };
        }
        );
    }


    /**
     * Retrieves a post by its ID.
     * @param postId - The ID of the post
     * @returns The post
     */
    static async getPostById(postId: string): Promise<Post | null> {
        return await prisma.post.findUnique({
            where: { postId },
        });

    }

    /**
     * Get all blogpost slugs with postName and categorySlug
     * @returns Array of objects with postName and categorySlug
     * */
    static async getAllPostSlugs(): Promise<{ title: string; slug: string; categorySlug: string }[]> {
        const posts = await prisma.post.findMany({
            where: {
                status: 'PUBLISHED',
                deletedAt: null,
                createdAt: {
                    lte: new Date(),
                }
            },
            select: {
                title: true,
                slug: true,
                category: {
                    select: {
                        slug: true,
                    }
                }
            }
        });

        return posts.map(post => ({
            title: post.title,
            slug: post.slug,
            categorySlug: post.category.slug,
        }));
    }

}

=== ./services/SocialMediaService/DiscordService.ts ===

import axios from 'axios';

const DISCORD_WEBHOOK_URL = process.env.DISCORD_WEBHOOK_URL;

export default class DiscordService {

    static async sendWebhookMessage(message: string) {
        try {
            const response = await axios.post(
                DISCORD_WEBHOOK_URL as string,
                {
                    content: message,
                },
                {
                    headers: {
                        "Content-Type": "application/json",
                    },
                },
            );
        } catch (error) {
            console.error(error);
        }
    }
}




=== ./services/UserService/index.ts ===
import prisma from "@/libs/prisma";
import { User, UserRole , SafeUser } from "@/types/UserTypes";

// Libraries
import bcrypt from "bcrypt";

// Utils
import FieldValidater from "@/utils/FieldValidater";

export default class UserService {

    /**
     * Error Messages
     * These are the error messages that can be thrown by the service.
     * TODO: Add more error messages as needed.
     */
    static INVALID_EMAIL = "INVALID_EMAIL";
    static INVALID_PASSWORD_FORMAT = "INVALID_PASSWORD_FORMAT";
    static USER_NOT_FOUND = "USER_NOT_FOUND";
    static EMAIL_ALREADY_EXISTS = "EMAIL_ALREADY_EXISTS";

    
    /**
     * Omit sensitive fields from the user object.
     * @param user - The user object.
     * @returns The user object without the password, resetToken, and resetTokenExpiry.
     */
    static omitSensitiveFields(user: User): SafeUser {
        const omitted : SafeUser = {
            userId: user.userId,
            email: user.email,
            phone: user.phone,
            name: user.name,
            userRole: user.userRole,
            createdAt: user.createdAt,
            updatedAt: user.updatedAt,
            profilePicture: user.profilePicture,
            otpMethods: user.otpMethods,
        };

        return omitted;

    }


    /**
     * Creates a new user in the database after validating input and hashing the password.
     * @param data - Partial user data to create the user.
     * @returns The created user without sensitive fields like password.
     */
    static async create({ email, password, name , phone, userRole } : {
        email: string,
        password: string,
        name: string,
        phone?: string,
        userRole?: string
    }): Promise<SafeUser> {

        // Validate email and password
        if (!email || !FieldValidater.isEmail(email)) {
            throw new Error(this.INVALID_EMAIL);
        }

        if (!password || !FieldValidater.isPassword(password)) {
            throw new Error(this.INVALID_PASSWORD_FORMAT);
        }

        // Check if the email is already in use
        const existingUser = await prisma.user.findUnique({
            where: { email },
        });

        if (existingUser) {
            throw new Error(this.EMAIL_ALREADY_EXISTS);
        }

        // Hash the password before saving
        const hashedPassword = await bcrypt.hash(password, 10);

        // Create the user in the database
        const user = await prisma.user.create({
            data: {
                email,
                password: hashedPassword, // Store the hashed password
                name,
                phone,
                userRole: userRole ? userRole as UserRole : "USER", // Default to 'USER' role if not provided
            }
        });

        // Exclude sensitive fields from the response
        return this.omitSensitiveFields(user);

    }

    /**
     * Retrieves all users from the database.
     * @param skip - The number of records to skip.
     * @param take - The number of records to take.
     * @param userId - The user ID to filter by.
     * @param tenantId - The tenant ID to filter by.
     * @param search - The search term to filter by.
     * @returns A list of users.
     */
    static async getAll({
        page,
        pageSize,
        search,
        userId,
    } : { 
        page: number,
        pageSize: number,
        search?: string,
        userId?: string
    }): Promise<{ users: SafeUser[], total: number }> {


        const queryOptions = {
            skip : (page - 1) * pageSize,
            take : pageSize,
            where: {
                userId: userId ? userId : undefined,
                OR: [
                    { email: { contains: search ? search : '' } },
                    { name: { contains: search ? search : '' } },
                ],
            }
        };

        // Get all users
        const [users, total] = await prisma.$transaction([
            prisma.user.findMany(queryOptions),
            prisma.user.count({ where: queryOptions.where }),
        ]);

        // Exclude sensitive fields from the response
        const usersWithoutPassword = users.map((user) => this.omitSensitiveFields(user));

        return { users: usersWithoutPassword, total };
    }

    /**
     * Retrieves a user from the database by ID.
     * @param userId - The user ID to retrieve.
     * @returns The user details.
     */
    static async getById(userId: string): Promise<SafeUser> {
        
        // Get the user by ID
        const user = await prisma.user.findUnique({
            where: { userId },
        });

        if (!user) {
            throw new Error(this.USER_NOT_FOUND);
        }

        return this.omitSensitiveFields(user);
    }

    /**
     * Updates a user in the database by ID.
     * @param userId - The user ID to update.
     * @param data - Partial user data to update.
     * @returns The updated user details.
     */
    static async update(data: Partial<SafeUser>): Promise<SafeUser> {

        if (!data.userId) {
            throw new Error(this.USER_NOT_FOUND);
        }

        // Get the user by ID
        const user = await prisma.user.findUnique({
            where: { userId: data.userId },
        });

        if (!user) {
            throw new Error(this.USER_NOT_FOUND);
        }

        // Update the user in the database
        const updatedUser = await prisma.user.update({
            where: { userId: data.userId },
            data : data as User,
        });

        // Exclude sensitive fields from the response
        return this.omitSensitiveFields(updatedUser);

    }

    /**
     * Deletes a user from the database by ID.
     * @param userId - The user ID to delete.
     * @returns The deleted user details.
     */
    static async delete(userId: string): Promise<void> {

        // Get the user by ID
        const user = await prisma.user.findUnique({
            where: { userId },
        });

        if (!user) {
            throw new Error(this.USER_NOT_FOUND);
        }

        // Delete the user from the database
        await prisma.user.delete({
            where: { userId },
        });

        return;
    }


    /**
     * Retrieves a user from the database by email.
     * @param email - The email to retrieve.
     * @returns The user details.
     */
    static async getByEmail(email: string): Promise<User | null> {
        return prisma.user.findUnique({
            where: { email },
        });
    }

}








=== ./services/AppointmentService/SlotService.ts ===
import redisInstance from '@/libs/redis'
import { Slot } from '@/types/CalendarTypes'
import { format, parse } from 'date-fns'
import { separateDateTimeWithTimeZone } from '@/helpers/TimeHelper'

export default class SlotService {
  static SLOT_PREFIX = 'slot:{date}:{time}'

  private static makeKey(date: string, time: string): string {
    return this.SLOT_PREFIX.replace('{date}', date).replace('{time}', time)
  }

  private static async scanKeys(pattern: string): Promise<string[]> {
    const keys: string[] = []
    let cursor = '0'
    do {
      const [next, found] = await redisInstance.scan(cursor, 'MATCH', pattern, 'COUNT', 100)
      keys.push(...found)
      cursor = next
    } while (cursor !== '0')
    return keys
  }

  private static async getOverlappingSlots(
    date: string,
    startTime: string,
    endTime: string
  ): Promise<Slot | null> {
    const pattern = this.makeKey(date, '*')
    const keys = await this.scanKeys(pattern)

    const newStart = parse(startTime, 'HH:mm', new Date())
    const newEnd = parse(endTime, 'HH:mm', new Date())

    for (const key of keys) {
      const value = await redisInstance.get(key)
      if (value) {
        const slot: Slot = JSON.parse(value)
        const slotStart = parse(format(slot.startTime, 'HH:mm'), 'HH:mm', new Date())
        const slotEnd = parse(format(slot.endTime, 'HH:mm'), 'HH:mm', new Date())
        if (newStart < slotEnd && newEnd > slotStart) {
          return slot
        }
      }
    }
    return null
  }

  static async createSlot(slot: Slot): Promise<Slot> {
    const { date: startDate, time: startTime } = separateDateTimeWithTimeZone(slot.startTime)
    const { date: endDate, time: endTime } = separateDateTimeWithTimeZone(slot.endTime)

    if (startDate !== endDate) throw new Error('Slot startTime and endTime must be on the same date')
    if (startTime >= endTime) throw new Error('Slot startTime must be before endTime')

    const overlappingSlot = await this.getOverlappingSlots(startDate, startTime, endTime)
    if (overlappingSlot) {
      throw new Error(
        `Overlapping slot exists: ${format(overlappingSlot.startTime, 'HH:mm')} - ${format(overlappingSlot.endTime, 'HH:mm')}`
      )
    }

    const key = this.makeKey(startDate, startTime)
    const ttlSeconds = 60 * 60 * 24 * 14 // 14 gün sakla
    await redisInstance.set(key, JSON.stringify(slot), 'EX', ttlSeconds)
    return slot
  }

  static async getSlot(date: string, time: string): Promise<Slot | null> {
    const key = this.makeKey(date, time)
    const value = await redisInstance.get(key)
    return value ? (JSON.parse(value) as Slot) : null
  }

  static async updateSlot(slot: Slot): Promise<Slot> {
    const { date, time } = separateDateTimeWithTimeZone(slot.startTime)
    const key = this.makeKey(date, time)
    await redisInstance.set(key, JSON.stringify(slot))
    return slot
  }

  static async deleteSlot(date: string, time: string): Promise<boolean> {
    const key = this.makeKey(date, time)
    const result = await redisInstance.del(key)
    return result > 0
  }

  static async getAllSlotsForDate(date: string): Promise<Slot[]> {
    const pattern = this.makeKey(date, '*')
    const keys = await this.scanKeys(pattern)
    if (!keys.length) return []
    const values = await redisInstance.mget(keys)
    return values.filter((v): v is string => !!v).map((v) => JSON.parse(v) as Slot)
  }

  static async emptySlotsForDate(date: Date): Promise<void> {
    const { date: formattedDate } = separateDateTimeWithTimeZone(date)
    const pattern = this.makeKey(formattedDate, '*')
    const keys = await this.scanKeys(pattern)
    if (keys.length) await redisInstance.del(...keys)
  }

  static async getAllSlotsForDateRange(params: {
    startDate?: string
    endDate?: string
  }): Promise<{ slots: Slot[]; total: number }> {
    const { startDate, endDate } = params
    if (!startDate && !endDate)
      throw new Error('At least one of startDate or endDate must be provided')

    const start = startDate ? new Date(startDate) : new Date('1970-01-01')
    const end = endDate ? new Date(endDate) : new Date('2100-01-01')

    if (start > end) throw new Error('startDate cannot be after endDate')

    const dates: string[] = []
    for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
      dates.push(format(new Date(d), 'yyyy-MM-dd'))
    }

    const allSlots = (await Promise.all(dates.map((d) => this.getAllSlotsForDate(d)))).flat()
    return { slots: allSlots, total: allSlots.length }
  }
}


=== ./services/AppointmentService/SlotTemplateService.ts ===
import { Day, Slot, SlotTemplate } from "@/types/CalendarTypes";

import redisInstance from '@/libs/redis';

export default class SlotTemplateService {

    static SLOT_TEMPLATE_PREFIX = 'slot_template:';

    static async createOrUpdateSlotTemplate(day: Day, slots: Slot[]): Promise<SlotTemplate> {
        const key = `${this.SLOT_TEMPLATE_PREFIX}${day}`;
        const template: SlotTemplate = { day, slots };
        await redisInstance.set(key, JSON.stringify(template));
        return template;
    }

    static async getSlotTemplate(day: Day): Promise<SlotTemplate> {
        const key = `${this.SLOT_TEMPLATE_PREFIX}${day}`;
        const value = await redisInstance.get(key);
        if (value) {
            return JSON.parse(value);
        }

        return { day, slots: [] };

    }

    static async emptySlotTemplate(day: Day): Promise<SlotTemplate> {
        const key = `${this.SLOT_TEMPLATE_PREFIX}${day}`;
        const template: SlotTemplate = { day, slots: [] };
        await redisInstance.set(key, JSON.stringify(template));
        return template;
    }

    static async getAllSlotTemplates(): Promise<SlotTemplate[]> {
        const keys = await redisInstance.keys(`${this.SLOT_TEMPLATE_PREFIX}*`);
        if (keys.length === 0) return [];

        const templates = await Promise.all(keys.map(async (key) => {
            const value = await redisInstance.get(key);
            if (value) {
                return JSON.parse(value);
            }
            return null;
        }));
        return templates.filter((template): template is SlotTemplate => template !== null);
    }
}

=== ./services/AppointmentService/index.ts ===
import prisma from '@/libs/prisma'
import Logger from '@/libs/logger'
import { Appointment, AppointmentStatus } from '@/types/CalendarTypes'
import SlotService from './SlotService'
import { separateDateTimeWithTimeZone } from '@/helpers/TimeHelper'

export default class AppointmentService {
  static APPOINTMENT_PREFIX = 'appointment:{date}:{time}'

  /** Utility: Get appointment or throw */
  private static async getAppointmentByIdOrThrow(appointmentId: string): Promise<Appointment> {
    const appointment = await prisma.appointment.findUnique({ where: { appointmentId } })
    if (!appointment) throw new Error(`Appointment not found: ${appointmentId}`)
    return appointment
  }

  /** 🔹 Appointment creation + slot capacity check */
  static async createAppointment(appointment: Appointment): Promise<Appointment> {
    const { date, time } = separateDateTimeWithTimeZone(appointment.startTime)
    const slot = await SlotService.getSlot(date, time)
    if (!slot) throw new Error(`Slot not found for ${date} ${time}`)
    if (slot.capacity <= 0) throw new Error('No available capacity for this slot')

    const created = await prisma.$transaction(async (tx) => {
      const newApp = await tx.appointment.create({ data: appointment })
      if (slot.capacity > 0) slot.capacity -= 1
      await SlotService.updateSlot(slot)
      return newApp
    })

    Logger.info(`Appointment created for ${date} ${time}`)
    return created
  }

  /** Retrieve appointment */
  static async getAppointmentById(appointmentId: string): Promise<Appointment | null> {
    return prisma.appointment.findUnique({ where: { appointmentId } })
  }

  /** Retrieve by datetime range */
  static async getAppointmentsByDatetimeRange(startTime: Date, endTime: Date): Promise<Appointment[]> {
    return prisma.appointment.findMany({
      where: { startTime: { gte: startTime }, endTime: { lte: endTime } },
      orderBy: { startTime: 'asc' },
    })
  }

  /** Update appointment (immutable date/time) */
  static async updateAppointment(
    appointmentId: string,
    updates: Partial<Appointment>
  ): Promise<Appointment> {
    const existing = await this.getAppointmentByIdOrThrow(appointmentId)
    if (updates.startTime && updates.startTime.getTime() !== existing.startTime.getTime())
      throw new Error('Cannot change appointment time')
    if (updates.endTime && updates.endTime.getTime() !== existing.endTime.getTime())
      throw new Error('Cannot change appointment duration')

    const updated = await prisma.appointment.update({ where: { appointmentId }, data: updates })
    Logger.info(`Appointment ${appointmentId} updated`)
    return updated
  }

  /** 🔹 Book appointment — atomic */
  static async bookAppointment(appointmentId: string): Promise<Appointment> {
    const existing = await this.getAppointmentByIdOrThrow(appointmentId)
    if (existing.status === 'BOOKED') throw new Error('Already booked')

    const { date, time } = separateDateTimeWithTimeZone(existing.startTime)
    const slot = await SlotService.getSlot(date, time)
    if (!slot) throw new Error('Slot not found')

    if (slot.capacity <= 0) throw new Error('No available capacity')

    const updated = await prisma.$transaction(async (tx) => {
      const booked = await tx.appointment.update({
        where: { appointmentId },
        data: { status: 'BOOKED' },
      })
      if (slot.capacity > 0) slot.capacity -= 1
      await SlotService.updateSlot(slot)
      return booked
    })

    Logger.info(`Appointment ${appointmentId} booked`)
    return updated
  }

  /** 🔹 Cancel appointment — atomic restore */
  static async cancelAppointment(appointmentId: string): Promise<Appointment> {
    const existing = await this.getAppointmentByIdOrThrow(appointmentId)
    if (existing.status === 'CANCELLED') throw new Error('Already cancelled')

    const { date, time } = separateDateTimeWithTimeZone(existing.startTime)
    const slot = await SlotService.getSlot(date, time)

    const updated = await prisma.$transaction(async (tx) => {
      const cancelled = await tx.appointment.update({
        where: { appointmentId },
        data: { status: 'CANCELLED' },
      })
      if (slot) {
        slot.capacity += 1
        await SlotService.updateSlot(slot)
      }
      return cancelled
    })

    Logger.info(`Appointment ${appointmentId} cancelled`)
    return updated
  }

  /** Paginated + filtered listing */
  static async getAllAppointments(params: {
    page: number
    pageSize: number
    startDate?: string
    endDate?: string
    status?: AppointmentStatus | 'ALL'
    appointmentId?: string
    email?: string
    name?: string
  }): Promise<{ appointments: Appointment[]; total: number }> {
    const { page, pageSize, startDate, endDate, status, appointmentId, email, name } = params
    const where: any = {
      startTime: startDate ? { gte: new Date(startDate) } : undefined,
      endTime: endDate ? { lte: new Date(endDate) } : undefined,
      appointmentId: appointmentId || undefined,
      email: email || undefined,
      name: name || undefined,
      status: status && status !== 'ALL' ? status : undefined,
    }

    const [appointments, total] = await prisma.$transaction([
      prisma.appointment.findMany({
        skip: (page - 1) * pageSize,
        take: pageSize,
        where,
        orderBy: { createdAt: 'desc' },
      }),
      prisma.appointment.count({ where }),
    ])

    return { appointments, total }
  }
}


=== ./services/ContactFormService.ts ===
import { ContactForm } from '@/types/ContactTypes';
import prisma from '@/libs/prisma';

export default class ContactFormService {

    private static sqlInjectionRegex = /(\b(ALTER|CREATE|DELETE|DROP|EXEC(UTE){0,1}|INSERT( +INTO){0,1}|MERGE|SELECT|UPDATE|UNION( +ALL){0,1})\b)|(--)|(\b(AND|OR|NOT|IS|NULL|LIKE|IN|BETWEEN|EXISTS|CASE|WHEN|THEN|END|JOIN|INNER|LEFT|RIGHT|OUTER|FULL|HAVING|GROUP|BY|ORDER|ASC|DESC|LIMIT|OFFSET)\b)/i; // SQL injection prevention

    /**
     * Creates a new contact form with regex validation.
     * @param data - Contact form data
     * @returns The created contact form
     */
    static async createContactForm(data: {
        name: string;
        email: string;
        message: string;
        phone: string;
    }): Promise<any> {
            
            var { name, email, message, phone } = data;
    
            // Validate input
            if (!name || !email || !message) {
                throw new Error('All fields are required.');
            }
        
            // Create the contact form
            const contactForm = await prisma.contactForm.create({
                data: {
                    name,
                    email,
                    message,
                    phone,
                },
            });
    
            return contactForm;
    
        }

    /**
     * Retrieves all contact forms with optional pagination and search.
     * @param page - The page number
     * @param pageSize - The page size
     * @param search - The search query
     * @returns The contact forms and total count
     * */
    static async getAllContactForms(page: number, pageSize: number, search?: string): Promise<{ contactForms: ContactForm[], total: number }> {

        if (search && this.sqlInjectionRegex.test(search)) {
            throw new Error('Invalid search query.');
        }

        const contactForms = await prisma.contactForm.findMany({
            take: pageSize,
            skip: page * pageSize,
            where: {
                OR: [
                    { name: { contains: search } },
                    { email: { contains: search } },
                    { message: { contains: search } },
                    { phone: { contains: search } },
                ],
            },
        });

        const total = await prisma.contactForm.count();

        return { contactForms, total };
    }

    /**
     * Retrieves a contact form by its ID.
     * @param contactFormId - The contact form ID
     * @returns The contact form
     */
    static async getContactFormById(contactId: string): Promise<ContactForm | null> {
        return await prisma.contactForm.findUnique({
            where: { contactId },
        });
    }

    static getRecentContactFormEntriesByPhoneOrEmail(phone: string, email: string): any {

        // Find recent contact form entries in 24 hours
      
        const recentEntries = prisma.contactForm.findMany({

            where: {
                OR: [
                    { phone: phone },
                    { email: email }
                ],
                createdAt: {
                    gte: new Date(new Date().getTime() - 24 * 60 * 60 * 1000)
                }
            }
        });

        return recentEntries;

    }

}




=== ./services/CategoryService.ts ===
import { Category } from '@/types/BlogTypes';
import prisma from '@/libs/prisma';

export default class CategoryService {

    private static sqlInjectionRegex = /(\b(ALTER|CREATE|DELETE|DROP|EXEC(UTE){0,1}|INSERT( +INTO){0,1}|MERGE|SELECT|UPDATE|UNION( +ALL){0,1})\b)|(--)|(\b(AND|OR|NOT|IS|NULL|LIKE|IN|BETWEEN|EXISTS|CASE|WHEN|THEN|END|JOIN|INNER|LEFT|RIGHT|OUTER|FULL|HAVING|GROUP|BY|ORDER|ASC|DESC|LIMIT|OFFSET)\b)/i; // SQL injection prevention


    /**
        * Creates a new category with regex validation.
        * @param data - Category data
        * @returns The created category
        */
    static async createCategory(data: {
        title: string;
        description: string;
        slug: string;
        image: string;
    }): Promise<any> {

        var { title, description, slug, image } = data;

        // Validate input
        if (!title || !description || !slug) {
            throw new Error('All fields are required.');
        }

        // Validate input
        const existingCategory = await prisma.category.findFirst({
            where: { OR: [{ title }, { slug }] },
        });

        if (existingCategory) {
            throw new Error('Category with the same name or slug already exists.');
        }

        // Create the category
        const category = await prisma.category.create({
            data: {
                title,
                description,
                slug,
                image,
            },
        });

        return category;

    }

    /**
     * Retrieves all categories with optional pagination and search.
     * @param page - The page number
     * @param pageSize - The page size
     * @param search - The search query
     * @returns The categories and total count
     */
    static async getAllCategories(page: number, pageSize: number, search?: string): Promise<{ categories: Category[], total: number }> {

        if (search && this.sqlInjectionRegex.test(search)) {
            throw new Error('Invalid search query.');
        }

        const where = search ? {
            OR: [
                { title: { contains: search } },
                { description: { contains: search } },
                { slug: { contains: search } },
            ],
        } : {};

        const categories = await prisma.category.findMany({
            where,
            skip: (page - 1) * pageSize,
            take: pageSize,
        });

        const total = await prisma.category.count({ where });

        return { categories, total };
    }

    /**
     * Retrieves a category by its ID.
     * @param categoryId - The ID of the category
     * @returns The requested category or null if not found
     */
    static async getCategoryById(categoryId: string): Promise<Category | null> {
        const category = await prisma.category.findUnique({
            where: { categoryId },
        });

        return category;
    }

    /**
     * Updates a category by its ID.
     * @param categoryId - The ID of the category
     * @param data - The updated category data
     * @returns The updated category
     */
    static async updateCategory(categoryId: string, data: {
        title: string;
        description: string;
        slug: string;
        image: string;
        keywords: string[];
    }): Promise<Category> {
            
            const { title, description, slug, image } = data;
    
            const category = await prisma.category.update({
                where: { categoryId },
                data: {
                    title,
                    description,
                    slug,
                    image,
                    keywords: { set: data.keywords },
                },
            });
    
            return category;
        }

    /**
     * Deletes a category by its ID.
     * @param categoryId - The ID of the category
     * @returns The deleted category
        */
    static async deleteCategory(categoryId: string): Promise<Category> {
        const category = await prisma.category.delete({
            where: { categoryId },
        });

        return category;
    }


    /**
     * Retrieves a category by its slug.
     * @param slug - The slug of the category
     * @returns The requested category or null if not found
     */
    static async getCategoryBySlug(slug: string): Promise<Category | null> {
        const category = await prisma.category.findFirst({
            where: { slug },
        });

        return category;
    }


    /**
     * Deletes all categories.
     * @returns The deleted categories
     * */
    static async deleteAllCategories(): Promise<void> {
        const categories = await prisma.category.deleteMany();

        return;
    }
}

=== ./services/ProjectService.ts ===
import prisma from "@/libs/prisma";
import redisInstance from "@/libs/redis";
import { Project } from "@/types/ProjectTypes";
import { MetadataRoute } from 'next';

export default class ProjectService {
    private static CACHE_KEY = 'sitemap:project';

    private static sqlInjectionRegex = /(\b(ALTER|CREATE|DELETE|DROP|EXEC(UTE){0,1}|INSERT( +INTO){0,1}|MERGE|SELECT|UPDATE|UNION( +ALL){0,1})\b)|(--)|(\b(AND|OR|NOT|IS|NULL|LIKE|IN|BETWEEN|EXISTS|CASE|WHEN|THEN|END|JOIN|INNER|LEFT|RIGHT|OUTER|FULL|HAVING|GROUP|BY|ORDER|ASC|DESC|LIMIT|OFFSET)\b)/i; // SQL injection prevention
    
    static async getAllProjects(
        data: {
            page: number;
            pageSize: number;
            projectId?: string;
            slug?: string;
            search?: string;
            onlyPublished?: boolean;
        }): Promise<{ projects: Project[], total: number }> {


        const { page, pageSize, search, onlyPublished , projectId, slug } = data;

        // Validate search query
        if (search && this.sqlInjectionRegex.test(search)) {
            throw new Error('Invalid search query.');
        }

        // Get posts by search query
        const query = {
            skip: (page - 1) * pageSize,
            take: pageSize,
            select: {
                projectId: true,
                title: true,
                description: true,
                slug: true,
                image: true,
                platforms: true,
                technologies: true,
                projectLinks: true,
                content: (slug || projectId) ? true : false,
            },
            where: {
                OR: [
                    {
                        title: {
                            contains: search || '',
                        },
                    },
                    {
                        description: {
                            contains: search || '',
                        },
                    }
                ],
                status: !onlyPublished ? undefined : 'PUBLISHED',
                projectId: projectId ? projectId : undefined,
                slug: slug ? slug : undefined,
            },
            orderBy: {
                createdAt: 'desc' as const,
            },
        };

        const countQuery = {
            skip: query.skip,
            take: query.take,
            where: query.where,
        };

        const transaction = await prisma.$transaction([
            prisma.project.findMany(query),
            prisma.project.count(countQuery),
        ]);

        return { projects: transaction[0] as Project[], total: transaction[1] };
    }

    static async getProjectById(projectId: string): Promise<Project | null> {
        return prisma.project.findUnique({
            where: {
                projectId,
            },
        });
    }

    static async createProject(data: Omit<Project, 'projectId'>): Promise<Project> {
        
        // Validate Fields
        const { title, description, slug, image, platforms, technologies, projectLinks } = data;

        if (!title || !description || !slug || !image || !platforms || !technologies || !projectLinks) {
            throw new Error('Missing required fields.');
        }

        await redisInstance.del(this.CACHE_KEY);

        return prisma.project.create({
            data,
        });
    }

    static async updateProject(data: Project): Promise<Project> {

        // Validate Fields
        const { title, description, slug, image, platforms, technologies, projectLinks } = data;
        
        if (!title || !description || !slug || !image || !platforms || !technologies || !projectLinks) {
            throw new Error('Missing required fields.');
        }

        await redisInstance.del(this.CACHE_KEY);

        return prisma.project.update({
            where: {
                projectId: data.projectId,
            },
            data,
        });
    }

    static async deleteProject(projectId: string): Promise<Project> {

        await redisInstance.del(this.CACHE_KEY);
        
        return prisma.project.delete({
            where: {
                projectId,
            },
        });
    }

    static async generateSiteMap(): Promise<MetadataRoute.Sitemap> {
        const projects = await prisma.project.findMany({
            select: {
                slug: true,
                updatedAt: true,
            },
        });

        return projects.map(project => {
            return {
                url: `/project/${project.slug}`,
                lastModified: project.updatedAt ? new Date(project.updatedAt) : new Date(),
                changeFrequency: 'daily',
                priority: 0.7,
            };
        });
    }

    static async getAllProjectSlugs(): Promise<{ title: string; slug: string }[]> {
       const projects = await prisma.project.findMany({
            select: {
                title: true,
                slug: true,
            },
            where: {
                status: 'PUBLISHED',
            },
        });

        return projects;
    }


}



=== ./services/CommentService.ts ===
import { Comment, CommentWithData } from "@/types/BlogTypes";
import prisma from "@/libs/prisma";

export default class CommentService {

    private static sqlInjectionRegex = /(\b(ALTER|CREATE|DELETE|DROP|EXEC(UTE){0,1}|INSERT( +INTO){0,1}|MERGE|SELECT|UPDATE|UNION( +ALL){0,1})\b)|(--)|(\b(AND|OR|NOT|IS|NULL|LIKE|IN|BETWEEN|EXISTS|CASE|WHEN|THEN|END|JOIN|INNER|LEFT|RIGHT|OUTER|FULL|HAVING|GROUP|BY|ORDER|ASC|DESC|LIMIT|OFFSET)\b)/i; // SQL injection prevention
    private static emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/
    private static commentRegex = /^[a-zA-Z0-9\s.,!?()]+$/;
    private static noHTMLRegex = /<[^>]*>?/gm;
    private static noJS = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi;

    /**
     * Creates a new comment with regex validation.
     * @param data - Comment data
     * @returns The created comment
     */

    static async createComment(data: Omit<Comment, 'commentId'>): Promise<Comment> {

        var { content, postId, parentId, email, name } = data;

        // Validate input
        if (!content || !postId || !email || !name) {
            throw new Error('All fields are required.');
        }

        // Check for SQL injection
        if (this.sqlInjectionRegex.test(content)) {
            throw new Error('SQL injection detected.');
        }

        // Validate email

        if (!this.emailRegex.test(email)) {
            throw new Error('Invalid email.');
        }

        // Validate comment content
        if (!this.commentRegex.test(content)) {
            throw new Error('Invalid comment content.');
        }

        // Sanitize input
        content = content.replace(this.noHTMLRegex, '');
        content = content.replace(this.noJS, '');

        

        // Validate input
        const existingComment = await prisma.comment.findFirst({
            where: { content },
        });

        if (existingComment) {
            throw new Error('Comment with the same content already exists.');
        }

        return await prisma.comment.create({ data });

    }

    /**
     * Retrieves all comments with optional pagination and search.
     * @param page - The page number
     * @param perPage - The number of comments per page
     * @param search - The search query
     * @param postId - The post ID
     * @returns An array of comments
     */
    static async getAllComments(
        data: {
            page: number;
            pageSize: number;
            search?: string;
            postId?: string;
            pending?: boolean;
        }): Promise<{ comments: CommentWithData[], total: number }> {

        const { page, pageSize, search, postId , pending } = data;

        // Validate search query
        if (search && this.sqlInjectionRegex.test(search)) {
            throw new Error('SQL injection detected.');
        }

        const comments = await prisma.comment.findMany({
            where: {
                postId,
                content: {
                    contains: search,
                },
                status: pending ? undefined : 'APPROVED',
            },
            orderBy: {
                createdAt: 'desc',
            },
            skip: (page - 1) * pageSize,
            take: pageSize,
            select: {
                commentId: true,
                content: true,
                email: true,
                name: true,
                postId: true,
                parentId: true,
                status: true,
                createdAt: true,
                post: {
                    select: {
                        title: true,
                        slug: true,
                        postId: true,
                        image: true,
                    },
                },
            },
        });

        const total = await prisma.comment.count({
            where: {
                postId,
                content: {
                    contains: search,
                },
            },
        });

        // @ts-ignore
        return { comments, total };
    }

    /**
     * Retrieves a comment by ID.
     * @param commentId - The comment ID
     * @returns The comment
     */
    static async getCommentById(commentId: string): Promise<Comment> {
        const comment = await prisma.comment.findUnique({
            where: { commentId },
        });

        if (!comment) {
            throw new Error('Comment not found.');
        }

        return comment;
    }

    /**
     * Deletes a comment by ID.
     * @param commentId - The comment ID
     * @returns The deleted comment
     */
    static async deleteComment(commentId: string): Promise<Comment> {
        const comment = await prisma.comment.delete({
            where: { commentId },
        });

        if (!comment) {
            throw new Error('Comment not found.');
        }

        return comment;
    }

    /**
     * Updates a comment by ID.
     * @param commentId - The comment ID
     * @param data - The comment data
     * @returns The updated comment
     */
    static async updateComment(data: Comment): Promise<Comment> {
        const { commentId, content, postId, parentId, email, name, status } = data;

        // Update the comment
        const comment = await prisma.comment.update({
            where: { commentId },
            data,
        });

        return comment;
    }
}




=== ./services/StatService.ts ===
import redis from "@/libs/redis";
import prisma from "@/libs/prisma";

export default class StatService {
  static REDIS_KEY = "stats:global";
  static CACHE_TTL_SECONDS = 320; // 5 dakika

  /**
   * Get all stats with Redis caching
   * @returns Cached or fresh stats
   */
  static async getAllStats() {
    // Önce Redis’te var mı kontrol et
    const cached = await redis.get(this.REDIS_KEY);
    if (cached) {
      return JSON.parse(cached);
    }

    // Yoksa veritabanından al
    const [
      totalPosts,
      totalCategories,
      totalUsers,
      totalViewsAggregate,
      totalComments
    ] = await prisma.$transaction([
      prisma.post.count(),
      prisma.category.count(),
      prisma.user.count(),
      prisma.post.aggregate({ _sum: { views: true } }),
      prisma.comment.count()
    ]);

    const stats = {
      totalPosts,
      totalCategories,
      totalUsers,
      totalViews: totalViewsAggregate._sum.views || 0,
      totalComments
    };

    console.log("Stats:", stats);

    // Redis’e yaz
    await redis.set(this.REDIS_KEY, JSON.stringify(stats), "EX", this.CACHE_TTL_SECONDS);

    return stats;
  }
}


=== ./services/SettingService.ts ===
//SettingService.tsx

import { Setting } from "@/types/SettingTypes";
import prisma from "@/libs/prisma";

export default class SettingService {

    static async getSettings(): Promise<Setting[]> {
        return await prisma.setting.findMany();
    }

    static async getSettingByKey(key: string): Promise<Setting | null> {
        return await prisma.setting.findFirst({
            where: {
                key: key
            }
        });
    }

    static async createSetting(key: string, value: string): Promise<Setting> {
        const existingSetting = await this.getSettingByKey(key);
        if (existingSetting) {
            return await prisma.setting.update({
                where: {
                    key: key
                },
                data: {
                    value: value
                }
            });
        }

        return await prisma.setting.create({
            data: {
                key: key,
                value: value
            }
        });
    }
    
    static async deleteSetting(key: string): Promise<Setting | null> {
        const existingSetting = await this.getSettingByKey(key);
        if (!existingSetting) {
            return null;
        }

        return await prisma.setting.delete({
            where: {
                key: key
            }
        });
    }

    static async updateSettings(settings: Setting[]): Promise<Setting[]> {
        const updatedSettings: Setting[] = [];
        for (const setting of settings) {
            const updatedSetting = await prisma.setting.upsert({
                where: {
                    key: setting.key
                },
                update: {
                    value: setting.value
                },
                create: {
                    key: setting.key,
                    value: setting.value
                }
            });
            updatedSettings.push(updatedSetting);
        }

        return updatedSettings;
    }

}

=== ./services/AuthService/SSOService/AppleService.ts ===
import axios from 'axios';
import jwt from 'jsonwebtoken';
import { SSOProfileResponse } from '@/types/SSOTypes';

export default class AppleService {

    // App URL
    static APPLICATION_HOST = process.env.APPLICATION_HOST;

    // Apple OAuth
    static APPLE_CALLBACK_PATH = "/api/auth/callback/apple";
    static APPLE_AUTH_URL = 'https://appleid.apple.com/auth/authorize';
    static APPLE_TOKEN_URL = 'https://appleid.apple.com/auth/token';
    static APPLE_CLIENT_ID = process.env.APPLE_CLIENT_ID!;
    static APPLE_TEAM_ID = process.env.APPLE_TEAM_ID!;
    static APPLE_KEY_ID = process.env.APPLE_KEY_ID!;
    static APPLE_PRIVATE_KEY = process.env.APPLE_PRIVATE_KEY!;



    /*
    * Create Apple SSO Link
    * @returns The SSO link.
    */
    static generateAuthUrl(): string {

        const params = {
            client_id: this.APPLE_CLIENT_ID,
            redirect_uri: `${this.APPLICATION_HOST}${this.APPLE_CALLBACK_PATH}`,
            response_type: 'code',
            scope: 'profile email', // Request access to profile and email
            access_type: 'offline', // Request a refresh token
            prompt: 'consent', // Force consent screen
        };

        return `${this.APPLE_AUTH_URL}?${new URLSearchParams(params).toString()}`;
    }




    /*
    * Generate Apple Client Secret
    * @returns The Apple client secret.
    */
    static generateClientSecret(): string {


        const payload = {
            iss: this.APPLE_TEAM_ID,
            iat: Math.floor(Date.now() / 1000),
            exp: Math.floor(Date.now() / 1000) + 3600, // 1 hour
            aud: 'https://appleid.apple.com',
            sub: this.APPLE_CLIENT_ID,
        };

        return jwt.sign(payload, this.APPLE_PRIVATE_KEY, {
            algorithm: 'ES256',
            keyid: this.APPLE_KEY_ID,
        });
    }

    /*
    * Get Tokens from Apple
    * @param code - The code from the callback.
    * @returns The access token and refresh token.
    * @throws Error if the request fails
    */
    static async getTokens(code: string): Promise<{ access_token: string; refresh_token: string }> {
        const clientSecret = this.generateClientSecret();



        const tokenResponse = await axios.post(
            this.APPLE_TOKEN_URL,
            new URLSearchParams({
                client_id: this.APPLE_CLIENT_ID,
                client_secret: clientSecret,
                code,
                redirect_uri: `${this.APPLICATION_HOST}${this.APPLE_CALLBACK_PATH}`,
                grant_type: 'authorization_code',
            }),
            {
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
            }
        );

        return {
            access_token: tokenResponse.data.access_token,
            refresh_token: tokenResponse.data.refresh_token,
        };
    }


    /*
    * Get Apple User Info
    * @param accessToken - The access token.
    * @returns The user info.
    * @throws Error if the request fails.
    */
    static async getUserInfo(accessToken: string): Promise<SSOProfileResponse> {
        // Decode the ID token to get user information
        const decodedToken = jwt.decode(accessToken) as { email: string; sub: string };
        return {
            email: decodedToken.email,
            sub: decodedToken.sub, // Apple's unique ID for the user
            provider: 'apple',
        };
    }

}

=== ./services/AuthService/SSOService/TwitterService.ts ===
import axios from 'axios';
import { SSOProfileResponse } from '@/types/SSOTypes';

export default class TwitterService {

    // App URL
    static APPLICATION_HOST = process.env.APPLICATION_HOST;

    // Twitter OAuth
    static TWITTER_CALLBACK_PATH = "/api/v1/sso/callback/twitter";
    static TWITTER_AUTH_URL = 'https://twitter.com/i/oauth2/authorize';
    static TWITTER_TOKEN_URL = 'https://api.twitter.com/2/oauth2/token';
    static TWITTER_USER_INFO_URL = 'https://api.twitter.com/2/users/me';
    static TWITTER_CLIENT_ID = process.env.TWITTER_CLIENT_ID!;
    static TWITTER_CLIENT_SECRET = process.env.TWITTER_CLIENT_SECRET!;

    /*
     * Create Twitter SSO Link
     * @returns The SSO link.
     */
    static generateAuthUrl(): string {
        const params = {
            client_id: this.TWITTER_CLIENT_ID,
            redirect_uri: `${this.APPLICATION_HOST}${this.TWITTER_CALLBACK_PATH}`,
            response_type: 'code',
            scope: 'tweet.read users.read', // Request access to read tweets and user info
            code_challenge: 'challenge', // Required for PKCE
            code_challenge_method: 'plain', // Use 'S256' for production
        };

        return `${this.TWITTER_AUTH_URL}?${new URLSearchParams(params).toString()}`;
    }

    /*
     * Get Tokens from Twitter
     * @param code - The code from the callback.
     * @returns The access token.
     * @throws Error if the request fails.
     */
    static async getTokens(code: string): Promise<{ access_token: string }> {
        const tokenResponse = await axios.post(
            this.TWITTER_TOKEN_URL,
            new URLSearchParams({
                client_id: this.TWITTER_CLIENT_ID,
                client_secret: this.TWITTER_CLIENT_SECRET,
                code,
                redirect_uri: `${this.APPLICATION_HOST}${this.TWITTER_CALLBACK_PATH}`,
                grant_type: 'authorization_code',
                code_verifier: 'challenge', // Must match the code_challenge from the authorization request
            }),
            {
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
            }
        );

        return {
            access_token: tokenResponse.data.access_token,
        };
    }

    /*
     * Get Twitter User Info
     * @param accessToken - The access token.
     * @returns The user info.
     * @throws Error if the request fails.
     */
    static async getUserInfo(accessToken: string):  Promise<SSOProfileResponse> {
        const userInfoResponse = await axios.get(this.TWITTER_USER_INFO_URL, {
            headers: {
                Authorization: `Bearer ${accessToken}`,
            },
        });

        const data = userInfoResponse.data;

        return {
            email: data.email || '', // Twitter may not provide email, handle accordingly
            sub: data.id, // Twitter's unique ID for the user
            name: data.name || '', // User's name
            picture: data.profile_image_url || '', // Profile picture URL
            provider: 'twitter', // Add provider field
        };
    }
}

=== ./services/AuthService/SSOService/MicrosoftService.ts ===
import axios from 'axios';
import { SSOProfileResponse } from '@/types/SSOTypes';

export default class MicrosoftService {

    // App URL
    static APPLICATION_HOST = process.env.APPLICATION_HOST;

    // Microsoft OAuth (Azure AD)
    static MICROSOFT_CALLBACK_PATH = "/api/v1/sso/callback/microsoft";
    static MICROSOFT_AUTH_URL = 'https://login.microsoftonline.com/common/oauth2/v2.0/authorize';
    static MICROSOFT_TOKEN_URL = 'https://login.microsoftonline.com/common/oauth2/v2.0/token';
    static MICROSOFT_USER_INFO_URL = 'https://graph.microsoft.com/v1.0/me';
    static MICROSOFT_CLIENT_ID = process.env.MICROSOFT_CLIENT_ID!;
    static MICROSOFT_CLIENT_SECRET = process.env.MICROSOFT_CLIENT_SECRET!;

    /*
     * Create Microsoft SSO Link
     * @returns The SSO link.
     */
    static generateAuthUrl(): string {
        const params = {
            client_id: this.MICROSOFT_CLIENT_ID,
            redirect_uri: `${this.APPLICATION_HOST}${this.MICROSOFT_CALLBACK_PATH}`,
            response_type: 'code',
            scope: 'openid profile email', // Request access to profile and email
            prompt: 'consent', // Force consent screen
        };

        return `${this.MICROSOFT_AUTH_URL}?${new URLSearchParams(params).toString()}`;
    }

    /*
     * Get Tokens from Microsoft
     * @param code - The code from the callback.
     * @returns The access token and refresh token.
     * @throws Error if the request fails.
     */
    static async getTokens(code: string): Promise<{ access_token: string; refresh_token: string }> {
        const tokenResponse = await axios.post(
            this.MICROSOFT_TOKEN_URL,
            new URLSearchParams({
                client_id: this.MICROSOFT_CLIENT_ID,
                client_secret: this.MICROSOFT_CLIENT_SECRET,
                code,
                redirect_uri: `${this.APPLICATION_HOST}${this.MICROSOFT_CALLBACK_PATH}`,
                grant_type: 'authorization_code',
            }),
            {
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
            }
        );

        return {
            access_token: tokenResponse.data.access_token,
            refresh_token: tokenResponse.data.refresh_token,
        };
    }

    /*
     * Get Microsoft User Info
     * @param accessToken - The access token.
     * @returns The user info.
     * @throws Error if the request fails.
     */
    static async getUserInfo(accessToken: string): Promise<SSOProfileResponse> {
        const userInfoResponse = await axios.get(this.MICROSOFT_USER_INFO_URL, {
            headers: {
                Authorization: `Bearer ${accessToken}`,
            },
        });

        const data = userInfoResponse.data;

        return {
            email: data.mail || data.userPrincipalName, // Use mail if available, otherwise userPrincipalName
            sub: data.id, // Microsoft's unique ID for the user
            name: data.displayName, // Full name
            picture: data.photo ? `https://graph.microsoft.com/v1.0/users/${data.id}/photo/$value` : undefined, // Profile picture URL
            provider: 'microsoft', // Add provider field
        };
    }
}

=== ./services/AuthService/SSOService/AutodeskService.ts ===
import axios from 'axios';
import { SSOProfileResponse } from '@/types/SSOTypes';

export default class AutodeskService {

    static APPLICATION_HOST = process.env.APPLICATION_HOST;
    static AUTODESK_CLIENT_ID = process.env.AUTODESK_CLIENT_ID!;
    static AUTODESK_CLIENT_SECRET = process.env.AUTODESK_CLIENT_SECRET!;
    static AUTODESK_CALLBACK_PATH = '/api/auth/callback/autodesk';

    static AUTODESK_AUTH_URL = 'https://developer.api.autodesk.com/authentication/v2/authorize';
    static AUTODESK_TOKEN_URL = 'https://developer.api.autodesk.com/authentication/v2/token';
    static AUTODESK_USER_INFO_URL = 'https://developer.api.autodesk.com/userprofile/v1/users/@me';

    /*
     * Create Autodesk SSO Link
     */
    static generateAuthUrl(): string {
        const params = {
            client_id: this.AUTODESK_CLIENT_ID,
            response_type: 'code',
            redirect_uri: `${this.APPLICATION_HOST}${this.AUTODESK_CALLBACK_PATH}`,
            scope: 'data:read data:write account:read account:write user-profile:read',
        };

        return `${this.AUTODESK_AUTH_URL}?${new URLSearchParams(params).toString()}`;
    }

    /*
     * Get Tokens from Autodesk
     */
    static async getTokens(code: string): Promise<{ access_token: string, refresh_token: string }> {
        const response = await axios.post(this.AUTODESK_TOKEN_URL,
            new URLSearchParams({
                client_id: this.AUTODESK_CLIENT_ID,
                client_secret: this.AUTODESK_CLIENT_SECRET,
                grant_type: 'authorization_code',
                code,
                redirect_uri: `${this.APPLICATION_HOST}${this.AUTODESK_CALLBACK_PATH}`,
            }),
            { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }
        );

        console.log('Autodesk Token Response:', response.data);

        return { access_token: response.data.access_token, refresh_token: response.data.refresh_token };
    }

    /*
     * Get Autodesk User Info
     */
    static async getUserInfo(accessToken: string): Promise<SSOProfileResponse> {


        const response = await axios.get(this.AUTODESK_USER_INFO_URL, {
            headers: {
                Authorization: `Bearer ${accessToken}`,
            },
        });

        console.log('Autodesk User Info Response:', response.data);

        const { userId, emailId, firstName, lastName, profileImages } = response.data;

        return {
            sub: userId, // Autodesk's unique ID for the user
            email: emailId, name: `${firstName} ${lastName}`, 
            picture: profileImages ? profileImages.size48 : null,
            provider: 'autodesk'
        };
    }
}


=== ./services/AuthService/SSOService/SlackService.ts ===
// services/AuthService/SSOService/SlackService.ts
import axios from 'axios';

export default class SlackService {
  static CLIENT_ID = process.env.SLACK_CLIENT_ID!;
  static CLIENT_SECRET = process.env.SLACK_CLIENT_SECRET!;
  static CALLBACK_URL = `${process.env.APPLICATION_HOST}/api/auth/callback/slack`;

  static AUTH_URL = 'https://slack.com/oauth/v2/authorize';
  static TOKEN_URL = 'https://slack.com/api/oauth.v2.access';
  static USERINFO_URL = 'https://slack.com/api/users.identity';

  static generateAuthUrl(state: string): string {
    const params = new URLSearchParams({
      client_id: this.CLIENT_ID,
      scope: 'identity.basic,identity.email',
      redirect_uri: this.CALLBACK_URL,
      state
    });

    return `${this.AUTH_URL}?${params.toString()}`;
  }

  static async getAccessToken(code: string) {
    const params = new URLSearchParams({
      client_id: this.CLIENT_ID,
      client_secret: this.CLIENT_SECRET,
      code,
      redirect_uri: this.CALLBACK_URL
    });

    const { data } = await axios.post(this.TOKEN_URL, params.toString(), {
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
    });

    if (!data.ok) throw new Error(data.error || 'Slack token fetch failed');
    return data.authed_user.access_token;
  }

  static async getUserInfo(accessToken: string) {
    const { data } = await axios.get(this.USERINFO_URL, {
      headers: { Authorization: `Bearer ${accessToken}` }
    });

    if (!data.ok) throw new Error(data.error || 'Slack user info fetch failed');

    return {
      id: data.user.id,
      name: data.user.name,
      email: data.user.email,
      avatar: data.user.image_192,
      provider: 'slack'
    };
  }

  static async authCallback(code: string) {
    const accessToken = await this.getAccessToken(code);
    const user = await this.getUserInfo(accessToken);
    return user;
  }
}


=== ./services/AuthService/SSOService/TiktokService.ts ===
import axios from 'axios';
import { SSOProfileResponse } from '@/types/SSOTypes';

export default class TikTokService {

    // App URL
    static APPLICATION_HOST = process.env.APPLICATION_HOST;

    // TikTok OAuth
    static TIKTOK_CALLBACK_PATH = "/api/v1/sso/callback/tiktok";
    static TIKTOK_AUTH_URL = 'https://www.tiktok.com/auth/authorize';
    static TIKTOK_TOKEN_URL = 'https://open.tiktokapis.com/v2/oauth/token/';
    static TIKTOK_USER_INFO_URL = 'https://open.tiktokapis.com/v2/user/info/';
    static TIKTOK_CLIENT_KEY = process.env.TIKTOK_CLIENT_KEY!;
    static TIKTOK_CLIENT_SECRET = process.env.TIKTOK_CLIENT_SECRET!;

    /*
     * Create TikTok SSO Link
     * @returns The SSO link.
     */
    static generateAuthUrl(): string {
        const params = {
            client_key: this.TIKTOK_CLIENT_KEY,
            redirect_uri: `${this.APPLICATION_HOST}${this.TIKTOK_CALLBACK_PATH}`,
            response_type: 'code',
            scope: 'user.info.basic', // Request basic user info
        };

        return `${this.TIKTOK_AUTH_URL}?${new URLSearchParams(params).toString()}`;
    }

    /*
     * Get Tokens from TikTok
     * @param code - The code from the callback.
     * @returns The access token and refresh token.
     * @throws Error if the request fails.
     */
    static async getTokens(code: string): Promise<{ access_token: string; refresh_token: string }> {
        const tokenResponse = await axios.post(
            this.TIKTOK_TOKEN_URL,
            new URLSearchParams({
                client_key: this.TIKTOK_CLIENT_KEY,
                client_secret: this.TIKTOK_CLIENT_SECRET,
                code,
                redirect_uri: `${this.APPLICATION_HOST}${this.TIKTOK_CALLBACK_PATH}`,
                grant_type: 'authorization_code',
            }),
            {
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Accept': 'application/json',
                },
            }
        );

        return {
            access_token: tokenResponse.data.access_token,
            refresh_token: tokenResponse.data.refresh_token,
        };
    }

    /*
     * Get TikTok User Info
     * @param accessToken - The access token.
     * @returns The user info.
     * @throws Error if the request fails.
     */
    static async getUserInfo(accessToken: string): Promise<SSOProfileResponse> {
        const userInfoResponse = await axios.get(this.TIKTOK_USER_INFO_URL, {
            headers: {
                Authorization: `Bearer ${accessToken}`,
            },
        });

        const data = userInfoResponse.data.data;

        return {
            email: data.email || '', // TikTok may not provide email, handle accordingly
            sub: data.open_id, // TikTok's unique ID for the user
            name: data.nickname || '', // User's nickname
            picture: data.avatar || '', // Profile picture URL
            provider: 'tiktok', // Add provider field
        };
    }
}

=== ./services/AuthService/SSOService/FacebookService.ts ===
import axios from 'axios';
import { SSOProfileResponse } from '@/types/SSOTypes';

export default class FacebookService {

    // App URL
    static APPLICATION_HOST = process.env.APPLICATION_HOST;

    // Meta (Facebook) OAuth
    static META_CALLBACK_PATH = "/api/auth/callback/facebook";
    static META_AUTH_URL = 'https://www.facebook.com/v17.0/dialog/oauth';
    static META_TOKEN_URL = 'https://graph.facebook.com/v17.0/oauth/access_token';
    static META_USER_INFO_URL = 'https://graph.facebook.com/v17.0/me';
    static META_CLIENT_ID = process.env.META_CLIENT_ID!;
    static META_CLIENT_SECRET = process.env.META_CLIENT_SECRET!;

    /*
     * Create Meta SSO Link
     * @returns The SSO link.
     */
    static generateAuthUrl(): string {
        const params = {
            client_id: this.META_CLIENT_ID,
            redirect_uri: `${this.APPLICATION_HOST}${this.META_CALLBACK_PATH}`,
            response_type: 'code',
            scope: 'email public_profile', // Request access to email and public profile
        };

        return `${this.META_AUTH_URL}?${new URLSearchParams(params).toString()}`;
    }

    /*
     * Get Tokens from Meta
     * @param code - The code from the callback.
     * @returns The access token.
     * @throws Error if the request fails.
     */
    static async getTokens(code: string): Promise<{ access_token: string }> {
        const tokenResponse = await axios.get(this.META_TOKEN_URL, {
            params: {
                client_id: this.META_CLIENT_ID,
                client_secret: this.META_CLIENT_SECRET,
                code,
                redirect_uri: `${this.APPLICATION_HOST}${this.META_CALLBACK_PATH}`,
            },
        });

        return {
            access_token: tokenResponse.data.access_token,
        };
    }

    /*
     * Get Meta User Info
     * @param accessToken - The access token.
     * @returns The user info.
     * @throws Error if the request fails.
     */
    static async getUserInfo(accessToken: string): Promise<SSOProfileResponse> {

        const userInfoResponse = await axios.get(this.META_USER_INFO_URL, {
            params: {
                fields: 'id,name,email,picture', // Request specific fields
                access_token: accessToken,
            },
        });

        const data = userInfoResponse.data;

        return {
            sub: data.id, // Meta's unique ID for the user
            email: data.email || '', // Email may not be available
            name: data.name || '',
            picture: data.picture?.data?.url || '', // Profile picture URL
            provider: 'facebook', // Specify the provider
        };
       
    }
}

=== ./services/AuthService/SSOService/WeChatService.ts ===
// services/AuthService/SSOService/WeChatService.ts
import axios from 'axios';
import qs from 'querystring';

export default class WeChatService {
  static CLIENT_ID = process.env.WECHAT_APP_ID!;
  static CLIENT_SECRET = process.env.WECHAT_APP_SECRET!;
  static CALLBACK_URL = `${process.env.APPLICATION_HOST}/api/auth/callback/wechat`;

  static AUTH_URL = 'https://open.weixin.qq.com/connect/qrconnect';
  static TOKEN_URL = 'https://api.weixin.qq.com/sns/oauth2/access_token';
  static USERINFO_URL = 'https://api.weixin.qq.com/sns/userinfo';

  static generateAuthUrl(state: string): string {
    const params = {
      appid: this.CLIENT_ID,
      redirect_uri: encodeURIComponent(this.CALLBACK_URL),
      response_type: 'code',
      scope: 'snsapi_login',
      state
    };

    return `${this.AUTH_URL}?${qs.stringify(params)}#wechat_redirect`;
  }

  static async getAccessToken(code: string) {
    const url = `${this.TOKEN_URL}?appid=${this.CLIENT_ID}&secret=${this.CLIENT_SECRET}&code=${code}&grant_type=authorization_code`;

    const { data } = await axios.get(url);

    if (data.errcode) throw new Error(data.errmsg);
    return data; // contains access_token, openid, etc.
  }

  static async getUserInfo(accessToken: string, openid: string) {
    const url = `${this.USERINFO_URL}?access_token=${accessToken}&openid=${openid}`;
    const { data } = await axios.get(url);

    if (data.errcode) throw new Error(data.errmsg);
    return {
      id: data.unionid || data.openid,
      name: data.nickname,
      email: null,
      avatar: data.headimgurl,
      provider: 'wechat'
    };
  }

  static async authCallback(code: string) {
    const tokenData = await this.getAccessToken(code);
    const user = await this.getUserInfo(tokenData.access_token, tokenData.openid);
    return user;
  }
}


=== ./services/AuthService/SSOService/GithubService.ts ===
import axios from 'axios';
import { SSOProfileResponse } from '@/types/SSOTypes';

export default class GithubService {

    // App URL
    static APPLICATION_HOST = process.env.APPLICATION_HOST;

    // GitHub OAuth
    static GITHUB_CALLBACK_PATH = "/api/v1/sso/callback/github";
    static GITHUB_AUTH_URL = 'https://github.com/login/oauth/authorize';
    static GITHUB_TOKEN_URL = 'https://github.com/login/oauth/access_token';
    static GITHUB_USER_INFO_URL = 'https://api.github.com/user';
    static GITHUB_CLIENT_ID = process.env.GITHUB_CLIENT_ID!;
    static GITHUB_CLIENT_SECRET = process.env.GITHUB_CLIENT_SECRET!;

    /*
     * Create GitHub SSO Link
     * @returns The SSO link.
     */
    static generateAuthUrl(): string {
        const params = {
            client_id: this.GITHUB_CLIENT_ID,
            redirect_uri: `${this.APPLICATION_HOST}${this.GITHUB_CALLBACK_PATH}`,
            scope: 'user', // Request access to user info
            state: 'random_string_to_prevent_csrf', // Optional: Add a state parameter for CSRF protection
        };

        return `${this.GITHUB_AUTH_URL}?${new URLSearchParams(params).toString()}`;
    }

    /*
     * Get Tokens from GitHub
     * @param code - The code from the callback.
     * @returns The access token.
     * @throws Error if the request fails.
     */
    static async getTokens(code: string): Promise<{ access_token: string }> {
        const tokenResponse = await axios.post(
            this.GITHUB_TOKEN_URL,
            new URLSearchParams({
                client_id: this.GITHUB_CLIENT_ID,
                client_secret: this.GITHUB_CLIENT_SECRET,
                code,
                redirect_uri: `${this.APPLICATION_HOST}${this.GITHUB_CALLBACK_PATH}`,
            }),
            {
                headers: {
                    'Accept': 'application/json', // GitHub returns JSON by default
                },
            }
        );

        return {
            access_token: tokenResponse.data.access_token,
        };
    }

    /*
     * Get GitHub User Info
     * @param accessToken - The access token.
     * @returns The user info.
     * @throws Error if the request fails.
     */
    static async getUserInfo(accessToken: string): Promise<SSOProfileResponse> {
        const userInfoResponse = await axios.get(this.GITHUB_USER_INFO_URL, {
            headers: {
                Authorization: `Bearer ${accessToken}`,
            },
        });

        const data = userInfoResponse.data;

        return {
            sub: data.id.toString(), // GitHub's unique ID for the user
            email: data.email || '', // Email may not be available
            name: data.name || '',
            picture: data.avatar_url || '', // User's avatar URL
            provider: 'github', // Provider name
        };

    }
}

=== ./services/AuthService/SSOService/LinkedInService.ts ===
import axios from 'axios';
import { SSOProfileResponse } from '@/types/SSOTypes';

export default class LinkedInService {

    // App URL
    static APPLICATION_HOST = process.env.APPLICATION_HOST;

    // LinkedIn OAuth
    static LINKEDIN_CALLBACK_PATH = "/api/v1/sso/callback/linkedin";
    static LINKEDIN_AUTH_URL = 'https://www.linkedin.com/oauth/v2/authorization';
    static LINKEDIN_TOKEN_URL = 'https://www.linkedin.com/oauth/v2/accessToken';
    static LINKEDIN_USER_INFO_URL = 'https://api.linkedin.com/v2/userinfo';
    static LINKEDIN_CLIENT_ID = process.env.LINKEDIN_CLIENT_ID!;
    static LINKEDIN_CLIENT_SECRET = process.env.LINKEDIN_CLIENT_SECRET!;

    /*
     * Create LinkedIn SSO Link
     * @returns The SSO link.
     */
    static generateAuthUrl(): string {
        const params = {
            client_id: this.LINKEDIN_CLIENT_ID,
            redirect_uri: `${this.APPLICATION_HOST}${this.LINKEDIN_CALLBACK_PATH}`,
            response_type: 'code',
            scope: 'openid profile email', // Request access to profile and email
        };

        return `${this.LINKEDIN_AUTH_URL}?${new URLSearchParams(params).toString()}`;
    }

    /*
     * Get Tokens from LinkedIn
     * @param code - The code from the callback.
     * @returns The access token.
     * @throws Error if the request fails.
     */
    static async getTokens(code: string): Promise<{ access_token: string }> {
        const tokenResponse = await axios.post(
            this.LINKEDIN_TOKEN_URL,
            new URLSearchParams({
                client_id: this.LINKEDIN_CLIENT_ID,
                client_secret: this.LINKEDIN_CLIENT_SECRET,
                code,
                redirect_uri: `${this.APPLICATION_HOST}${this.LINKEDIN_CALLBACK_PATH}`,
                grant_type: 'authorization_code',
            }),
            {
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
            }
        );

        return {
            access_token: tokenResponse.data.access_token,
        };
    }

    /*
     * Get LinkedIn User Info
     * @param accessToken - The access token.
     * @returns The user info.
     * @throws Error if the request fails.
     */
    static async getUserInfo(accessToken: string): Promise<SSOProfileResponse> {
        const userInfoResponse = await axios.get(this.LINKEDIN_USER_INFO_URL, {
            headers: {
                Authorization: `Bearer ${accessToken}`,
            },
        });

        const data = userInfoResponse.data;

        return {
            email: data.email, // LinkedIn's email field
            sub: data.sub, // LinkedIn's unique ID for the user
            name: data.name, // Full name
            picture: data.picture, // Profile picture URL
            provider: 'linkedin', // Add provider field
        };
    }
}

=== ./services/AuthService/SSOService/GoogleService.ts ===
import axios from 'axios';
import { SSOProfileResponse } from '@/types/SSOTypes';

export default class GoogleService {

    // App URL
    static APPLICATION_HOST = process.env.APPLICATION_HOST;


    // Google OAuth
    static GOOGLE_CALLBACK_PATH = "/api/auth/callback/google";
    static GOOGLE_AUTH_URL = 'https://accounts.google.com/o/oauth2/v2/auth';
    static GOOGLE_TOKEN_URL = 'https://oauth2.googleapis.com/token';
    static GOOGLE_CLIENT_ID = process.env.GOOGLE_CLIENT_ID!;
    static GOOGLE_CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET!;


    
    /*
    * Create Google SSO Link
    * @returns The SSO link.
    */
    static generateAuthUrl(): string {

        const params = {
            client_id: process.env.GOOGLE_CLIENT_ID!,
            redirect_uri: `${this.APPLICATION_HOST}${this.GOOGLE_CALLBACK_PATH}`,
            response_type: 'code',
            scope: 'profile email', // Request access to profile and email
            access_type: 'offline', // Request a refresh token
            prompt: 'consent', // Force consent screen
        };

        return `${this.GOOGLE_AUTH_URL}?${new URLSearchParams(params).toString()}`;
    }


    /*
    * Get Tokens from Google
    * @param code - The code from the callback.
    * @returns The access token and refresh token.
    * @throws Error if the request fails.
    */
    static async getTokens(code: string): Promise<{ access_token: string; refresh_token: string }> {

        const tokenResponse = await axios.post(
            this.GOOGLE_TOKEN_URL,
            new URLSearchParams({
                client_id: process.env.GOOGLE_CLIENT_ID!,
                client_secret: process.env.GOOGLE_CLIENT_SECRET!,
                code,
                redirect_uri: `${this.APPLICATION_HOST}${this.GOOGLE_CALLBACK_PATH}`,
                grant_type: 'authorization_code',
            }),
            {
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
            }
        );

        return {
            access_token: tokenResponse.data.access_token,
            refresh_token: tokenResponse.data.refresh_token,
        };
    }


    /*
    * Get Google User Info
    * @param accessToken - The access token.
    * @returns The user info.
    */
    static async getUserInfo(accessToken: string): Promise<SSOProfileResponse> {
        const userInfoResponse = await axios.get('https://www.googleapis.com/oauth2/v3/userinfo', {
            headers: {
                Authorization: `Bearer ${accessToken}`,
            },
        });

        const data = userInfoResponse.data;

        return {
            email: data.email,
            sub: data.sub, // Google's unique ID for the user
            name: data.name,
            picture: data.picture, // Profile picture URL
            provider: 'google', // Add provider field
        };

    }

}

=== ./services/AuthService/SSOService/index.ts ===
import prisma from '../../../libs/prisma';
import GoogleService from './GoogleService';
import AppleService from './AppleService';
import FacebookService from './FacebookService';
import GithubService from './GithubService';
import LinkedInService from './LinkedInService';
import MicrosoftService from './MicrosoftService';
import TwitterService from './TwitterService';

import bcrypt from 'bcrypt';
import SettingService from '../../SettingService';
import { SSOProfileResponse } from '@/types/SSOTypes';
import AutodeskService from './AutodeskService';

import { SSOMessages } from '@/messages/SSOMessages';
import { AuthMessages } from '@/messages/AuthMessages';
import { User } from '@prisma/client';
import { SafeUser } from '@/types/UserTypes';


interface SSOProviderService {
    generateAuthUrl: () => string;
    getTokens: (code: string) => Promise<{ access_token: string; refresh_token?: string }>;
    getUserInfo: (accessToken: string) => Promise<SSOProfileResponse>;
}

export default class SSOService {

    private static ALLOWED_PROVIDERS = process.env.SSO_ALLOWED_PROVIDERS?.split(',') || [];

    private static getAllowedProviders(): string[] {
        return this.ALLOWED_PROVIDERS;
    }

    private static PROVIDER_SERVICES: Record<string, SSOProviderService> = {
        "autodesk": AutodeskService,
        "google": GoogleService,
        "apple": AppleService,
        "facebook": FacebookService,
        "github": GithubService,
        "linkedin": LinkedInService,
        "microsoft": MicrosoftService,
        "twitter": TwitterService,
    };

    private static getProviderService(provider: string): SSOProviderService {
        if (!provider || !this.getAllowedProviders().includes(provider)) {
            throw new Error(SSOMessages.INVALID_PROVIDER);
        }

        const service = this.PROVIDER_SERVICES[provider];

        if (!service) {
            throw new Error(SSOMessages.INVALID_PROVIDER);
        }

        return service;
    }

    /**
     * Hashes the password.
     * @param password - The password to hash.
     * @returns The hashed password.
     */
    static async hashPassword(password: string): Promise<string> {
        return bcrypt.hash(password, 10);
    }


    private static async createUserFromSSOProfile(
        profile: SSOProfileResponse,
        accessToken: string,
        refreshToken?: string
    ) {
        const registrationEnabled = await SettingService.getSettingByKey("ALLOW_REGISTRATION");

        if (!registrationEnabled) {
            throw new Error(AuthMessages.REGISTRATION_DISABLED);
        }

        const user = await prisma.user.create({
            data: {
                email: profile.email,
                name: profile.name,
                password: await this.hashPassword(profile.sub + new Date().toISOString()),
            },
        });

        await prisma.userSocialAccount.create({
            data: {
                provider: profile.provider,
                providerId: profile.sub,
                accessToken,
                refreshToken,
                userId: user.userId,
            },
        });

        return user;
    }

    private static async updateUserFromSSOProfile(
        userId: string,
        profile: SSOProfileResponse,
        accessToken: string,
        refreshToken?: string
    ) {
        await prisma.user.update({
            where: { userId },
            data: {
                name: profile.name,
            },
        });

        const socialAccount = await prisma.userSocialAccount.findFirst({
            where: {
                provider: profile.provider,
                userId,
            },
        });

        if (socialAccount) {
            await prisma.userSocialAccount.update({
                where: { userSocialAccountId: socialAccount.userSocialAccountId },
                data: {
                    providerId: profile.sub,
                    accessToken,
                    refreshToken,
                },
            });
        } else {
            await prisma.userSocialAccount.create({
                data: {
                    provider: profile.provider,
                    providerId: profile.sub,
                    accessToken,
                    refreshToken,
                    userId,
                },
            });
        }

        return prisma.user.findUnique({ where: { userId } });
    }

    /*
     * Generate SSO Link
     * @param provider - The provider name.
     * @returns The SSO link.
     */
    static generateAuthUrl(provider: string): string {

        const providerService = this.getProviderService(provider);

        try {
            return providerService.generateAuthUrl();
        } catch (error) {
            throw new Error(SSOMessages.OAUTH_ERROR);
        }
    }


    /*
     * Auth Callback
     * @param provider - The provider name.
     * @param code - The code.
     * @param state - The state.
     * @param scope - The scope.
     * @returns The user and whether it's a new user.
     */
    static async authCallback(
        provider: string,
        code: string
    ): Promise<{ user: SafeUser; newUser: boolean }> {
        if (!code) {
            throw new Error(SSOMessages.CODE_NOT_FOUND);
        }

        const providerService = this.getProviderService(provider);

        const { access_token, refresh_token } = await providerService.getTokens(code);

        if (!access_token) {
            throw new Error(SSOMessages.OAUTH_ERROR);
        }

        try {
            const profile = await providerService.getUserInfo(access_token);
            if (!profile.email) {
                throw new Error(SSOMessages.EMAIL_NOT_FOUND);
            }

            let user = await prisma.user.findUnique({
                where: { email: profile.email },
            });

            let newUser = false;

            if (!user) {
                newUser = true;
                user = await this.createUserFromSSOProfile(profile, access_token, refresh_token);
            } else {
                user = await this.updateUserFromSSOProfile(user.userId, profile, access_token, refresh_token);
            }

            if (!user) {
                throw new Error(SSOMessages.OAUTH_ERROR);
            }
            
            return { user, newUser };
        } catch (error) {
            throw new Error(SSOMessages.OAUTH_ERROR);
        }
    }


}

=== ./services/AuthService/PasswordService.ts ===
import bcrypt from "bcrypt";
import crypto from "crypto";
import redis from "@/libs/redis";
import prisma from "@/libs/prisma";
import AuthMessages from "@/messages/AuthMessages";
import MailService from "../NotificationService/MailService";
import SMSService from "../NotificationService/SMSService";

export default class PasswordService {
  static RESET_TOKEN_EXPIRY_SECONDS = parseInt(process.env.RESET_TOKEN_EXPIRY_SECONDS || "3600"); // 1 saat
  static RESET_TOKEN_LENGTH = Math.max(4, parseInt(process.env.RESET_TOKEN_LENGTH || "6"));

  static generateResetToken(length = this.RESET_TOKEN_LENGTH): string {
    const min = Math.pow(10, length - 1);
    const max = Math.pow(10, length) - 1;
    return Math.floor(min + Math.random() * (max - min)).toString().padStart(length, "0");
  }

  static async hashToken(token: string): Promise<string> {
    return crypto.createHash("sha256").update(token).digest("hex");
  }

  static getRedisKey(email: string): string {
    return `reset-password:${email.toLowerCase()}`;
  }

  static getRateKey(email: string): string {
    return `reset-password-rate:${email.toLowerCase()}`;
  }

  static async forgotPassword({ email }: { email: string }): Promise<void> {
    const user = await prisma.user.findUnique({ where: { email: email } });
    if (!user) throw new Error(AuthMessages.USER_NOT_FOUND);
  
    const emailKey = user.email.toLowerCase();
    const emailTokenKey = this.getRedisKey(emailKey);
    const emailRateKey = this.getRateKey(emailKey);
  
    const alreadyEmailSent = await redis.get(emailRateKey);
    if (alreadyEmailSent) {
      const emailRate = parseInt(alreadyEmailSent);
      if (emailRate >= 5) {
        throw new Error(AuthMessages.RATE_LIMIT_EXCEEDED);
      } else {
        await redis.set(emailRateKey, (emailRate + 1).toString(), "EX", 60);
      }
    } else {
      await redis.set(emailRateKey, "1", "EX", 60);
    }
  
    // Invalidate old token
    await redis.del(emailTokenKey);
  
    // Generate and store new token
    const emailToken = this.generateResetToken();
    const hashedEmailToken = await this.hashToken(emailToken);
    await redis.set(emailTokenKey, hashedEmailToken, "EX", this.RESET_TOKEN_EXPIRY_SECONDS);
  
    // Send email
    await MailService.sendForgotPasswordEmail(user.email, user.name || undefined, emailToken);
  }
  

  static async resetPassword({ email, resetToken, password }: { email: string; resetToken: string; password: string }): Promise<void> {
    const user = await prisma.user.findFirst({ where: { email: email } });
    if (!user) throw new Error(AuthMessages.USER_NOT_FOUND);

    const key = this.getRedisKey(user.email);
    const storedHashed = await redis.get(key);
    if (!storedHashed) throw new Error(AuthMessages.INVALID_TOKEN);

    const hashedInput = await this.hashToken(resetToken);
    if (hashedInput !== storedHashed) {
      throw new Error(AuthMessages.INVALID_TOKEN);
    }

    await prisma.user.update({
      where: { userId: user.userId },
      data: {
        password: await bcrypt.hash(password, 10),
      },
    });

    await redis.del(key); // one-time usage

    await MailService.sendPasswordResetSuccessEmail(user.email, user.name || undefined);

    if (user.phone) {
      await SMSService.sendShortMessage({
        to: user.phone,
        body: `Your password has been successfully reset.`,
      });
    }
  }
}


=== ./services/AuthService/SocialAccountService.ts ===
import { UserSocialAccount } from "@prisma/client";
import prisma from "@/libs/prisma";

// Other Services
import UserService from "../UserService";

export default class SocialAccountService {

    static async addOrUpdateSocialAccount(
        userId: string,
        provider: string,
        providerId: string,
        accessToken?: string,
        refreshToken?: string,
        profilePicture?: string
    ): Promise<UserSocialAccount> {
        try {
            const existingAccount = await prisma.userSocialAccount.findUnique({
                where: { provider: provider, providerId: providerId },
            });

            if (existingAccount) {
                return await prisma.userSocialAccount.update({
                    where: { providerId: providerId },
                    data: {
                        accessToken,
                        refreshToken,
                        profilePicture,
                        updatedAt: new Date(),
                    },
                });
            }

            return await prisma.userSocialAccount.create({
                data: {
                    userId,
                    provider,
                    providerId,
                    accessToken,
                    refreshToken,
                    profilePicture,
                },
            });
        } catch (error: any) {
            throw new Error(`Error adding/updating social account: ${error.message}`);
        }
    }

    /**
     * Finds a user's social account by provider
     */
    static async getSocialAccountByProvider(
        provider: string,
        providerId: string
    ): Promise<UserSocialAccount | null> {
        try {
            return await prisma.userSocialAccount.findUnique({
                where: {
                    provider,
                    providerId,
                },
            });
        } catch (error: any) {
            throw new Error(`Error fetching social account: ${error.message}`);
        }
    }

    /**
     * Links a social account to an existing user by email
     */
    static async linkSocialAccountToUser(
        email: string,
        provider: string,
        providerId: string,
        accessToken?: string,
        refreshToken?: string,
        profilePicture?: string
    ): Promise<UserSocialAccount | null> {
        try {
            const user = await UserService.getByEmail(email);

            if (!user) {
                throw new Error("User not found");
            }

            return await this.addOrUpdateSocialAccount(
                user.userId,
                provider,
                providerId,
                accessToken,
                refreshToken,
                profilePicture
            );
        } catch (error: any) {
            throw new Error(`Error linking social account: ${error.message}`);
        }
    }

    /**
     * Unlinks a social account from a user
     */
    static async unlinkSocialAccount(
        userId: string,
        provider: string
    ): Promise<void> {
        try {
            await prisma.userSocialAccount.deleteMany({
                where: { userId, provider },
            });
        } catch (error: any) {
            throw new Error(`Error unlinking social account: ${error.message}`);
        }
    }

    /**
     * Retrieves all social accounts linked to a user
     */
    static async getAllUserSocialAccounts(userId: string): Promise<UserSocialAccount[]> {
        try {
            return await prisma.userSocialAccount.findMany({
                where: { userId },
            });
        } catch (error: any) {
            throw new Error(`Error retrieving social accounts: ${error.message}`);
        }
    }

}


=== ./services/AuthService/UserSessionOTPService.ts ===
import bcrypt from "bcrypt";
import redis from "@/libs/redis";
import { OTPMethod } from "@prisma/client";
import MailService from "../NotificationService/MailService";
import SMSService from "../NotificationService/SMSService";
import prisma from "@/libs/prisma";
import AuthMessages from "@/messages/AuthMessages";
import { authenticator } from "otplib";
import {  SafeUserSession } from "@/types/UserSessionTypes";
import { SafeUser } from "@/types/UserTypes";

export default class UserSessionOTPService {
  static OTP_EXPIRY_SECONDS = parseInt(process.env.OTP_EXPIRY_SECONDS || "600"); // 10 dk
  static OTP_LENGTH = parseInt(process.env.OTP_LENGTH || "6");
  static OTP_RATE_LIMIT_SECONDS = parseInt(process.env.OTP_RATE_LIMIT_SECONDS || "60");

  static generateToken(length = this.OTP_LENGTH): string {
    const min = Math.pow(10, length - 1);
    const max = Math.pow(10, length) - 1;
    return Math.floor(min + Math.random() * (max - min)).toString().padStart(length, "0");
  }

  static async hashToken(token: string): Promise<string> {
    return bcrypt.hash(token, 10);
  }

  static async compareToken(raw: string, hashed: string): Promise<boolean> {
    return bcrypt.compare(raw, hashed);
  }

  static async generateTOTPSecret(): Promise<string> {
    const secret = authenticator.generateSecret();
    return secret;
  }

  static async getUserOTPSecret(userId: string): Promise<string | null> {
    const user = await prisma.user.findUnique({
      where: { userId },
      select: { otpSecret: true },
    });
    if (!user) throw new Error(AuthMessages.USER_NOT_FOUND);
    if (!user.otpSecret) return null;
    return user.otpSecret;
  }

  static async rateLimitGuard(sessionId: string, method: OTPMethod) {
    const key = `otp:rate:${sessionId}:${method}`;
    const exists = await redis.get(key);
    if (exists) throw new Error(AuthMessages.OTP_ALREADY_SENT);
    await redis.set(key, "1", "EX", this.OTP_RATE_LIMIT_SECONDS);
  }

  static async storeOTP(sessionId: string, method: OTPMethod, token: string) {
    const hashed = await this.hashToken(token);
    const key = `otp:code:${sessionId}:${method}`;
    await redis.set(key, hashed, "EX", this.OTP_EXPIRY_SECONDS);
  }

  static async sendOTP({
    user,
    userSession,
    method
  }: {
    user: SafeUser;
    userSession: SafeUserSession;
    method: OTPMethod;
  }) {
    if (!userSession.otpVerifyNeeded)
      throw new Error(AuthMessages.OTP_NOT_NEEDED);
    if (userSession.sessionExpiry < new Date())
      throw new Error(AuthMessages.SESSION_NOT_FOUND);
  
    if (method === OTPMethod.TOTP_APP) {
      throw new Error(AuthMessages.INVALID_OTP_METHOD); // TOTP is not sent
    }
  
    const sessionId = userSession.userSessionId;
    const otpKey = `otp:code:${sessionId}:${method}`;
    const rateKey = `otp:rate:${sessionId}:${method}`;
  
    const rateCount = await redis.get(rateKey);
    if (rateCount) {
      const count = parseInt(rateCount);
      if (count >= 5) {
        throw new Error(AuthMessages.RATE_LIMIT_EXCEEDED);
      } else {
        await redis.set(rateKey, (count + 1).toString(), "EX", this.OTP_RATE_LIMIT_SECONDS);
      }
    } else {
      await redis.set(rateKey, "1", "EX", this.OTP_RATE_LIMIT_SECONDS);
    }
  
    // Delete any previous OTP
    await redis.del(otpKey);
  
    // Generate and store new OTP
    const token = this.generateToken();
    await this.storeOTP(sessionId, method, token);
  
    // Send OTP
    switch (method) {
      case OTPMethod.EMAIL:
        await MailService.sendOTPEmail({
          email: user.email,
          name: user.name,
          otpToken: token,
        });
        break;
  
      case OTPMethod.SMS:
        if (!user.phone)
          throw new Error(AuthMessages.INVALID_OTP_METHOD);
        await SMSService.sendShortMessage({
          to: user.phone,
          body: `Your OTP code is ${token}. Valid for ${this.OTP_EXPIRY_SECONDS / 60} minutes.`,
        });
        break;
  
      default:
        throw new Error(AuthMessages.INVALID_OTP_METHOD);
    }
  }
  

  static async validateOTP({ user, userSession, otpToken, method }: { user: SafeUser; userSession: SafeUserSession; otpToken: string; method: OTPMethod }) {
    if (!userSession.otpVerifyNeeded) throw new Error(AuthMessages.OTP_NOT_NEEDED);
    if (userSession.sessionExpiry < new Date()) throw new Error(AuthMessages.SESSION_NOT_FOUND);

    if (method === OTPMethod.TOTP_APP) {
      const otpSecret = await this.getUserOTPSecret(user.userId);
      if (!otpSecret) throw new Error(AuthMessages.INVALID_OTP_METHOD);

      const isValid = authenticator.check(otpToken, otpSecret);
      if (!isValid) throw new Error(AuthMessages.INVALID_OTP);
    } else {
      const key = `otp:code:${userSession.userSessionId}:${method}`;
      const hashed = await redis.get(key);
      if (!hashed) throw new Error(AuthMessages.OTP_EXPIRED);

      const isValid = await this.compareToken(otpToken, hashed);
      if (!isValid) throw new Error(AuthMessages.INVALID_OTP);

      await redis.del(key);
      await redis.del(`otp:rate:${userSession.userSessionId}:${method}`);
    }

    await prisma.userSession.update({
      where: { userSessionId: userSession.userSessionId },
      data: { otpVerifyNeeded: false },
    });
  }
}


=== ./services/AuthService/OTPService.ts ===
import { OTPMethod, User } from "@prisma/client";
import redis from "@/libs/redis";
import prisma from "@/libs/prisma";
import AuthMessages from "@/messages/AuthMessages";
import MailService from "../NotificationService/MailService";
import SMSService from "../NotificationService/SMSService";

export default class OTPService {
  static OTP_EXPIRY_SECONDS = parseInt(process.env.OTP_EXPIRY_SECONDS || "600");
  static OTP_LENGTH = parseInt(process.env.OTP_LENGTH || "6");

  static generateToken(length = OTPService.OTP_LENGTH): string {
    const min = Math.pow(10, length - 1);
    const max = Math.pow(10, length) - 1;
    return Math.floor(min + Math.random() * (max - min)).toString().padStart(length, "0");
  }

  static getRedisKey(userId: string, method: OTPMethod) {
    return `otp:activate:${userId}:${method}`;
  }

  static getRateKey(userId: string, method: OTPMethod) {
    return `otp:activate:rate:${userId}:${method}`;
  }

  static getDeactivationKey(userId: string, method: OTPMethod) {
    return `otp:deactivate:${userId}:${method}`;
  }

  static getDeactivationRateKey(userId: string, method: OTPMethod) {
    return `otp:deactivate:rate:${userId}:${method}`;
  }


  static async requestOTP({ user, method }: { user: User; method: OTPMethod }) {
    if (method === OTPMethod.TOTP_APP || method === OTPMethod.PUSH_APP) {
      throw new Error(AuthMessages.INVALID_OTP_METHOD);
    }

    const rateKey = this.getRateKey(user.userId, method);
    if (await redis.get(rateKey)) {
      throw new Error(AuthMessages.OTP_ALREADY_SENT);
    }

    const token = this.generateToken();
    const redisKey = this.getRedisKey(user.userId, method);
    await redis.set(redisKey, token, "EX", this.OTP_EXPIRY_SECONDS);
    await redis.set(rateKey, "1", "EX", 60);

    switch (method) {
      case OTPMethod.EMAIL:
        if (!user.email) throw new Error("No email on file.");
        await MailService.sendOTPEmail({
          email: user.email,
          name: user.name,
          otpToken: token,
        });
        break;

      case OTPMethod.SMS:
        if (!user.phone) throw new Error("No phone number on file.");
        await SMSService.sendShortMessage({
          to: user.phone,
          body: `Your OTP code to activate SMS login is ${token}.`,
        });
        break;
    }
  }

  static async verifyOTPAndActivate({
    user,
    method,
    otpToken,
  }: {
    user: User;
    method: OTPMethod;
    otpToken: string;
  }) {
    const redisKey = this.getRedisKey(user.userId, method);
    const storedToken = await redis.get(redisKey);

    if (!storedToken || storedToken !== otpToken) {
      throw new Error(AuthMessages.INVALID_OTP);
    }

    await prisma.user.update({
      where: { userId: user.userId },
      data: {
        otpMethods: {
          set: Array.from(new Set([...user.otpMethods, method])),
        },
      },
    });

    await redis.del(redisKey);
    await redis.del(this.getRateKey(user.userId, method));
  }


  static async requestDeactivation({ user, method }: { user: User; method: OTPMethod }) {
    if (!user.otpMethods.includes(method)) {
      throw new Error(`This method (${method}) is not currently active.`);
    }

    const rateKey = this.getDeactivationRateKey(user.userId, method);
    if (await redis.get(rateKey)) {
      throw new Error(AuthMessages.OTP_ALREADY_SENT);
    }

    const token = this.generateToken();
    const redisKey = this.getDeactivationKey(user.userId, method);
    await redis.set(redisKey, token, "EX", this.OTP_EXPIRY_SECONDS);
    await redis.set(rateKey, "1", "EX", 60);

    switch (method) {
      case OTPMethod.EMAIL:
        if (!user.email) throw new Error("No email on file.");
        await MailService.sendOTPEmail({
          email: user.email,
          name: user.name,
          otpToken: token,
        });
        break;

      case OTPMethod.SMS:
        if (!user.phone) throw new Error("No phone number on file.");
        await SMSService.sendShortMessage({
          to: user.phone,
          body: `Your OTP code to deactivate SMS login is ${token}.`,
        });
        break;

      default:
        throw new Error(AuthMessages.INVALID_OTP_METHOD);
    }
  }

  static async verifyDeactivation({
    user,
    method,
    otpToken,
  }: {
    user: User;
    method: OTPMethod;
    otpToken: string;
  }) {
    const redisKey = this.getDeactivationKey(user.userId, method);
    const storedToken = await redis.get(redisKey);

    if (!storedToken || storedToken !== otpToken) {
      throw new Error(AuthMessages.INVALID_OTP);
    }

    await prisma.user.update({
      where: { userId: user.userId },
      data: {
        otpMethods: {
          set: user.otpMethods.filter((m) => m !== method),
        },
      },
    });

    await redis.del(redisKey);
    await redis.del(this.getDeactivationRateKey(user.userId, method));
  }

  static listOTPStatus(user: User): { active: OTPMethod[]; inactive: OTPMethod[] } {
    const all: OTPMethod[] = [OTPMethod.EMAIL, OTPMethod.SMS, OTPMethod.TOTP_APP, OTPMethod.PUSH_APP];
    return {
      active: user.otpMethods,
      inactive: all.filter((m) => !user.otpMethods.includes(m)),
    };
  }
}


=== ./services/AuthService/UserSessionService.ts ===
import { UserSession, UserRole } from "@prisma/client";
import prisma from "@/libs/prisma";

// Other Services
import UserService from "../UserService";
// Utils
import { SafeUserSession } from "@/types/UserSessionTypes";
import { SafeUser } from "@/types/UserTypes";
import jwt from 'jsonwebtoken';
import crypto from "crypto";
import AuthMessages from "@/messages/AuthMessages";

import { v4 as uuidv4 } from "uuid";
import redisInstance from "@/libs/redis";


const ACCESS_TOKEN_SECRET = process.env.ACCESS_TOKEN_SECRET; // Burada bir varsayılan değer belirleyebilirsiniz
const ACCESS_TOKEN_EXPIRES_IN = process.env.ACCESS_TOKEN_EXPIRES_IN || '1h'; // veya '1h' gibi

const REFRESH_TOKEN_SECRET = process.env.REFRESH_TOKEN_SECRET; // Burada bir varsayılan değer belirleyebilirsiniz
const REFRESH_TOKEN_EXPIRES_IN: string | number = process.env.REFRESH_TOKEN_EXPIRES_IN || '7d'; // veya '7d' gibi

const SESSION_EXPIRY_MS = parseInt(process.env.SESSION_EXPIRY_MS || `${1000 * 60 * 60 * 24 * 7}`); // 7 gün
const SESSION_REDIS_EXPIRY_MS = parseInt(process.env.SESSION_REDIS_EXPIRY_MS || `${1000 * 60 * 30}`); // 30 min default


if (!ACCESS_TOKEN_SECRET || !REFRESH_TOKEN_SECRET) {
  throw new Error("Missing JWT secrets in environment variables.");
}

if (isNaN(SESSION_EXPIRY_MS)) {
  throw new Error("Invalid SESSION_EXPIRY_MS value in environment variables.");
}

if (isNaN(SESSION_REDIS_EXPIRY_MS)) {
  throw new Error("Invalid SESSION_REDIS_EXPIRY_MS value in environment variables.");
}

export default class UserSessionService {



  static readonly UserSessionOmitSelect = {
    userId: true,
    userSessionId: true,
  }


  /*
   * Generate Session CUID Token
    * @param userId - The user ID.
    * @param userSessionId - The session ID.
    * @param deviceFingerprint - The device fingerprint.
  * @returns A random cuid token.
  */
  private static generateAccessToken(userId: string, userSessionId: string, deviceFingerprint: string): string {

    if (!ACCESS_TOKEN_SECRET) {
      throw new Error("ACCESS_TOKEN_SECRET is not defined");
    }

    // @ts-expect-error: this is a valid use of the jwt.sign method 
    return jwt.sign(
      {
        userId: userId,
        userSessionId: userSessionId, // her session için eşsiz
        deviceFingerprint: deviceFingerprint,
      },
      ACCESS_TOKEN_SECRET,
      {
        subject: userId,                // sub: userId
        issuer: 'relatia.kuray.dev',    // iss
        audience: 'web',                // aud
        expiresIn: ACCESS_TOKEN_EXPIRES_IN, // exp
      }
    );
  }

  /**
   * Generate Refresh Token
   * @param userId - The user ID.
   * @param userSessionId - The session ID.
   * @param deviceFingerprint - The device fingerprint.
   * @returns A random refresh token.
   */

  private static generateRefreshToken(userId: string, userSessionId: string, deviceFingerprint: string): string {
    // @ts-expect-error: this is a valid use of the jwt.sign method
    return jwt.sign(
      {
        userId: userId,
        deviceFingerprint: deviceFingerprint,
        userSessionId: userSessionId, // her session için eşsiz
      },
      REFRESH_TOKEN_SECRET as string,
      {
        subject: userId,
        issuer: 'relatia.kuray.dev',
        audience: 'web',
        expiresIn: REFRESH_TOKEN_EXPIRES_IN,
        notBefore: 5, // 5 saniye sonra geçerli
      }
    );
  }


  /**
   * Verifies a access token.
   * @param token - The access token to verify.
   * 
   * @returns The decoded token payload.
   */
  static async verifyAccessToken(token: string, deviceFingerprint: string): Promise<{ userId: string }> {

    if (!ACCESS_TOKEN_SECRET) {
      throw new Error("ACCESS_TOKEN_SECRET is not defined");
    }

    try {

      const decoded = jwt.verify(token, ACCESS_TOKEN_SECRET, {
        issuer: 'relatia.kuray.dev',
        audience: 'web',
      }) as { userId: string, deviceFingerprint: string, userSessionId: string };

      if (decoded.deviceFingerprint !== deviceFingerprint) {
        throw new Error(AuthMessages.INVALID_TOKEN);
      }

      return { userId: decoded.userId };
    } catch (error: any) {
      if (error.name === "TokenExpiredError") {
        throw new Error(AuthMessages.TOKEN_EXPIRED);
      }
      throw new Error(AuthMessages.INVALID_TOKEN);
    }
  }


  /**
   * Verifies a refresh token.
   * @param token - The refresh token to verify.
   * @returns The decoded token payload.
   */
  static verifyRefreshToken(token: string): any {

    if (!REFRESH_TOKEN_SECRET) {
      throw new Error("REFRESH_TOKEN_SECRET is not defined");
    }

    try {
      const decoded = jwt.verify(token, REFRESH_TOKEN_SECRET, {
        issuer: 'relatia.kuray.dev',
        audience: 'web',
      }) as { userId: string };

      return decoded;
    } catch (error: any) {
      if (error.name === "TokenExpiredError") {
        throw new Error(AuthMessages.TOKEN_EXPIRED);
      }
      throw new Error(AuthMessages.INVALID_TOKEN);
    }
  }

  /**
   * Hashes a token using SHA-256.
   * @param token - The access token to verify.
   * @returns The decoded token payload.
   */
  static hashToken(token: string): string {
    return crypto.createHash("sha256").update(token).digest("hex");
  }


  /**
   * Generates a device fingerprint based on the request headers.
   * @param request - The HTTP request object.
   * @returns A promise that resolves to the device fingerprint.
   */
  static async generateDeviceFingerprint(request: NextRequest): Promise<string> {
    const ip = request.headers.get("x-forwarded-for") || request.headers.get("x-real-ip") || request.headers.get("cf-connecting-ip") || request.headers.get("remote-addr") || request.headers.get("x-client-ip") || request.headers.get("x-cluster-client-ip") || request.headers.get("x-original-forwarded-for") || request.headers.get("forwarded-for") || request.headers.get("forwarded");
    const userAgent = request.headers.get("user-agent") || "";
    const acceptLanguage = request.headers.get("accept-language") || "";

    const rawFingerprint = `${ip}|${userAgent}|${acceptLanguage}`;
    return crypto.createHash("sha256").update(rawFingerprint).digest("hex");
  }


  /**
   * Creates a new user session.
   * @param userId - The user ID.
   * @returns The created session.
   */
  static async createSession(user: SafeUser, request: NextRequest, otpIgnore: boolean = false): Promise<
    {
      userSession: SafeUserSession,
      otpVerifyNeeded: boolean,
      rawAccessToken: string,
      rawRefreshToken: string
    }> {

    const deviceFingerprint = await UserSessionService.generateDeviceFingerprint(request);


    // Generate a random session ID
    const userSessionId = uuidv4();

    const rawAccessToken = UserSessionService.generateAccessToken(user.userId, userSessionId, deviceFingerprint);
    const hashedAccessToken = UserSessionService.hashToken(rawAccessToken);



    const rawRefreshToken = UserSessionService.generateRefreshToken(user.userId, userSessionId, deviceFingerprint);
    const hashedRefreshToken = UserSessionService.hashToken(rawRefreshToken);

    const otpVerifyNeeded = !otpIgnore && user.otpMethods && user.otpMethods.length > 0;

    const userSession = await prisma.userSession.create({
      data: {
        userSessionId: userSessionId,
        userId: user.userId,
        accessToken: hashedAccessToken,
        refreshToken: hashedRefreshToken,
        sessionExpiry: new Date(Date.now() + SESSION_EXPIRY_MS),
        deviceFingerprint: deviceFingerprint,
        otpVerifyNeeded,
      },
    });


    return {
      userSession: UserSessionService.omitSensitiveFields(userSession),
      otpVerifyNeeded: userSession.otpVerifyNeeded,
      rawAccessToken,
      rawRefreshToken,
    };

  }

  /**
   * Gets a user session by token.
   * @param accessToken - The session token.
   * @returns The user session.
   */
  static async getSessionDangerously(
    accessToken: string,
    request: NextRequest
  ): Promise<{ user: SafeUser; userSession: SafeUserSession }> {
    const deviceFingerprint = await UserSessionService.generateDeviceFingerprint(request);
    const { userId } = await UserSessionService.verifyAccessToken(accessToken, deviceFingerprint);

    const cacheKey = `session:${userId}:${UserSessionService.hashToken(accessToken)}`;

    // 1️⃣ Try from Redis cache first
    const cached = await redisInstance.get(cacheKey);
    if (cached) {
      const { user, userSession } = JSON.parse(cached);
      return { user, userSession };
    }

    // 2️⃣ If not cached, query DB
    const hashedAccessToken = UserSessionService.hashToken(accessToken);

    const userSession = await prisma.userSession.findFirst({
      where: {
        accessToken: hashedAccessToken,
        deviceFingerprint: deviceFingerprint,
        sessionExpiry: { gte: new Date() },
      },
    });

    if (!userSession || userSession.userId !== userId)
      throw new Error(AuthMessages.SESSION_NOT_FOUND);
    if (userSession.otpVerifyNeeded)
      throw new Error(AuthMessages.OTP_NEEDED);
    if (userSession.deviceFingerprint !== deviceFingerprint)
      throw new Error(AuthMessages.DEVICE_FINGERPRINT_NOT_MATCH);

    const user = await prisma.user.findUnique({ where: { userId: userSession.userId } });
    if (!user) throw new Error(AuthMessages.USER_NOT_FOUND);

    const safeUser = UserService.omitSensitiveFields(user);
    const safeSession = UserSessionService.omitSensitiveFields(userSession);

    // 3️⃣ Cache result in Redis
    const ttlSeconds = Math.floor(SESSION_REDIS_EXPIRY_MS / 1000);
    await redisInstance.setex(cacheKey, ttlSeconds, JSON.stringify({ user: safeUser, userSession: safeSession }));

    return { user: safeUser, userSession: safeSession };
  }

  /**
   * Omits sensitive fields from the user session.
   * @param session - The user session.
   * @returns The user session without sensitive fields.
   */
  static async getSession(accessToken: string, request: NextRequest): Promise<{ user: SafeUser, userSession: SafeUserSession }> {
    // Get the session using the provided access token
    const { user, userSession } = await UserSessionService.getSessionDangerously(accessToken, request);

    // Check if the session is expired
    return {
      user: user,
      userSession: userSession,
    };
  }

  static omitSensitiveFields(session: UserSession): SafeUserSession {
    return {
      userSessionId: session.userSessionId,
      userId: session.userId,
      otpVerifyNeeded: session.otpVerifyNeeded,
      sessionExpiry: session.sessionExpiry,
    };
  }


  static async refreshAccessToken(currentRefreshToken: string) {
    // 🔍 Decode & verify refresh token
    const { userId } = await UserSessionService.verifyRefreshToken(currentRefreshToken);

    // Hash the current refresh token for DB lookup
    const hashedRefreshToken = UserSessionService.hashToken(currentRefreshToken);

    // 🔎 Find the session in DB
    const userSession = await prisma.userSession.findFirst({
      where: {
        refreshToken: hashedRefreshToken,
        userId,
        sessionExpiry: { gte: new Date() },
      },
    });

    if (!userSession) throw new Error(AuthMessages.SESSION_NOT_FOUND);
    if (userSession.otpVerifyNeeded) throw new Error(AuthMessages.OTP_NEEDED);

    // 🚨 Reuse detection: verify the stored token matches hash
    if (userSession.refreshToken !== hashedRefreshToken) {
      // Token reuse detected → invalidate all sessions
      await prisma.userSession.deleteMany({ where: { userId: userSession.userId } });

      // 🔥 Remove from Redis immediately
      const pattern = `session:${userSession.userId}:*`;
      const keys = await redisInstance.keys(pattern);
      if (keys.length > 0) await redisInstance.del(...keys);

      throw new Error(AuthMessages.REFRESH_TOKEN_REUSED);
    }

    // 🔁 Generate new tokens
    const newAccessToken = UserSessionService.generateAccessToken(
      userSession.userId,
      userSession.userSessionId,
      userSession.deviceFingerprint!
    );

    const newRefreshToken = UserSessionService.generateRefreshToken(
      userSession.userId,
      userSession.userSessionId,
      userSession.deviceFingerprint!
    );

    const newRefreshTokenHash = UserSessionService.hashToken(newRefreshToken);
    const newAccessTokenHash = UserSessionService.hashToken(newAccessToken);

    // 🕓 Update DB session
    const updatedSession = await prisma.userSession.update({
      where: { userSessionId: userSession.userSessionId },
      data: {
        accessToken: newAccessTokenHash,
        refreshToken: newRefreshTokenHash,
        sessionExpiry: new Date(Date.now() + SESSION_EXPIRY_MS),
      },
    });

    // 🧹 Invalidate old Redis caches
    const pattern = `session:${userSession.userId}:*`;
    const keys = await redisInstance.keys(pattern);
    if (keys.length > 0) await redisInstance.del(...keys);

    // ⚡ Cache the updated session with new tokens
    const safeSession = UserSessionService.omitSensitiveFields(updatedSession);
    const ttlSeconds = Math.floor(SESSION_REDIS_EXPIRY_MS / 1000);

    await redisInstance.setex(
      `session:${userSession.userId}:${newAccessTokenHash}`,
      ttlSeconds,
      JSON.stringify({
        userSession: safeSession,
        // Optional: You may also cache user details if needed for getSessionDangerously
      })
    );

    // ✅ Return new tokens & session
    return {
      userSession: safeSession,
      rawAccessToken: newAccessToken,
      rawRefreshToken: newRefreshToken,
    };
  }



  /**
   * Destroy all other sessions of the user.
   * 
   * @param userSession - The current user session.
   * @returns A promise that resolves when the sessions are destroyed.
   */
  static async destroyOtherSessions(userSession: SafeUserSession): Promise<void> {
    await prisma.userSession.deleteMany({
      where: {
        userId: userSession.userId,
        userSessionId: { not: userSession.userSessionId },
      },
    });

    // 🧹 Clear all Redis caches except the current session
    const pattern = `session:${userSession.userId}:*`;
    const keys = await redisInstance.keys(pattern);
    if (keys.length > 0) await redisInstance.del(...keys);
  }




  /**
   * Deletes a user session.
   * @param data - The user session data to delete.
   */

  static async deleteSession(data: SafeUserSession): Promise<void> {
    await prisma.userSession.deleteMany({
      where: { userSessionId: data.userSessionId },
    });

    // 🧹 Remove related cache entries
    const pattern = `session:${data.userId}:*`;
    const keys = await redisInstance.keys(pattern);
    if (keys.length > 0) await redisInstance.del(...keys);
  }



  /**
   * Authenticate a user by access token.
   * @param accessToken - The access token to authenticate.
   * @returns The authenticated user.
   */
  static async authenticateUserByRequest(request: NextRequest, requiredUserRole = "ADMIN"): Promise<SafeUser | null> {

    try {

      const accessToken = request.cookies.get("accessToken")?.value;
      const refreshToken = request.cookies.get("refreshToken")?.value;

      if (!accessToken || !refreshToken) {
        throw new Error(AuthMessages.USER_DOES_NOT_HAVE_REQUIRED_ROLE);
      }

      const { user, userSession } = await UserSessionService.getSession(accessToken, request);

      if (!user) {
        throw new Error(AuthMessages.USER_NOT_FOUND);
      }

      if (userSession.otpVerifyNeeded) {
        throw new Error(AuthMessages.OTP_NEEDED);
      }

      // Check if the session is expired
      if (userSession.sessionExpiry < new Date()) {
        throw new Error(AuthMessages.SESSION_NOT_FOUND);
      }

      const userRoleKeys = Object.keys(UserRole);

      const requiredUserRoleKeyIndex = userRoleKeys.indexOf(requiredUserRole);
      const userRoleKeyIndex = userRoleKeys.indexOf(user.userRole);

      if (requiredUserRoleKeyIndex > userRoleKeyIndex) {
        throw new Error(AuthMessages.USER_NOT_AUTHENTICATED);
      }

      request.user = user;

      return user;
    } catch (error: any) {
      if (requiredUserRole !== "GUEST") {
        throw new Error(AuthMessages.USER_NOT_AUTHENTICATED);
      }
      request.user = null; // GUEST role is allowed to not be authenticated
      return null; // GUEST role is allowed to not be authenticated
    }
  }
}






=== ./services/AuthService/index.ts ===
import prisma from "@/libs/prisma";
import bcrypt from "bcrypt";

// Other Services
import UserService from "../UserService";
import SMSService from "../NotificationService/SMSService";
import MailService from "../NotificationService/MailService";

// Utils
import { SafeUser } from "@/types/UserTypes";
import  AuthMessages from "@/messages/AuthMessages";

export default class AuthService {

    static readonly SafeUserSelect = {
        userId: true,
        email: true,
        name: true,
        phone: true,
        userRole: true,
        otpEnabled: true,
        createdAt: true,
        updatedAt: true,
    };



    /**
     * Token Generation
     * @returns A random token 6 characters long with only numbers.
     */
    static generateToken(): string {
        return Math.floor(100000 + Math.random() * 900000).toString();
    }


    /**
     * Hashes the password.
     * @param password - The password to hash.
     * @returns The hashed password.
     */
    static async hashPassword(password: string): Promise<string> {
        return bcrypt.hash(password, 10);
    }


    /**
     * Authenticates a user by email and password.
     * @param email - The user's email.
     * @param password - The user's password.
     * @returns The authenticated user.
     */
    static async login({ email, password } : { email: string, password: string }): Promise<SafeUser> {

        // Get the user by email
        const user = await prisma.user.findUnique({
            where: { email: email.toLowerCase() },
        })

        if (!user) {
            throw new Error(AuthMessages.INVALID_EMAIL_OR_PASSWORD);
        }

        // Compare the password with the hash

        const isPasswordValid = await bcrypt.compare(password, user.password);

        if (!isPasswordValid) {
            throw new Error(AuthMessages.INVALID_EMAIL_OR_PASSWORD);
        }
        
        return UserService.omitSensitiveFields(user);
    }

    /**
     * Logs out a user by deleting the session.
     * @param token - The session token.
     */
    static async logout({ accessToken }: { accessToken: string }): Promise<void> {

        // Check if the session exists
        const sessions = await prisma.userSession.findMany({
            where: { accessToken: accessToken }
        });

        if (sessions.length === 0) {
            throw new Error(AuthMessages.SESSION_NOT_FOUND);
        }

        // Delete the session if found
        await prisma.userSession.deleteMany({
            where: { accessToken: accessToken }
        });
    }


    /**
     * Registers a new user.
     * @param email - The user's email.
     * @param password - The user's password.
     * @returns The registered user.
     */
    static async register({ email, password, name, phone }: { email: string, password: string, name?: string, phone?: string }): Promise<SafeUser> {

        // TODO: Validate the input data

        // Check if the user already exists
        const existingUser = await UserService.getByEmail(email);

        if (existingUser) {
            throw new Error(AuthMessages.EMAIL_ALREADY_EXISTS);
        }

        // Create the user
        const createdUser = await prisma.user.create({
            data: {
                name,
                phone,
                email: email.toLowerCase(),
                password: await AuthService.hashPassword(password),
            },
        });

        // Send a welcome email
        await MailService.sendWelcomeEmail(createdUser);
        await SMSService.sendShortMessage({
            to: createdUser.phone!,
            body: `Welcome ${createdUser.name || createdUser.email}! Your account has been created successfully.`,
        });

        // Create a session for the user
        return UserService.omitSensitiveFields(createdUser);
    }

    /**
     * Checks if a user has the required role.
     * @param user - The user object.
     * @param requiredRoles - The required roles.
     * @returns Whether the user has the required role.
     */
    public static checkIfUserHasRole(user: SafeUser, requiredRole: string): boolean {

        const roles = [
            'SUPER_ADMIN',
            'ADMIN',
            'USER',
            'GUEST'
        ];

        const userRoleIndex = roles.indexOf(user.userRole);
        const requiredRoleIndex = roles.indexOf(requiredRole);

        return userRoleIndex <= requiredRoleIndex;
    }



}




=== ./libs/prisma/index.ts ===
import { PrismaClient } from "@prisma/client"
 
const globalForPrisma = globalThis as unknown as { prisma: PrismaClient }
 
const prisma = globalForPrisma.prisma || new PrismaClient()
 
if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma

export default prisma

=== ./libs/zustand/index.ts ===
import { create } from 'zustand';
import { persist, createJSONStorage, PersistOptions } from 'zustand/middleware';
import {SafeUser} from '@/types/UserTypes';

type GlobalState = {
  user: SafeUser | null;
  availableLanguages: string[];
  language: string;
  availableThemes: string[];
  theme: string;

  setUser: (user: SafeUser | null) => void;
  clearUser: () => void;

  setLanguage: (language: string) => void;
  setTheme: (theme: string) => void;
};

// Extend the store type to include PersistOptions
type GlobalStatePersist = PersistOptions<GlobalState>;

export const useGlobalStore = create<GlobalState>()(
  persist(
    (set, get) => ({
      user: null,
      availableLanguages: ['en', 'tr', 'de', 'gr', 'et', 'mt', 'th'],
      availableThemes: ['light', 'dark'],
      language: 'en',
      theme: 'dark',
      setUser: (user) => set({ user }),
      clearUser: () => set({ user: null }),
      setLanguage: (language) => set({ language }),
      setTheme: (theme) => set({ theme }),
    }),
    {
      name: 'global-storage',
      storage: createJSONStorage(() => sessionStorage),
      version: 0.6,
    }
  )
);


export default useGlobalStore


=== ./libs/rateLimit/index.ts ===
// libs/RateLimiter.ts

import { NextResponse } from 'next/server';
import redisInstance from '../redis';

const RATE_LIMIT = 10;
const RATE_DURATION = 60; // seconds

export default class RateLimiter {
  static getIpFromRequest(request: NextRequest): string {
    return (
      request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() ||
      request.headers.get('x-real-ip')?.trim() ||
      'unknown'
    );
  }

  static async check(ip: string): Promise<{ success: boolean; remaining: number }> {
    const key = `rate_limit:${ip}`;
    const current = await redisInstance.get(key);
    const currentCount = current ? parseInt(current, 10) : 0;
    const newCount = currentCount + 1;
    await redisInstance.set(key, newCount, 'EX', RATE_DURATION);
    return { success: newCount <= RATE_LIMIT, remaining: Math.max(RATE_LIMIT - newCount, 0) };
  }

  /**
   * Applies rate limiting. If limit exceeded, returns 429 response.
   * Otherwise, returns modified response with headers.
   */
  static async useRateLimit(request: NextRequest): Promise<NextResponse | null> {
    const ip = this.getIpFromRequest(request);
    const { success, remaining } = await this.check(ip);

    const res = NextResponse.next();
    res.headers.set('X-RateLimit-Limit', RATE_LIMIT.toString());
    res.headers.set('X-RateLimit-Remaining', remaining.toString());

    if (!success) {
      return new NextResponse(JSON.stringify({ message: 'Too many requests' }), {
        status: 429,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    return res;
  }
}


=== ./libs/localize/localize.ts ===
import i18n, { t } from "i18next";
import { initReactI18next } from "react-i18next";

//de, en, et, gr, mt, th, tr
import de from "@/dictionaries/de.json";
import en from "@/dictionaries/en.json";
import et from "@/dictionaries/et.json";
import gr from "@/dictionaries/gr.json";
import mt from "@/dictionaries/mt.json";
import th from "@/dictionaries/th.json";
import tr from "@/dictionaries/tr.json";


const compatibilityJSON = "v3";
const fallbackLng = "en";

const resources = {
  de: {
    translation: de,
  },
  en: {
    translation: en,
  },
  et: {
    translation: et,
  },
  gr: {
    translation: gr,
  },
  mt: {
    translation: mt,
  },
  th: {
    translation: th,
  },
  tr: {
    translation: tr,
  },
};

const interpolation = {
  escapeValue: false, // not needed for react as it escapes by default
};

// @ts-ignore
i18n
  // load translation using http -> see /public/locales (i.e. https://github.com/i18next/react-i18next/tree/master/example/react/public/locales)
  // learn more: https://github.com/i18next/i18next-http-backend
  // want your translations to be loaded from a professional CDN? => https://github.com/locize/react-tutorial#step-2---use-the-locize-cdn
  //.use(Backend)
  // detect user language
  // learn more: https://github.com/i18next/i18next-browser-languageDetector
  //.use(LanguageDetector)
  // pass the i18n instance to react-i18next.
  .use(initReactI18next)
  // init i18next
  // for all options read: https://www.i18next.com/overview/configuration-options
  .init({
    compatibilityJSON,
    fallbackLng,
    //debug: process.env.NODE_ENV === "development",
    debug: false,
    resources,
    interpolation,
  })



export default i18n;


=== ./libs/redis/index.ts ===
// libs/queue.ts
import { Queue } from 'bullmq';
import { Redis } from 'ioredis';


const REDIS_HOST = process.env.REDIS_HOST || 'localhost';
const REDIS_PORT = process.env.REDIS_PORT || '6379';
const REDIS_PASSWORD = process.env.REDIS_PASSWORD || '';

const redisInstance = new Redis({
  host: REDIS_HOST,
  port: Number(REDIS_PORT),
  password: REDIS_PASSWORD,
  maxRetriesPerRequest: null, // ✅ This is required by BullMQ

});

export default redisInstance;

=== ./libs/openai/index.ts ===
import OpenAI from 'openai';

export const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY || '',
});

export default openai;



=== ./libs/s3/index.ts ===
//create a s3 client
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";

//create a s3 client
const s3Client = new S3Client({ region: process.env.AWS_REGION!,
    credentials: {
        accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!
    }
});

export const s3 = s3Client;

export default s3;

=== ./libs/axios/index.ts ===
'use client';
import axios from 'axios';
import useGlobalStore from '../zustand';
import { AuthMessages } from '@/messages/AuthMessages';

const axiosInstance = axios.create({
    withCredentials: true, // Enable sending cookies with requests
});

// Add a request interceptor
axiosInstance.interceptors.request.use(async function (config) {
    /*
    const { session } = await useGlobalStore.getState();

    if (session) {
        config.headers['Authorization'] = `Bearer ${session?.sessionToken}`;
    }
    */

    return config;
}, function (error) {
    // Do something with request error
    return Promise.reject(error);
});

// Add a response interceptor
axiosInstance.interceptors.response.use(function (response) {
    // Any status code that lie within the range of 2xx cause this function to trigger
    // Do something with response data
    return response;
}, function (error) {
    // Any status codes that falls outside the range of 2xx cause this function to trigger
    if (error.response) {
        const { message } = error.response.data;
        if (message === AuthMessages.TOKEN_EXPIRED || message === AuthMessages.USER_NOT_AUTHENTICATED) {
            window.location.href = '/auth/login';
        } else {
            console.error('Response error:', error.response.data);
        }
    } else {
        console.error('Response error without response:', error);
    }
    return Promise.reject(error);
});
// Handle login required error

export default axiosInstance;


=== ./libs/logger/index.ts ===
import winston from 'winston';

const { combine, timestamp, json, printf } = winston.format;
const timestampFormat = 'MMM-DD-YYYY HH:mm:ss';

const NODE_ENV = process.env.NODE_ENV || 'development';

export default class Logger {
  private static infoLogger = winston.createLogger({
    level: 'info',
    format: combine(
      timestamp({ format: timestampFormat }),
      json(),
      printf(({ level, message, timestamp }) => {
        return `[${timestamp}] [${level}]: ${message}`;
      })
    ),
    // @ts-ignore
    transports: (NODE_ENV === 'vercel' || NODE_ENV === 'development') ? [
      new winston.transports.Console(), // Add a console transport to log information to console
    ] : [
      new winston.transports.File({
        filename: 'logs/' + new Date().toISOString().split('T')[0] + '.log',
        level: 'info',
      }),
    ],
  });

  private static errorLogger = winston.createLogger({
    level: 'error',
    format: combine(
      timestamp({ format: timestampFormat }),
      json(),
      printf(({ level, message, timestamp }) => {
        return `[${timestamp}] [${level}]: ${message}`;
      })
    ),
    // @ts-ignore
    transports: (NODE_ENV === 'vercel' || NODE_ENV === 'development') ? [
      new winston.transports.Console(), // Add a console transport to log information to console
    ] : [
      new winston.transports.File({
        filename: 'logs/' + new Date().toISOString().split('T')[0] + '.log',
        level: 'error',
      }),
    ],
  });

  private static warnLogger = winston.createLogger({
    level: 'warn',
    format: combine(
      timestamp({ format: timestampFormat }),
      json(),
      printf(({ level, message, timestamp }) => {
        return `[${timestamp}] [${level}]: ${message}`;
      })
    ),
    // @ts-ignore
    transports: (NODE_ENV === 'vercel' || NODE_ENV === 'development') ? [
      new winston.transports.Console(), // Add a console transport to log information to console
    ] : [
      new winston.transports.File({
        filename: 'logs/' + new Date().toISOString().split('T')[0] + '.log',
        level: 'error',
      }),
    ],
  });


  static info(message: string) {
    Logger.infoLogger.info(message);
  }

  static error(message: string) {
    Logger.errorLogger.error(message);
  }

  static warn(message: string) {
    Logger.warnLogger.warn(message);
  }

  /* Disabled on NEXTJS
  static useLogger(request: Request, response: Response, next: NextFunction) {
    const ip = request.headers['x-forwarded-for'] || request.connection.remoteAddress;
    const method = request.method;
    const url = request.url;
    
    response.on('finish', () => {

      const status = response.statusCode;
      const message = `${method} ${url.split('?')[0]} ${status} ${ip} ${response.statusMessage}`;
      
      //if response has error 
      if (status >= 400) {
        Logger.error(message);
      } else {
        Logger.info(message);
      }

    });

    next();
  }
  */
}






=== ./utils/FieldValidater.ts ===
import bcrypt from "bcrypt";
export type KeysOfType<T, U> = { [K in keyof T]: T[K] extends U ? K : never }[keyof T];
export type RequiredKeys<T> = Exclude<KeysOfType<T, Exclude<T[keyof T], undefined>>, undefined>;
export type OptionalKeys<T> = Exclude<keyof T, RequiredKeys<T>>;

export default class FieldValidater {
    static emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    static passwordRegex = /^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/;
    static tokenRegex = /^[0-9]{6}$/;
    static sqlInjectionRegex = /[\s\[\]{}()*+?.,\\^$|#]/;
    static domainRegex = /^[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*$/;

    /**
     * Validates if the provided email matches the email regex pattern.
     * @param email - The email string to validate.
     * @returns `true` if valid, `false` otherwise.
     */
    static isEmail(email: string | undefined | null): boolean {
        if (!email || typeof email !== "string") return false;
        return this.emailRegex.test(email);
    }

    /**
     * Validates if the provided password matches the password regex pattern.
     * @param password - The password string to validate.
     * @returns `true` if valid, `false` otherwise.
     */
    static isPassword(password: string | undefined | null): boolean {
        if (!password || typeof password !== "string") return false;
        return this.passwordRegex.test(password);
    }

    /**
     * Validates a string against a custom regex pattern.
     * @param value - The string to validate.
     * @param pattern - The regex pattern to use for validation.
     * @returns `true` if the value matches the pattern, `false` otherwise.
     */
    static validateWithRegex(value: string | undefined | null, pattern: RegExp): boolean {
        if (!value || typeof value !== "string") return false;
        return pattern.test(value);
    }

    /**
     * Validates if the provided value is a valid Code for account verification.
     * @param token - The code string to validate.
     * @returns `true` if valid, `false` otherwise.
     * @see
     * - Code must be 6 characters long.
     * - Code must contain only numbers.
     */
    static isVerificationToken(token: string | undefined | null): boolean {
        if (!token || typeof token !== "string") return false;
        return this.tokenRegex.test(token);
    }

    /**
     * Validates if the provided two passwords match.
     * @param hashedPassword - The hashed password to compare.
     * @param password - The password to compare.
     */
    static async comparePasswords(hashedPassword: string, password: string): Promise<boolean> {
        return await bcrypt.compare(password, hashedPassword);
    }


    /**
     * Validates if the provided UUID is a valid UUID.
     * @param cuid - The UUID string to validate.
     * @returns `true` if valid, `false` otherwise.
     * @see
     */
    static isCUID(cuid: string | undefined | null): boolean {
        if (!cuid || typeof cuid !== "string") return false;
        return cuid.length === 25;
    }
    /**
     * Validates a string against database injection attacks and only allows alphanumeric characters.
     * @param value - The string to validate.
     * @returns string - The sanitized string.
     * @see
     * - Only allows alphanumeric characters.
     * - Removes all special characters except for `-` and `_` characters.
     */
    static sanitizeString(value: string | undefined | null): string | undefined {
        // Ensure the value is a string, defaulting to an empty string if null or undefined
        if (!value || typeof value !== "string") return undefined;

        // Sanitize the string by removing unwanted characters
        const sanitized = value.replace(/[^a-zA-Z0-9_-]/g, "");

        return sanitized;
    }

    /**
     * Validates phone number starts with + and is followed by numbers.
     * @param phone - The phone number string to validate.
     * @returns `true` if valid, `false` otherwise.
     * @see
     * - Phone number must start with a `+` character.
     * - Phone number must contain only numbers after the `+` character.
     */
    static isPhone(phone: string | undefined | null): boolean {
        if (!phone || typeof phone !== "string") return false;
        return /^\+[0-9]+$/.test(phone);
    }

    /**
     * Validates if the provided role is a valid role.
     * @param role - The role string to validate.
     * @returns `true` if valid, `false` otherwise.
     * @see
     * - Role must be one of the following: `USER`, `ADMIN`, `SUPER_ADMIN`.
     */
    static isRole(role: string | undefined | null): boolean {
        if (!role || typeof role !== "string") return false;
        return ["USER", "ADMIN", "SUPER_ADMIN"].includes(role);
    }

    /**
     * Validates if the provided value is tenant user role.
     * @param tenantUserRole - The tenant user role string to validate.
     * @returns `true` if valid, `false` otherwise.
     * @see
     */ 

    static isTenantUserRole(tenantUserRole: string | undefined | null): boolean {
        if (!tenantUserRole || typeof tenantUserRole !== "string") return false;
        return ["USER", "ADMIN", "SUPER_ADMIN"].includes(tenantUserRole);
    }

    /**
     * Validates if the provided value is tenant user status.
     * @param tenantUserStatus - The tenant user status string to validate.
     * @returns `true` if valid, `false` otherwise.
     * @see
     */
    static isTenantUserStatus(tenantUserStatus: string | undefined | null): boolean {
        if (!tenantUserStatus || typeof tenantUserStatus !== "string") return false;
        return ["ACTIVE", "INACTIVE"].includes(tenantUserStatus);
    }


    /**
     * Validates if the provided value is a valid number.
     * @param value - The number string to validate.
     * @returns `true` if valid, `false` otherwise.
     * @see
     */
    static isNumber(value: string | undefined | null): boolean {
        if (!value || typeof value !== "string") return false;
        return !isNaN(Number(value));
    }

    /**
     * Validates if the provided value is cuid2.
     * @param value - The cuid2 string to validate.
     * @returns `true` if valid, `false` otherwise.
     * d3o47zbqg28ftevdgehuewiw
     */
    static isAccessToken(value: string | undefined | null): boolean {

        return true;
    }
    /**
     * Validates if the provided JSON matches the model.
     * Ensures all fields in the model are present in the JSON
     * and that there are no extra fields in the JSON.
     * @param value - The JSON object to validate.
     * @param model - The model class to validate against.
     * @returns `true` if valid, `false` otherwise.
     */
    static validateBody(body: any = {}, Model: any): boolean {       

        // Create an instance of the model to get the required and optional fields
        const orginalInstance = new Model();
        const allFields = Object.keys(orginalInstance);
        const requiredFields = Object.keys(orginalInstance).filter((key) => key in orginalInstance);
        const optionalFields = Object.keys(orginalInstance).filter((key) => !(key in orginalInstance));

        const bodyFields = Object.keys(body);

        // Check if all required fields are present
        if (requiredFields.some((key) => !bodyFields.includes(key))) {
            return false;
        }

        // Check if there are any extra fields
        if (bodyFields.some((key) => !allFields.includes(key))) {
            return false;
        }

        // Check if optional fields are valid
        if (optionalFields.some((key) => !bodyFields.includes(key))) {
            return false;
        }
           


        return true; // Valid if no issues
    }

    /**
     * Validates if the provided string is a valid domain withouth protocol.
     * @param domain - The domain string to validate.
     * @returns `true` if valid, `false` otherwise.
     */
    static isDomain(domain: string | undefined | null): boolean {
        if (!domain || typeof domain !== "string") return false;
        return this.domainRegex.test(domain);
    }
    

    /**
     * Validates if the provided string is a valid name.
     * @param name - The name string to validate.
     * @returns `true` if valid, `false` otherwise.
     * @see
     */

    static isName(name: string | undefined | null): boolean {
        if (!name || typeof name !== "string") return false;
        return name.length > 5;
    }


    /**
     * Validates if the provided string is a valid tenant status.
     * @param tenantStatus - The tenant status string to validate.
     * @returns `true` if valid, `false` otherwise.
     * @see
     */ 

    static isTenantStatus(tenantStatus: string | undefined | null): boolean {
        if (!tenantStatus || typeof tenantStatus !== "string") return false;
        return ["ACTIVE", "INACTIVE"].includes(tenantStatus);
    }

    /**
     * Validates if the provided string is a valid boolean.
     * @param value - The boolean string to validate.
     * 
     * @returns `true` if valid, `false` otherwise
     */
    static isBoolean(value: boolean | undefined | null): boolean {
        if (value === undefined || value === null) return false;
        return typeof value === "boolean";
    }
}



=== ./utils/Encryptor.ts ===
// libs/security/Encryptor.ts
import crypto from 'crypto';
import dotenv from 'dotenv';
dotenv.config();

const ENCRYPTION_KEY = Buffer.from(process.env.ENCRYPTION_SECRET_KEY!, 'hex'); // 32 bytes
const ALGORITHM = 'aes-256-gcm';

export default class Encryptor {
    public static encrypt(text: string): string {
        const iv = crypto.randomBytes(12);
        const cipher = crypto.createCipheriv(ALGORITHM, ENCRYPTION_KEY, iv);

        const encrypted = Buffer.concat([cipher.update(text, 'utf8'), cipher.final()]);
        const tag = cipher.getAuthTag();

        return Buffer.concat([iv, tag, encrypted]).toString('base64');
    }

    public static decrypt(enc: string): string {

        const bData = Buffer.from(enc, 'base64');
        const iv = bData.slice(0, 12);
        const tag = bData.slice(12, 28);
        const text = bData.slice(28);

        const decipher = crypto.createDecipheriv(ALGORITHM, ENCRYPTION_KEY, iv);
        decipher.setAuthTag(tag);

        return decipher.update(text.toString('utf8'), 'utf8', 'utf8') + decipher.final('utf8');
    }

}


=== ./middleware.ts ===
import { NextRequest, NextResponse } from 'next/server';

const PUBLIC_FILE = /\.(.*)$/;
//de, en, et, gr, mt, th, tr
const SUPPORTED_LOCALES = ['de', 'en', 'et', 'gr', 'mt', 'th', 'tr'];
const DEFAULT_LOCALE = 'en';

function shouldSkipMiddleware(pathname: string): boolean {
  return pathname.startsWith('/_next') || PUBLIC_FILE.test(pathname);
}

function getLocaleFromHeader(req: NextRequest): string {
  const acceptLanguage = req.headers.get('accept-language');
  if (!acceptLanguage) return DEFAULT_LOCALE;

  const preferredLanguages = acceptLanguage.split(',').map(lang => lang.trim().split(';')[0]);
  const matchedLocale = preferredLanguages.find(lang =>
    SUPPORTED_LOCALES.includes(lang.split('-')[0])
  );
  return matchedLocale?.split('-')[0] || DEFAULT_LOCALE;
}

export function middleware(req: NextRequest) {
  const { pathname, locale, search } = req.nextUrl;

  if (shouldSkipMiddleware(pathname)) {
    return NextResponse.next();
  }

  if (locale === 'default') {
    const detectedLocale = getLocaleFromHeader(req);
    const url = new URL(`/${detectedLocale}${pathname}${search}`, req.url);
    return NextResponse.redirect(url);
  }

  return NextResponse.next();
}

export const config = {
  matcher: [
    '/((?!_next|.*\\..*).*)',
  ],
};


=== ./app/(easter)/easter/terminal/layout.tsx ===
import React from 'react';
import Terminal from '@/components/easter/Terminal';

const Layout = ({
    children,
}: {
    children: React.ReactNode;
}) => {
    
    
    
    
    return (
        <Terminal/>
    );
};

export default Layout;

=== ./app/(easter)/easter/terminal/page.tsx ===
'use client'
import Terminal from '@/components/easter/Terminal';

const TerminalPage: React.FC = () => {

    return (
        <>
            <Terminal />
        </>
    );
}

export default TerminalPage;

=== ./app/layout.tsx ===
import "./globals.css";
import { GoogleTagManager } from '@next/third-parties/google'

/*
export const metadata: Metadata = {
  title: "Kuray Karaaslan | Software Engineer",
  description: "Self-taught and self-motivated software developer, open-source contributor, and tech enthusiast with a diverse portfolio of independent projects.",
};
*/

const NEXT_PUBLIC_GOOGLE_TAG = process.env.NEXT_PUBLIC_GOOGLE_TAG;

export default function RootLayout({
  children,
  params,
}: Readonly<{
  children: React.ReactNode;
  params: any;
}>) {
  return (
    <html data-theme="dark" className="antialiased scroll-smooth focus:scroll-auto">
      <head>
        <GoogleTagManager gtmId={NEXT_PUBLIC_GOOGLE_TAG as string} />
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
      </head>
      <body className="min-h-screen">
        {children}
      </body>
    </html>
  );
}


=== ./app/(frontend)/layout.tsx ===
import Footer from "@/components/frontend/Footer";
import Navbar from "@/components/frontend/Navbar";
import ScrollToTop from "@/components/frontend/ScrollToTop";
import Sidebar from "@/components/frontend/Sidebar";
import TerminalButton from "@/components/frontend/TerminalButton";
import Whatsapp from "@/components/frontend/Whatsapp";
import { Suspense , useEffect, useState } from "react";
import { useGlobalStore } from "@/libs/zustand";
/*
export const metadata: Metadata = {
  title: "Kuray Karaaslan | Software Engineer",
  description: "Welcome to my tech blog! I’m Kuray Karaaslan, a frontend, backend, and mobile developer skilled in React, Next.js, Node.js, Java, and React Native. I share practical coding tutorials, industry insights, and UI/UX tips to help developers and tech enthusiasts excel. Stay updated, solve problems, and grow your tech expertise with me!",
};
*/

export default function RootLayout({
  children,
  props = { lng: "en" },
}: Readonly<{
  children: React.ReactNode;
  props: { lng: string };
}>) {



  return (
    <Suspense fallback={<div className="flex justify-center items-center h-screen">Loading...</div>}>
      <div className="drawer">
        <input id="my-drawer" type="checkbox" className="drawer-toggle" />
        <div className="relative drawer-content flex flex-col min-h-screen bg-base-200 h-full">
          {/* Navbar */}
          <Navbar />
          {/* Page content here */}
          {children}

          {/* Footer */}
          <Footer />
        </div>
        <Sidebar />
      </div>
      <ScrollToTop />
      <Whatsapp />
    </Suspense>
  );
}


=== ./app/(frontend)/privacy-policy/page.tsx ===
import { Metadata } from 'next';
import React from 'react';

const APPLICATION_HOST = process.env.APPLICATION_HOST;

export default function TermsPage() {

  const meta = generateMetadata();

  return (
    <>
      {generateMetadataElement(meta)}
      <section className="min-h-screen bg-base-100 pt-32" id="blog">
        <h1 className="text-3xl font-bold text-center mb-6">Privacy Policy</h1>
        <p className="text-sm text-gray-600 text-center mb-8">
          Last Updated: {new Date().toLocaleDateString()}
        </p>

        <div className="prose max-w-3xl mx-auto">
          <h2 className="text-xl font-semibold mb-4">1. Introduction</h2>
          <p className="mb-4">
            Welcome to <strong>kuray.dev</strong> (the "Website"). Your privacy is important to us, and this Privacy Policy explains how we collect, use, disclose, and protect your personal information when you visit our Website.
          </p>

          <h2 className="text-xl font-semibold mb-4">2. Information We Collect</h2>
          <p className="mb-4">We may collect the following types of information:</p>
          <ul className="list-disc list-inside mb-4">
            <li><strong>Personal Information:</strong> Name, email address, and contact details when you submit forms or interact with us.</li>
            <li><strong>Usage Data:</strong> IP addresses, browser type, pages visited, and other analytical data collected through cookies and similar technologies.</li>
            <li><strong>Cookies & Tracking:</strong> We use cookies to enhance your experience, analyze traffic, and personalize content.</li>
          </ul>

          <h2 className="text-xl font-semibold mb-4">3. How We Use Your Information</h2>
          <p className="mb-4">We may use the collected information for the following purposes:</p>
          <ul className="list-disc list-inside mb-4">
            <li>To provide, maintain, and improve our Website.</li>
            <li>To respond to inquiries and customer support requests.</li>
            <li>To analyze Website performance and user behavior.</li>
            <li>To comply with legal obligations.</li>
          </ul>

          <h2 className="text-xl font-semibold mb-4">4. How We Share Your Information</h2>
          <p className="mb-4">We do not sell or rent your personal information. However, we may share data with:</p>
          <ul className="list-disc list-inside mb-4">
            <li><strong>Service Providers:</strong> Third-party services that help us operate and maintain the Website.</li>
            <li><strong>Legal Authorities:</strong> When required by law or to protect our rights.</li>
            <li><strong>Business Transfers:</strong> If we undergo a business transaction such as a merger or acquisition.</li>
          </ul>

          <h2 className="text-xl font-semibold mb-4">5. Cookies and Tracking Technologies</h2>
          <p className="mb-4">
            We use cookies and similar tracking technologies to enhance user experience. You can control cookie settings through your browser preferences.
          </p>

          <h2 className="text-xl font-semibold mb-4">6. Data Security</h2>
          <p className="mb-4">
            We implement security measures to protect your data. However, no online platform is 100% secure, so use the Website at your own risk.
          </p>

          <h2 className="text-xl font-semibold mb-4">7. Your Rights and Choices</h2>
          <p className="mb-4">
            Depending on your location, you may have rights to access, correct, or delete your personal data. To request changes, please contact us.
          </p>

          <h2 className="text-xl font-semibold mb-4">8. Third-Party Links</h2>
          <p className="mb-4">
            Our Website may contain links to third-party sites. We are not responsible for their privacy practices, so review their policies separately.
          </p>

          <h2 className="text-xl font-semibold mb-4">9. Changes to This Privacy Policy</h2>
          <p className="mb-4">
            We may update this Privacy Policy from time to time. Any changes will be posted on this page with the updated date.
          </p>

          <h2 className="text-xl font-semibold mb-4">10. Contact Us</h2>
          <p className="mb-4">
            If you have any questions or concerns about this Privacy Policy, please contact us at:
            <br />
            <strong>Email:</strong> support@kuray.dev
            <br />
            <strong>Website:</strong> kuray.dev
          </p>
        </div>
      </section>
    </>
  );
}

function generateMetadata(): Metadata {
  return {
    title: `Privacy Policy | Kuray Karaaslan`,
    description: "Privacy Policy for Kuray Karaaslan",
    openGraph: {
      title: `Privacy Policy | Kuray Karaaslan`,
      description: "Privacy Policy for Kuray Karaaslan",
      type: 'article',
      url: `${APPLICATION_HOST}/terms`,
      images: [`${APPLICATION_HOST}/assets/img/default.jpg`],
    },
  };
}

function generateMetadataElement(meta: Metadata) {

  return (
    <>
      <title>{String(meta?.title)}</title>
      <meta name="description" content={String(meta?.description)} />
      <meta property="og:title" content={String(meta?.openGraph?.title)} />
      <meta property="og:description" content={String(meta?.openGraph?.description)} />
      <meta property="og:type" content="article" />
      <meta property="og:url" content={String(meta?.openGraph?.url)} />
      <meta property="og:image" content={Array.isArray(meta?.openGraph?.images) ? String(meta?.openGraph?.images?.[0]) : String(meta?.openGraph?.images)} />
      <meta name="twitter:card" content="summary_large_image" />
      <meta name="twitter:site" content="@dropshoptickets" />
      <meta name="twitter:creator" content="@dropshoptickets" />
      <meta name="twitter:title" content={String(meta?.title)} />
      <meta name="twitter:description" content={String(meta?.description)} />
      <meta name="twitter:image" content={Array.isArray(meta?.openGraph?.images) ? String(meta?.openGraph?.images?.[0]) : String(meta?.openGraph?.images)} />
    </>
  );
}

=== ./app/(frontend)/page.tsx ===
import Welcome from '@/components/frontend/Hero/Welcome';
import React from 'react';
import Toolbox from '@/components/frontend/Hero/Toolbox';
import Contact from '@/components/frontend/Hero/Contact';
import ProjectsHero from '@/components/frontend/Hero/Projects';
import type { Metadata } from 'next';
import MetadataHelper from '@/helpers/MetadataHelper';
import Timeline from '@/components/frontend/Hero/Timeline';
import AppointmentCalendar from '@/components/frontend/AppointmentCalendar';
import { ToastContainer } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';


const APPLICATION_HOST = process.env.APPLICATION_HOST;

const HomePage = () => {

  const metadata: Metadata = {
    title: "Software Developer | Kuray Karaaslan",
    description: "Welcome to my tech blog! I’m Kuray Karaaslan, a frontend, backend, and mobile developer skilled in React, Next.js, Node.js, Java, and React Native. I share practical coding tutorials, industry insights, and UI/UX tips to help developers and tech enthusiasts excel. Stay updated, solve problems, and grow your tech expertise with me!",
    openGraph: {
      title: "Software Developer | Kuray Karaaslan",
      description: "Welcome to my tech blog! I’m Kuray Karaaslan, a frontend, backend, and mobile developer skilled in React, Next.js, Node.js, Java, and React Native. I share practical coding tutorials, industry insights, and UI/UX tips to help developers and tech enthusiasts excel. Stay updated, solve problems, and grow your tech expertise with me!",
      type: 'website',
      url: `${APPLICATION_HOST}`,
      images: [
        `${APPLICATION_HOST}/assets/img/og.png`,
      ],
    },
  };

  return (
    <>
      {MetadataHelper.generateElements(metadata)}
      <Welcome />
      <Toolbox />
      <ProjectsHero />
      <AppointmentCalendar />
      <Contact />
      <ToastContainer />
    </>
  );
};

export default HomePage;


=== ./app/(frontend)/terms-of-use/page.tsx ===
import { Metadata } from 'next';
import React from 'react';

const APPLICATION_HOST = process.env.APPLICATION_HOST;

export default function TermsPage() {

  const meta = generateMetadata();

  return (
    <>
      {generateMetadataElement(meta)}
      <section className="min-h-screen bg-base-100 pt-32" id="blog">
        <div className="container mx-auto px-4 lg:px-8 mb-8 flex-grow flex-col max-w-none">
          <h1 className="text-3xl font-bold text-center mb-6">Terms of Use</h1>
          <p className="text-sm text-gray-600 text-center mb-8">
            Last Updated: September 1, 2023
          </p>

          <div className="prose max-w-3xl mx-auto">
            <h2 className="text-xl font-semibold mb-4">1. Introduction</h2>
            <p className="mb-4">
              Welcome to <strong>kuray.dev</strong> (the "Website"), operated by Kuray Karaaslan ("we," "us," or "our"). By accessing or using this Website, you agree to comply with and be bound by the following terms and conditions of use. If you do not agree to these terms, please do not use this Website.
            </p>

            <h2 className="text-xl font-semibold mb-4">2. Intellectual Property</h2>
            <p className="mb-4">
              All content on this Website, including but not limited to text, graphics, logos, images, and software, is the property of Kuray Karaaslan or its licensors and is protected by intellectual property laws. You may not reproduce, distribute, or create derivative works from any content without our prior written consent.
            </p>

            <h2 className="text-xl font-semibold mb-4">3. User Responsibilities</h2>
            <p className="mb-4">
              By using this Website, you agree to:
              <ul className="list-disc list-inside">
                <li>Use the Website only for lawful purposes.</li>
                <li>Not engage in any activity that disrupts or interferes with the Website's functionality.</li>
                <li>Not attempt to gain unauthorized access to any part of the Website or its systems.</li>
              </ul>
            </p>

            <h2 className="text-xl font-semibold mb-4">4. Limitation of Liability</h2>
            <p className="mb-4">
              We are not liable for any damages arising out of or related to your use of this Website. This includes, but is not limited to, direct, indirect, incidental, or consequential damages.
            </p>

            <h2 className="text-xl font-semibold mb-4">5. Changes to Terms</h2>
            <p className="mb-4">
              We reserve the right to modify these terms at any time. Any changes will be effective immediately upon posting on this Website. Your continued use of the Website after changes are posted constitutes your acceptance of the revised terms.
            </p>

            <h2 className="text-xl font-semibold mb-4">6. Governing Law</h2>
            <p className="mb-4">
              These terms are governed by and construed in accordance with the laws of [Insert Jurisdiction]. Any disputes arising from these terms or your use of the Website will be subject to the exclusive jurisdiction of the courts of [Insert Jurisdiction].
            </p>

            <h2 className="text-xl font-semibold mb-4">7. Contact Information</h2>
            <p className="mb-4">
              If you have any questions about these terms, please contact us at:
              <br />
              <strong>Email:</strong> info@kuray.dev
              <br />
              <strong>Website:</strong> kuray.dev
            </p>
          </div>
        </div>
      </section>
    </>
  );
}

function generateMetadata(): Metadata {
  return {
    title: `Terms of Use | Kuray Karaaslan`,
    description: "Terms of Use for Kuray Karaaslan",
    openGraph: {
      title: `Terms of Use | Kuray Karaaslan`,
      description: "Terms of Use for Kuray Karaaslan",
      type: 'article',
      url: `${APPLICATION_HOST}/terms`,
      images: [`${APPLICATION_HOST}/assets/img/default.jpg`],
    },
  };
}

function generateMetadataElement(meta: Metadata) {

  return (
    <>
      <title>{String(meta?.title)}</title>
      <meta name="description" content={String(meta?.description)} />
      <meta property="og:title" content={String(meta?.openGraph?.title)} />
      <meta property="og:description" content={String(meta?.openGraph?.description)} />
      <meta property="og:type" content="article" />
      <meta property="og:url" content={String(meta?.openGraph?.url)} />
      <meta property="og:image" content={Array.isArray(meta?.openGraph?.images) ? String(meta?.openGraph?.images?.[0]) : String(meta?.openGraph?.images)} />
      <meta name="twitter:card" content="summary_large_image" />
      <meta name="twitter:site" content="@dropshoptickets" />
      <meta name="twitter:creator" content="@dropshoptickets" />
      <meta name="twitter:title" content={String(meta?.title)} />
      <meta name="twitter:description" content={String(meta?.description)} />
      <meta name="twitter:image" content={Array.isArray(meta?.openGraph?.images) ? String(meta?.openGraph?.images?.[0]) : String(meta?.openGraph?.images)} />
    </>
  );
}

=== ./app/(frontend)/blog/layout.tsx ===
'use client';
import React, { useEffect, useState } from "react";
import { ToastContainer } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
import useGlobalStore from "@/libs/zustand";
import { toast } from "react-toastify";
import i18n from "@/libs/localize/localize";


const layout = ({ children }: { children: React.ReactNode }) => {

  const { setLanguage, language } = useGlobalStore();
  const [ languageNotifiedOnce, setLanguageNotifiedOnce ] = useState(false);
  const { t } = i18n;

  useEffect(() => {

    if (languageNotifiedOnce) return;

    console.log("language", language);
    //if language is not en , notify that blog is only in english
    if (language !== "en") {
      toast.info(t("alert.this_blog_is_available_in_only_english"));
      setLanguageNotifiedOnce(true);
      //setLanguage("en");
    }
  }, [language]);


  return (

    <>
      {children}
      <ToastContainer
        position="top-right"
        autoClose={3000}
        hideProgressBar={false}
        newestOnTop={false}
        closeOnClick
        rtl={false}
        pauseOnFocusLoss
        draggable
        pauseOnHover
        theme="light" 
      />
    </>
  );
};

export default layout;


=== ./app/(frontend)/blog/page.tsx ===
import Newsletter from '@/components/frontend/Newsletter';
import Feed from '@/components/frontend/Feed';
import CategoryBullets from '@/components/frontend/CategoryBullets';
import type { Metadata } from 'next';
import MetadataHelper from '@/helpers/MetadataHelper';

const APPLICATION_HOST = process.env.APPLICATION_HOST;

const BlogPage = ({
}) => {

    const metadata: Metadata = {
        title: 'Blog | Kuray Karaaslan',
        description: 'Welcome to my tech blog! I’m Kuray Karaaslan, a frontend, backend, and mobile developer skilled in React, Next.js, Node.js, Java, and React Native. I share practical coding tutorials, industry insights, and UI/UX tips to help developers and tech enthusiasts excel. Stay updated, solve problems, and grow your tech expertise with me!',
        openGraph: {
            title: 'Blog | Kuray Karaaslan',
            description: 'Welcome to my tech blog! I’m Kuray Karaaslan, a frontend, backend, and mobile developer skilled in React, Next.js, Node.js, Java, and React Native. I share practical coding tutorials, industry insights, and UI/UX tips to help developers and tech enthusiasts excel. Stay updated, solve problems, and grow your tech expertise with me!',
            type: 'website',
            url: `${APPLICATION_HOST}/blog`,
            images: [
                `${APPLICATION_HOST}/assets/img/og.png`,
            ],
        },
    };

    return (
        <>
            {MetadataHelper.generateElements(metadata)}
            <Feed category={null} />
            <CategoryBullets />
            <Newsletter />
        </>
    );
};

export default BlogPage;


=== ./app/(frontend)/blog/sitemap.xml/route.ts ===
// app/blog/sitemap.xml/route.ts
import { NextResponse } from 'next/server';
import PostService from '@/services/PostService';
import { getBaseUrl, renderUrlSet } from '@/helpers/SitemapGenerator';
import redisInstance from '@/libs/redis';
import type { SitemapUrl } from '@/types/SitemapTypes';

const CACHE_KEY = 'sitemap:blog';
const CACHE_TTL = 60 * 60; // 1 saat

export async function GET() {
  // 1. Önce Redis’ten dene
  const cached = await redisInstance.get(CACHE_KEY);
  if (cached) {
    return new NextResponse(cached, {
      headers: { 'Content-Type': 'application/xml; charset=utf-8' },
    });
  }

  // 2. Cache yoksa DB/Service’ten çek
  const BASE = getBaseUrl();
  const posts = await PostService.getAllPostSlugs();

  const urls: SitemapUrl[] = posts.map((p: any) => ({
    loc: `${BASE}/blog/${p.categorySlug}/${p.slug}`,
    lastmod: p.updatedAt ? new Date(p.updatedAt).toISOString() : undefined,
    changefreq: 'daily',
    priority: 0.8,
  }));

  const xml = renderUrlSet(urls);

  // 3. Redis’e yaz
  await redisInstance.set(CACHE_KEY, xml, 'EX', CACHE_TTL);

  return new NextResponse(xml, {
    headers: { 'Content-Type': 'application/xml; charset=utf-8' },
  });
}


=== ./app/(frontend)/blog/[categorySlug]/page.tsx ===
import Newsletter from '@/components/frontend/Newsletter';
import {  ToastContainer } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';
import Feed from '@/components/frontend/Feed';
import { Category } from '@prisma/client';
import CategoryService from '@/services/CategoryService';
import { notFound } from 'next/navigation';
import { Metadata } from 'next';
import MetadataHelper from '@/helpers/MetadataHelper';

const APPLICATION_HOST = process.env.APPLICATION_HOST;

export default async function CategoryPage({ params }: { params: { categorySlug: string } }) {
    try {

        const { categorySlug } = await params;

        if (!categorySlug) {
            notFound();
        }


        const category = await CategoryService.getCategoryBySlug(categorySlug) as Category | null;

        if (!category) {
            notFound();
        }

    

        const metadata: Metadata = { 
            title: `${category.title} | Kuray Karaaslan`,
            description: category.description || `Discover posts in the ${category.title} category.`,
            openGraph: {
                title: `${category.title} | Kuray Karaaslan`,
                description: category.description || `Explore all articles in the ${category.title} category.`,
                type: 'website',
                url: `${APPLICATION_HOST}/blog/${category.slug}`,
                images: [category.image || `${APPLICATION_HOST}/assets/img/og.png`],
            },
        };

        return (
            <>
                {MetadataHelper.generateElements(metadata)}
                <Feed category={category} />
                <Newsletter />
                <ToastContainer />
            </>
        );
        
    } catch (error) {
        console.error('Error fetching category:', error);
        return (
            <div className="text-center text-red-500 py-10">
                Oops! Unable to load category. Please try again later.
            </div>
        );
    }
}


=== ./app/(frontend)/blog/[categorySlug]/[postSlug]/page.tsx ===
import React from 'react';
import Article from '@/components/frontend/Article';
import PostService from '@/services/PostService';

import { Metadata } from 'next';
import { notFound } from 'next/navigation';
import Comments from '@/components/frontend/Comments';
import OtherPosts from '@/components/frontend/OtherPosts';
import Newsletter from '@/components/frontend/Newsletter';
import PostHeader from '@/components/frontend/PostHeader';


import MetadataHelper from '@/helpers/MetadataHelper';
import UserSessionService from '@/services/AuthService/UserSessionService';

const APPLICATION_HOST = process.env.APPLICATION_HOST;

export default async function BlogPost({ request, params }: { request: NextRequest, params: { categorySlug: string, postSlug: string } }) {
    try {

        const { postSlug } = await params;


        if (!postSlug) {
            notFound();
        }

        const response = await PostService.getAllPosts({
            page: 1,
            pageSize: 1,
            slug: postSlug,
            status: 'ALL',
        });

        const { posts } = response;

        if (!posts || posts.length === 0) {
            notFound();
        }

        const post = posts[0];

        if (!post) {
            notFound();
        }

        if (post.status !== 'PUBLISHED') {
            // Check if the user is authenticated and has the required role
            await UserSessionService.authenticateUserByRequest(request, "ADMIN");
        }

        await PostService.incrementViewCount(post.postId);
        post.views++;

        const metadata : Metadata = {
            title: `${post.title} | Kuray Karaaslan`,
            description: post.description || post.content.substring(0, 150),
            openGraph: {
                title: `${post.title} | Kuray Karaaslan`,
                description: post.description || post.content.substring(0, 150),
                type: 'article',
                url: `${APPLICATION_HOST}/blog/${post.category.slug}/${post.slug}`,
                images: [ post.image ? post.image : `${APPLICATION_HOST}/api/posts/${post.postId}/cover.jpeg` ],
            },
        }

        return (
            <>
                {MetadataHelper.generateElements(metadata)}
                <section className="min-h-screen bg-base-100 pt-32" id="blog">
                    <div className="container mx-auto px-4 lg:px-8 mb-8 flex-grow flex-col">
                        <PostHeader {...post} />
                        <Article {...post} />
                        <OtherPosts currentPostId={post.postId} categoryId={post.categoryId} />
                        <Comments postId={post.postId} />
                    </div>
                </section>
                <Newsletter />
            </>
        );
    } catch (error) {
        console.error('Error fetching post:', error);
        notFound();
    }
}


=== ./app/(frontend)/blog/user/[userId]/page.tsx ===
import React from 'react';
import AuthorHeader from '@/components/frontend/AuthorHeader';
import PostService from '@/services/PostService';

import { Metadata } from 'next';
import { notFound } from 'next/navigation';
import Comments from '@/components/frontend/Comments';
import OtherPosts from '@/components/frontend/OtherPosts';
import Newsletter from '@/components/frontend/Newsletter';
import PostHeader from '@/components/frontend/PostHeader';


import MetadataHelper from '@/helpers/MetadataHelper';
import UserSessionService from '@/services/AuthService/UserSessionService';
import UserService from '@/services/UserService';
import { ToastContainer } from 'react-toastify';
import Feed from '@/components/frontend/Feed';

const APPLICATION_HOST = process.env.APPLICATION_HOST;

export default async function AuthorPage({ request, params }: { request: NextRequest, params: { userId: string } }) {
    try {

        const { userId } = await params;


        if (!userId) {
            notFound();
        }

        const response = await UserService.getById(userId);

        if (!response) {
            notFound();
        }

        const user = response;

        if (!user) {
            notFound();
        }

        if (user.userRole !== 'ADMIN') {
            notFound();
        }


        const metadata : Metadata = {
            title: `${user.name} | kuray.dev`,
            description: user.name ? `Posts by ${user.name}` : 'Author page',
            openGraph: {
                title: `${user.name} | kuray.dev`,
                description: user.biography || "No biography available",
                type: 'profile',
                url: `${APPLICATION_HOST}/author/${user.userId}`,
                images: [ user.profilePicture ? user.profilePicture : `${APPLICATION_HOST}/assets/img/og.png` ],
            },
        }

 
        return (
            <>
                {MetadataHelper.generateElements(metadata)}
                <Feed author={user} />
                <Newsletter />
                <ToastContainer />
            </>
        );

    } catch (error) {
        console.error('Error fetching post:', error);
        notFound();
    }
}


=== ./app/(frontend)/project/page.tsx ===
import 'react-toastify/dist/ReactToastify.css';
import { notFound } from 'next/navigation';

export default async function ({ params }: { params: { categorySlug: string } }) {


    // Disable this page for now
    return notFound();

    return (
        <>
        </>
    );
};


=== ./app/(frontend)/project/sitemap.xml/route.ts ===
// app/project/sitemap.xml/route.ts
import { NextResponse } from 'next/server';
import ProjectService from '@/services/ProjectService';
import { getBaseUrl, renderUrlSet } from '@/helpers/SitemapGenerator';
import redisInstance from '@/libs/redis';
import type { SitemapUrl } from '@/types/SitemapTypes';

const CACHE_KEY = 'sitemap:project';
const CACHE_TTL = 60 * 60;

export async function GET() {
  const cached = await redisInstance.get(CACHE_KEY);
  if (cached) {
    return new NextResponse(cached, {
      headers: { 'Content-Type': 'application/xml; charset=utf-8' },
    });
  }

  const BASE = getBaseUrl();
  const projects = await ProjectService.getAllProjectSlugs();

  const urls: SitemapUrl[] = projects.map((pr: any) => ({
    loc: `${BASE}/project/${pr.slug}`,
    lastmod: pr.updatedAt ? new Date(pr.updatedAt).toISOString() : undefined,
    changefreq: 'weekly',
    priority: 0.7,
  }));

  const xml = renderUrlSet(urls);
  await redisInstance.set(CACHE_KEY, xml, 'EX', CACHE_TTL);

  return new NextResponse(xml, {
    headers: { 'Content-Type': 'application/xml; charset=utf-8' },
  });
}


=== ./app/(frontend)/project/[projectSlug]/page.tsx ===
import React from 'react';
import { Metadata } from 'next';
import { notFound } from 'next/navigation';
import Newsletter from '@/components/frontend/Newsletter';
import ProjectService from '@/services/ProjectService';
import Image from 'next/image';
import SingleProject from '@/components/frontend/SingleProject';
import { faDownload, faExternalLinkAlt, faFile } from '@fortawesome/free-solid-svg-icons';
import { faGithub, faYoutube, faLinkedin, faTwitter, faInstagram, faFacebook, faDiscord, faGitlab } from '@fortawesome/free-brands-svg-icons';

const SinglePin = ({ bgColor, textColor, text }: { bgColor: string, textColor: string, text: string }) => (
    <div className={`bg-${bgColor} text-${textColor} rounded-lg p-1`}>
        <p className="text-center">{text}</p>
    </div>
);

export default async function ProjectPage({ params }: { params: { projectSlug: string } }) {

    // disabled
    return notFound();

    try {


        const params = useParams();


        const response = await ProjectService.getAllProjects({
            slug: params.projectSlug,
            page: 1,
            pageSize: 1,
            onlyPublished: true
        });

        if (!response.projects || response.projects.length === 0) {
            notFound();
        }

        const project = response.projects[0];
        const meta = generateMetadata(project);
        const readTime = Math.ceil(project.content.split(' ').length / 200);

        return (
            <>
                {generateMetadataElement(meta)}
                <section className="min-h-screen pt-32 pb-8 bg-base-100" id="project">
                    <div className="mx-auto px-4 lg:px-8 mb-8 flex justify-between md:flex-row flex-col h-full gap-2">
                        <div className="flex-none flex md:min-w-80">
                            <div className="md:w-80 h-full rounded-lg bg-base-300 md:shadow-lg md:drop-shadow-lg border border-base-200">
                                <Image
                                    src={project.image || 'https://kuray.dev/images/logo.png'}
                                    alt={project.title}
                                    width={400}
                                    height={400}
                                    layout="responsive"
                                    className="rounded-t-lg object-cover"
                                />
                                <div className="flex flex-col space-y-2 mt-4 p-4">
                                    <h1 className="text-xl font-bold">{project.title}</h1>
                                    <h2 className="text-sm">
                                        <span className="font-bold">Description:</span> {project.description}
                                    </h2>
                                    <h2 className="text-sm">
                                        <span className="font-bold">Technologies:</span> {project.technologies.join(', ')}
                                    </h2>
                                    <h3 className="text-sm">
                                        <span className="font-bold mb-2">Categories:</span> {project.platforms.join(', ')}
                                    </h3>
                                </div>
                            </div>
                        </div>
                        <div className="flex-1">
                            <SingleProject {...project} />
                        </div>
                    </div>
                </section>
                <Newsletter backgroundColor="bg-base-200" />
            </>
        );
    } catch (error) {
        console.error('Error fetching project:', error);
        return (
            <div className="text-center text-red-500 py-10">
                Oops! Something went wrong while loading the project. Please try again later.
            </div>
        );
    }
}

function generateMetadata(project: any): Metadata {
    return {
        title: `${project.title} | Kuray Karaaslan`,
        description: project.description || project.content.substring(0, 160),
        openGraph: {
            title: `${project.title} | Kuray Karaaslan`,
            description: project.description || project.content.substring(0, 160),
            type: 'article',
            url: `https://kuray.dev/project/${project.slug}/`,
            images: [project.image || 'https://kuray.dev/images/logo.png'],
        },
    };
}

function generateMetadataElement(meta: Metadata) {
    return (
        <>
            <title>{String(meta?.title)}</title>
            <meta name="description" content={String(meta?.description)} />
            <meta property="og:title" content={String(meta?.openGraph?.title)} />
            <meta property="og:description" content={String(meta?.openGraph?.description)} />
            <meta property="og:type" content="article" />
            <meta property="og:url" content={String(meta?.openGraph?.url)} />
            <meta property="og:image" content={Array.isArray(meta?.openGraph?.images) ? String(meta?.openGraph?.images?.[0]) : String(meta?.openGraph?.images)} />
            <meta property="og:site_name" content="kuray.dev" />
            <meta property="twitter:card" content="summary_large_image" />
            <meta property="twitter:title" content={String(meta?.openGraph?.title)} />
            <meta property="twitter:description" content={String(meta?.openGraph?.description)} />
            <meta property="twitter:image" content={Array.isArray(meta?.openGraph?.images) ? String(meta?.openGraph?.images?.[0]) : String(meta?.openGraph?.images)} />
            <link rel="canonical" href={String(meta?.openGraph?.url)} />
        </>
    );
}

const allowedIconOptions = [
    { value: 'github', label: 'GitHub', icon: faGithub },
    { value: 'demo', label: 'Demo', icon: faExternalLinkAlt },
    { value: 'gitlab', label: 'GitLab', icon: faGitlab },
    { value: 'download', label: 'Download', icon: faDownload },
    { value: 'link', label: 'Link', icon: faExternalLinkAlt },
    { value: 'file', label: 'File', icon: faFile },
    { value: 'external-link', label: 'External Link', icon: faExternalLinkAlt },
    { value: 'youtube', label: 'YouTube', icon: faYoutube },
    { value: 'linkedin', label: 'LinkedIn', icon: faLinkedin },
    { value: 'twitter', label: 'Twitter', icon: faTwitter },
    { value: 'instagram', label: 'Instagram', icon: faInstagram },
    { value: 'facebook', label: 'Facebook', icon: faFacebook },
    { value: 'discord', label: 'Discord', icon: faDiscord },
];


=== ./app/(api)/api/posts/[postId]/cover.jpeg/route.tsx ===
import React from 'react';
import { ImageResponse } from 'next/og';
import PostService from '@/services/PostService';
import { NextRequest } from 'next/server';
import { notFound } from 'next/navigation';

export async function GET(request: NextRequest,
    { params }: { params: { postId: string } }) {

    const { postId } = await params;

    try {
        const post = await PostService.getPostById(postId);

        //if there is no post, return 404

        if (!post) {
            return notFound();
        }

        //if there is a image, return the image
        if (post.image) {
            return new ImageResponse(<img src={post.image} width={1200} height={630} />, {
                width: 1200,
                height: 630,
            });
        }

        const header = (
            <div style={{
                width: 1200,
                height: '100%',
                display: 'flex',
                flexDirection: 'column',
                justifyContent: 'center', // Center horizontally
                alignItems: 'center', // Center vertically
                textAlign: 'center',
                padding: '50px',
                position: 'absolute',
                top: 0,
                left: '50%', // Move it to the center of the screen
                transform: 'translateX(-50%)', // Offset it back by half its width
                fontWeight: 'bold',
                fontSize: post.title.length > 50 ? 40 : 60,
            }}>
                <h1 style={{ fontStyle: 'italic' }}>{post.title}</h1>
            </div>
        );



        return new ImageResponse(
            (

                <div
                    style={{
                        fontSize: 15,
                        width: '100%',
                        height: '100%',
                        display: 'flex',
                        flexDirection: 'row',
                        padding: '30px',
                        position: 'relative',
                        backgroundColor: '#c3c8d7',
                    }}
                >

                    {header}
                </div>
            ),
            {
                width: 1200,
                height: 630,
                headers: {
                    'Cache-Control': 'public, max-age=3600',
                    'Content-Type': 'image/jpeg',
                },
            }
        );

    } catch (error: any) {
        console.error(error.message);
        return notFound();
    }
}


=== ./app/(api)/api/posts/[postId]/like/count/route.ts ===
import { NextRequest, NextResponse } from 'next/server';
import PostLikeService from '@/services/PostService/LikeService';

export async function GET(_: NextRequest, { params }: { params: { postId: string } }) {
  try {
    const { postId } = await params;
    const total = await PostLikeService.countLikes(postId);
    return NextResponse.json({ success: true, total });
  } catch (error: any) {
    return NextResponse.json({ success: false, error: error.message }, { status: 400 });
  }
}


=== ./app/(api)/api/posts/[postId]/like/route.ts ===
import { NextResponse } from 'next/server';
import PostLikeService from '@/services/PostService/LikeService';
import UserSessionService from '@/services/AuthService/UserSessionService';

export async function POST(request: NextRequest, { params }: { params: { postId: string } }) {
  try {

    await UserSessionService.authenticateUserByRequest(request, 'GUEST' );
    
    const { postId } = await params;
    const userId = request?.user?.userId || null;
    
    // Call the likePost method with the postId and userId
    await PostLikeService.likePost({
      postId,
      userId,
      request, // Pass the request
    });

    return NextResponse.json({ success: true });
  } catch (error: any) {
    console.error('Error liking post:', error);
    return NextResponse.json({ success: false, error: error.message }, { status: 400 });
  }
}

=== ./app/(api)/api/posts/route.ts ===
"use server";

import { NextResponse } from "next/server";
   
import PostService from "@/services/PostService";
import AuthService from "@/services/AuthService";
import UserSessionService from "@/services/AuthService/UserSessionService";


/**
 * GET handler for retrieving all posts with optional pagination and search.
 * @param request - The incoming request object
 * @returns A NextResponse containing the posts data or an error message
 */
export async function GET(request: NextRequest) {
    try {

        const { searchParams } = new URL(request.url);

        // Extract query parameters
        const page = parseInt(searchParams.get('page') || '1', 10);
        const pageSize = parseInt(searchParams.get('pageSize') || '10', 10);
        const postId = searchParams.get('postId') || undefined;
        const authorId = searchParams.get('authorId') || undefined;
        const status = searchParams.get('status') || 'PUBLISHED';
        const categoryId = searchParams.get('categoryId') || undefined;
        const search = searchParams.get('search') || undefined;

        const result = await PostService.getAllPosts({
            page,
            pageSize,
            status,
            categoryId,
            search,
            postId,
            authorId,
        
        });

        return NextResponse.json({ posts: result.posts, total: result.total , page, pageSize });

    }
    catch (error: any) {
        console.error(error.message);
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}

/**
 * POST handler for creating a new post.
 * @param request - The incoming request object
 * @returns A NextResponse containing the new post data or an error message
 */
export async function POST(request: NextRequest) {
    try {

        UserSessionService.authenticateUserByRequest(request, "ADMIN");

        const body = await request.json();

        const post = await PostService.createPost(body);
        
        return NextResponse.json({ post });

    }
    catch (error: any) {
        console.error(error.message);
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}

/**
 * PUT handler for updating a post.
 * @param request - The incoming request object
 * @returns A NextResponse containing the updated post data or an error message
 */
export async function PUT(request: NextRequest) {
    try {

        await UserSessionService.authenticateUserByRequest(request, "ADMIN");

        const data = await request.json();
 
        const post = await PostService.updatePost(data);
        
        return NextResponse.json({ post });

    }
    catch (error: any) {
        console.error(error.message);
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}



=== ./app/(api)/api/contact/form/route.ts ===
"use server";
import { NextRequest, NextResponse } from 'next/server';
import DiscordService from '@/services/SocialMediaService/DiscordService';
import ContactFormService from '@/services/ContactFormService';
import MailService from '@/services/NotificationService/MailService';
import SMSService from '@/services/NotificationService/SMSService';

import AdminContactUsMailTemplate from '@/helpers/MailTemplates/Admin/AdminContactUsMailTemplate';
import CustomerContactUsMailTemplate from '@/helpers/MailTemplates/Customer/CustomerContactUsMailTemplate';

import AdminContactUsSMSTemplate from '@/helpers/SMSTemplates/Admin/AdminContactUsSMSTemplate';
import CustomerContactUsSMSTemplate from '@/helpers/SMSTemplates/Customer/CustomerContactUsSMSTemplate';

type ResponseData = {
    message: string;
};


export async function POST(req: NextRequest, res: NextResponse<ResponseData>) {

    const { name, email, phone, message } = await req.json();

    if (!name || !email || !phone || !message) {
        return NextResponse.json({ message: "Please fill in the required fields." }, { status: 400 });
    }

    const INFORM_NAME = process.env.INFORM_MAIL as string;
    const INFORM_TITLE = process.env.INFORM_TITLE as string;
    const INFORM_MAIL = process.env.INFORM_MAIL as string;
    const INFORM_PHONE = process.env.INFORM_PHONE as string;

    //find recent contact form entries
    const recentEntries = await ContactFormService.getRecentContactFormEntriesByPhoneOrEmail(phone, email);

    try {
        const data = {
            name: name,
            email: email,
            phone: phone,
            message: message
        };

        await ContactFormService.createContactForm(data);
    } catch (error) { console.error(error); }

    try {
        const adminMailBody = AdminContactUsMailTemplate({ name, email, message, phone });
        await MailService.sendMail(INFORM_MAIL, "Contact Form Message", adminMailBody);
    } catch (error) { console.error(error); }

    try {
        const customerMailBody = CustomerContactUsMailTemplate({ name, email, message, phone });
        await MailService.sendMail(email, "Contact Form Message", customerMailBody);
    } catch (error) { console.error(error); }


    try {
        const discordMessage = `A new message has been received from the contact form.\n\nName: ${name}\nEmail: ${email}\nPhone: ${phone}\nMessage: ${message}`;
        await DiscordService.sendWebhookMessage(discordMessage);
    } catch (error) { console.error(error); }

    try {
        const customerSMSBody = CustomerContactUsSMSTemplate({ name });

        if (recentEntries.length === 0) {
            // Send SMS to customer if user not contacted recently 
            await SMSService.sendShortMessage({ to: phone, body: customerSMSBody });
        } 

    } catch (error) { console.error(error); }

    try {
        const adminSMSBody = AdminContactUsSMSTemplate({ name });
        if (recentEntries.length === 0) {
            // Send SMS to admin if user not contacted recently
            await SMSService.sendShortMessage({ to: INFORM_PHONE, body: adminSMSBody });
        }
        
        
    } catch (error) { console.error(error); }

    return NextResponse.json({ message: "Your message has been sent successfully." });
}




=== ./app/(api)/api/contact/subscription/route.ts ===
"use server";
import { NextRequest, NextResponse } from 'next/server';
import SubscriptionService from '@/services/SubscriptionService';

type ResponseData = {
    message: string;
};

export async function POST(req: NextRequest, res: NextResponse<ResponseData>) {

    const { email } = await req.json();

    if (!email) {
        return NextResponse.json({ message: "Please fill in the required fields." }, { status: 400 });
    }


    try {
        await SubscriptionService.createSubscription(email);  
        return NextResponse.json({ message: "You have been successfully subscribed." });

    } catch (error) { 

        return NextResponse.json({ message: "An error occurred while trying to subscribe." }, { status: 500 });

    }
}

export async function DELETE(req: NextRequest, res: NextResponse<ResponseData>) {

    const { email } = await req.json();

    if (!email) {
        return NextResponse.json({ message: "Please fill in the required fields." }, { status: 400 });
    }

    try {
        await SubscriptionService.deleteSubscription(email);
        return NextResponse.json({ message: "You have been successfully unsubscribed." });
    } catch (error) {
        return NextResponse.json({ message: "An error occurred while trying to unsubscribe." }, { status: 500 });
    }

}

=== ./app/(api)/api/contact/info/phone/route.ts ===
"use server";
import { NextResponse , NextRequest} from 'next/server';

type ResponseData = {
    message: string;
    phones: Array<{
        CountryCode: string;
        PhoneNumber: string;
        noSpacePhoneNumber: string;
        hasTelegram: boolean;
        hasWhatsapp: boolean;
    }>;
};

export async function GET(req: NextRequest, res: NextResponse<ResponseData>) {

    const phones = [
        {
            "CountryCode": "gb",
            "PhoneNumber": "+44 7456 373554",
            "noSpacePhoneNumber": "+447456373554",
            "hasWhatsapp": false,
            "hasTelegram": false
        },
        {
            "CountryCode": "tr",
            "PhoneNumber": "+90 545 922 3554",
            "noSpacePhoneNumber": "+905459223554",
            "hasWhatsapp": false,
            "hasTelegram": false
        }
    ]

    return NextResponse.json({ message: "phones fetched successfully", phones });
}
//




=== ./app/(api)/api/contact/info/mail/route.ts ===
"use server";
import { NextRequest, NextResponse } from 'next/server';


type ResponseData = {
    message: string;
    mails: Array<{
        mail: string;
    }>;
};

export async function GET(req: NextRequest, res: NextResponse<ResponseData>) {

    const mails = [
        {
            "mail": "kuraykaraaslan@gmail.com"
        }
    ]

    return NextResponse.json({ message: "mails fetched successfully", mails });
}
//




=== ./app/(api)/api/widget/posts/route.tsx ===
import React from 'react';
import { ImageResponse } from 'next/og';
import PostService from '@/services/PostService';
import { NextRequest } from 'next/server';

export async function GET(request: NextRequest) {
    const { posts } = await PostService.getAllPosts({ page: 1, pageSize: 10, search: undefined });

    // Convert posts to JSX list items
    const listItems = posts.slice(0, 10).map((post, index) => (
        <div key={post.title} style={{
            fontSize: 15,
            width: 850,
            height: '100%',
            display: 'flex',
            flexDirection: 'row',
            padding: '20px',
            position: 'absolute',
            top: index * 30,
        }}>
            &#8226; {post.title.length > 100 ? post.title.substring(0, 100) + '...' : post.title}
        </div>
    ));

    const header = (
        <div style={{
            width: 600,
            height: '100%',
            display: 'flex',
            flexDirection: 'row',
            padding: '20px',
            position: 'absolute',
            top: 0,
            fontWeight: 'bold',
            fontSize: 20,
        }}>
            Latest Posts
        </div>
    );

    return new ImageResponse(
        (
            <div
                style={{
                    fontSize: 15,
                    width: '100%',
                    height: '100%',
                    display: 'flex',
                    flexDirection: 'row',
                    padding: '20px',
                    position: 'relative',
                    backgroundColor: '#c3c8d7',
                }}
            >
                <ul style={{ padding: 0 }}>{listItems}</ul>
            </div>
        ),
        {
            width: 900,
            height: 350,
        }
    );
}


=== ./app/(api)/api/sections/github/route.ts ===
"use server";

import { NextRequest, NextResponse } from "next/server";
import GithubService from "@/services/IntegrationService/GithubService";

export async function GET(req: NextRequest) {
  try {
    const data = await GithubService.getContributionCalendar();
    return NextResponse.json(data, { status: 200 });
  } catch (error) {
    return NextResponse.json({ message: "Error", error }, { status: 500 });
  }
}

=== ./app/(api)/api/sections/gitlab/route.ts ===
import { NextResponse } from "next/server";
import GitlabService from "@/services/IntegrationService/GitlabService";

export async function GET() {
  try {
    const data = await GitlabService.getMockContributions();
    return NextResponse.json({ message: "Success", data });
  } catch (error) {
    return NextResponse.json({ message: "Error", error }, { status: 500 });
  }
}


=== ./app/(api)/api/projects/route.ts ===
"use server";

import { NextResponse } from "next/server";
import { Project } from "@prisma/client";
import ProjectService from "@/services/ProjectService";
import UserSessionService from "@/services/AuthService/UserSessionService";

/**
 * GET handler for retrieving all projects with optional pagination and search.
 * @param request - The incoming request object
 * @returns A NextResponse containing the projects data or an error message
 * */
export async function GET(request: NextRequest) {
    try {
        const { searchParams } = new URL(request.url);

        // Extract query parameters
        const page = parseInt(searchParams.get('page') || '1', 10);
        const pageSize = parseInt(searchParams.get('pageSize') || '10', 10);
        const search = searchParams.get('search') || undefined;
        const projectId = searchParams.get('projectId') || undefined;

        const result = await ProjectService.getAllProjects({
            page,
            pageSize,
            search,
            projectId
        });
        
        return NextResponse.json({ projects: result.projects, total: result.total , page, pageSize });

    }
    catch (error: any) {
        console.error(error.message);
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}

/**
 * POST handler for creating a new project.
 * @param request - The incoming request object
 * @returns A NextResponse containing the newly created project or an error message
 * */
export async function POST(request: NextRequest) {
    try {

        await UserSessionService.authenticateUserByRequest(request, "ADMIN");

        const data = await request.json() as Omit<Project, 'projectId'>;
        const project = await ProjectService.createProject(data) as Project;
        
        return NextResponse.json({ project });

    }
    catch (error: any) {
        console.error(error.message);
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }

}


/**
 * PUT handler for updating an existing project.
 * @param request - The incoming request object
 * @returns A NextResponse containing the updated project data or an error message
 * */
export async function PUT(request: NextRequest) {
    try {

        await UserSessionService.authenticateUserByRequest(request, "ADMIN");

        const data = await request.json() as Project;
        const project = await ProjectService.updateProject(data);
        
        return NextResponse.json({ project });

    }
    catch (error: any) {
        console.error(error.message);
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }

}


=== ./app/(api)/api/stats/route.ts ===
"use server";

import { NextResponse } from "next/server";
import StatService from "@/services/StatService";
import UserSessionService from "@/services/AuthService/UserSessionService";

/**
 * GET handler for retrieving all users.
 * @param request - The incoming request object
 * @returns A NextResponse containing the user data or an error message
 */
export async function GET(request: NextRequest) {

    try {

        await UserSessionService.authenticateUserByRequest(request);

        const { searchParams } = new URL(request.url);

        // Extract query parameters
        const stats = await StatService.getAllStats();

        const values = {
            totalPosts: stats.totalPosts || 0,
            totalCategories: stats.totalCategories || 0,
            totalUsers: stats.totalUsers || 0,
            totalViews: stats.totalViews || 0,
            totalComments: stats.totalComments || 0,
        };
        
        return NextResponse.json({ values });

    }
    catch (error: any) {
        console.error("Error in GET /api/stats:", error);
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}


=== ./app/(api)/api/comments/route.ts ===

import UserSessionService from '@/services/AuthService/UserSessionService';
import CommentService from '@/services/CommentService';
import PostService from '@/services/PostService';
import { NextResponse } from "next/server";


type ResponseData = {
    message: string;
};


export async function POST(request: NextRequest, res: NextResponse<ResponseData>) {

    try {
        await UserSessionService.authenticateUserByRequest(request, "USER");

        const { content, postId, parentId, email, name } = await request.json();

        if (!name || !email || !content) {
            return NextResponse.json({ message: "Please fill in the required fields." }, { status: 400 });
        }

        // Check if the post exists
        const post = await PostService.getPostById(postId);

        if (!post) {
            return NextResponse.json({ message: "Post not found." }, { status: 404 });
        }

        // Create the comment
        const comment = await CommentService.createComment({
            content,
            postId,
            parentId,
            email,
            name,
            status: 'PENDING', // or any default status
            createdAt: new Date(), // current date and time
        });

        return NextResponse.json({ message: "Comment created successfully." }, { status: 201 });

    } catch (error: any) {
        console.error(error.message);
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }

}


/**
 * GET handler for retrieving all posts with optional pagination and search.
 * @param request - The incoming request object
 * @returns A NextResponse containing the posts data or an error message
 */
export async function GET(request: NextRequest) {
    try {

        const { searchParams } = new URL(request.url);

        // Extract query parameters
        const page = parseInt(searchParams.get('page') || '1', 10);
        const pageSize = parseInt(searchParams.get('pageSize') || '10', 10);
        const postId = searchParams.get('postId') || undefined;
        const search = searchParams.get('search') || undefined;
        const pending = searchParams.get('pending') === 'true';

        if (pending) {
            // only allow admins to view pending comments
            await UserSessionService.authenticateUserByRequest(request, "ADMIN");
        } else {
            await UserSessionService.authenticateUserByRequest(request, "GUEST");
        }



        const data = {
            page,
            pageSize,
            search,
            postId,
            pending
        }

        const result = await CommentService.getAllComments(data);
        return NextResponse.json({ comments: result.comments, total: result.total, page, pageSize });

    }
    catch (error: any) {
        console.error(error.message);
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}

export async function PUT(request: NextRequest, res: NextResponse<ResponseData>) {

    try {
        await UserSessionService.authenticateUserByRequest(request, "ADMIN");
        const data = await request.json();
        await CommentService.updateComment(data);
        return NextResponse.json({ message: "Comment updated successfully." });
    } catch (error: any) {
        console.error(error.message);
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }

}


=== ./app/(api)/api/ai/gpt-4o/route.ts ===
"use server";

import { NextResponse } from "next/server";
import OpenAIService from "@/services/OpenAIService";
import UserSessionService from "@/services/AuthService/UserSessionService";

/**
 * POST handler for creating a new post.
 * @param request - The incoming request object
 * @returns A NextResponse containing the new post data or an error message
 */
export async function POST(request: NextRequest) {
    try {
        await UserSessionService.authenticateUserByRequest(request);
        const { prompt } = await request.json();
        const text = await OpenAIService.generateText(prompt);
        return NextResponse.json({ text });
    } catch (error: any) {
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}

=== ./app/(api)/api/ai/dall-e/route.ts ===
"use server";

import { NextResponse } from "next/server";
import OpenAIService from "@/services/OpenAIService";
import UserSessionService from "@/services/AuthService/UserSessionService";
/**
 * POST handler for creating a new post.
 * @param request - The incoming request object
 * @returns A NextResponse containing the new post data or an error message
 */
export async function POST(request: NextRequest) {
    try {
        await UserSessionService.authenticateUserByRequest(request);
        const { prompt } = await request.json();
        const url = await OpenAIService.generateImage(prompt);
        return NextResponse.json({ url });
    } catch (error: any) {
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}

=== ./app/(api)/api/aws/from-url/route.ts ===
'use server'

import { NextResponse } from 'next/server'
import AWSService from '@/services/StorageService/AWSService'
import UserSessionService from '@/services/AuthService/UserSessionService'
/**
 * POST handler for uploading a file to an S3 bucket.
 * @param req - The incoming request object
 * @returns A NextResponse containing the S3 URL or an error message
 */
export async function POST(request: NextRequest) {
    try {

        await UserSessionService.authenticateUserByRequest(request);

        const { url, folder } = await request.json();


        if (!url) {
            return NextResponse.json(
                { message: 'No URL provided' },
                { status: 400 }
            );
        }

        const urlReloaded = await AWSService.uploadFromUrl(url, folder);

        return NextResponse.json({ url: urlReloaded });

    }
    catch (error: any) {
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}




=== ./app/(api)/api/aws/route.ts ===
'use server'

import { NextResponse } from 'next/server'
import AWSService from '@/services/StorageService/AWSService'
import UserSessionService from '@/services/AuthService/UserSessionService'

/**
 * POST handler for uploading a file to an S3 bucket.
 * @param req - The incoming request object
 * @returns A NextResponse containing the S3 URL or an error message
 */
export async function POST(request: NextRequest) {
    try {

        await UserSessionService.authenticateUserByRequest(request);
        
        const formData = await request.formData();

        const file = formData.get('file');
        const folder = formData.get('folder');

        if (!file) {
            return NextResponse.json(
                { message: 'No file provided' },
                { status: 400 }
            );
        }

        const url = await AWSService.uploadFile(file as File, folder as string);

        return NextResponse.json({ url });

    }
    catch (error: any) {
        console.error(error.message);
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}




=== ./app/(api)/api/slot-templates/[day]/apply/route.ts ===
import { NextResponse } from 'next/server'
import SlotService from '@/services/AppointmentService/SlotService'
import { Day, Slot, SlotTemplate } from '@/types/CalendarTypes'
import UserSessionService from '@/services/AuthService/UserSessionService'
import SlotTemplateService from '@/services/AppointmentService/SlotTemplateService';
import { date } from 'zod';



export async function POST(
    request: NextRequest,
    { params }: { params: Promise<{ day: Day }> }
) {

    await UserSessionService.authenticateUserByRequest(request, "ADMIN");

    const { formattedDate } = await request.json();
    const { day } = await params

    if (!date) {
        return NextResponse.json(
            { success: false, message: 'Date is required' },
            { status: 400 }
        )
    }

    console.log("Applying template for 0", day, "to date", formattedDate);

    const SlotTemplate = await SlotTemplateService.getSlotTemplate(day);

    console.log("Fetched template:", SlotTemplate);
    
    if (!SlotTemplate || SlotTemplate.slots.length === 0) {
        return NextResponse.json(
            { success: false, message: 'No slot template found for the specified day' },
            { status: 404 }
        )
    }

    console.log("Applying template for 1", day, "to date", formattedDate);

    await SlotService.emptySlotsForDate(formattedDate);

    console.log("Applying template for", day, "to date", formattedDate);

    const createdSlots: Slot[] = [];

    for (const slot of SlotTemplate.slots) {
        const slotData: Slot = {
            startTime: slot.startTime,
            endTime: slot.endTime,
            capacity: slot.capacity, // Default capacity if not provided
        };
        const createdSlot = await SlotService.createSlot(slotData);
        createdSlots.push(createdSlot);
    }

    return NextResponse.json({ success: true, slots: createdSlots })
}





=== ./app/(api)/api/slot-templates/[day]/route.ts ===
import { NextResponse } from 'next/server'
import SlotTemplateService from '@/services/AppointmentService/SlotTemplateService'
import { Day, Slot } from '@/types/CalendarTypes'
import UserSessionService from '@/services/AuthService/UserSessionService'

/**
 * [day] → MONDAY..SUNDAY
 * GET:   haftalık şablonu getirir
 * POST:  haftalık şablonu kaydeder  { slots: [{ time, length? }] }
 */

export async function GET(
    req: Request,
    { params }: { params: Promise<{ day: Day }> }
) {
    try {
    const { day } = await params
    if (!day) {
        return NextResponse.json(
            { success: false, message: 'Day is required' },
            { status: 400 }
        )
    }
    const slotsTemplate = await SlotTemplateService.getSlotTemplate(day)

    return NextResponse.json(slotsTemplate)
    } catch (error: any) {
        console.error(error.message);
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}

export async function POST(
    request: NextRequest,
    { params }: { params: Promise<{ day: Day }> }
) {

    await UserSessionService.authenticateUserByRequest(request, "ADMIN");

    const { day, slots } = await request.json()

    console.log("Received template for day:", day, "with slots:", slots);

    if (!day) {
        return NextResponse.json(
            { success: false, message: 'Day is required' },
            { status: 400 }
        )
    }

    console.log("Day parameter:", day);

    if (!slots || !Array.isArray(slots)) {
        return NextResponse.json(
            { success: false, message: 'Slots are required and must be an array' },
            { status: 400 }
        )
    }

    console.log("Slots parameter:", slots);

    const result = Day.safeParse(day)

    if (!result.success) {
        return NextResponse.json(
            { success: false, message: 'Invalid day', issues: result.error.issues },
            { status: 400 }
        )
    }

    console.log("Day validation passed:", result.data);

    for (const slot of slots) {
        const result = Slot.safeParse(slot)
        if (!result.success) {
            console.log("Slot validation failed for slot:", slot, "Issues:", result.error.issues);
            return NextResponse.json(
                { success: false, message: 'Invalid slot', issues: result.error.issues },
                { status: 400 }
            )
        }
    }

    console.log("All slots validation passed");

    const slotsTemplate = await SlotTemplateService.createOrUpdateSlotTemplate(day, slots)

    return NextResponse.json({ slotsTemplate })
}


=== ./app/(api)/api/users/[userId]/route.ts ===
"use server";
import { NextResponse } from "next/server";
   
import UserService from "@/services/UserService";
import UserSessionService from "@/services/AuthService/UserSessionService";

/**
 * GET handler for retrieving a user by its ID.
 * @param request - The incoming request object
 * @param context - Contains the URL parameters, including userId
 * @returns A NextResponse containing the user data or an error message
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { userId: string } }
) {


  try {

    const { userId } = await params

    await UserSessionService.authenticateUserByRequest(request, "USER");

    const user = await UserService.getById(userId);

    if (!user) {
      return NextResponse.json(
        { message: "USER_NOT_FOUND" },
        { status: 404 }
      );
    }

    return NextResponse.json({ user });

  }
  catch (error: any) {
    return NextResponse.json(
      { message: error.message },
      { status: 500 }
    );
  }
}

/**
 * DELETE handler for deleting a user by its ID.
 * @param request - The incoming request object
 * @param context - Contains the URL parameters, including userId
 * @returns A NextResponse containing a success message or an error message
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: { userId: string } }
) {
  try {

    await UserSessionService.authenticateUserByRequest(request, "ADMIN");

    const { userId } = await params

    const user = await UserService.getById(userId);

    if (!user) {
      return NextResponse.json(
        { message: "USER_NOT_FOUND" },
        { status: 404 }
      );
    }

    await UserService.delete(userId);

    return NextResponse.json(
      { message: "USER_DELETED" },
    );
  }
  catch (error: any) {
    return NextResponse.json(
      { message: error.message },
      { status: 500 }
    );
  }
}

/**
 * PUT handler for updating a user by its ID.
 * @param request - The incoming request object
 * @param context - Contains the URL parameters, including userId
 * @returns A NextResponse containing the updated user data or an error message
 */
export async function PUT(
  request: NextRequest,
  { params }: { params: { userId: string } }
) {
  try {

    await UserSessionService.authenticateUserByRequest(request, "ADMIN");
    const { userId } = await params
    const user = await UserService.getById(userId);

    if (!user) {
      return NextResponse.json(
        { message: "USER_NOT_FOUND" },
        { status: 404 }
      );
    } 

    // TODO: add update user logic
    
    return NextResponse.json({ user });

  }
  catch (error: any) {
    return NextResponse.json(
      { message: error.message },
      { status: 500 }
    );
  }
}

=== ./app/(api)/api/users/route.ts ===
"use server";

import { NextResponse } from "next/server";
   
import UserService from "@/services/UserService";
import UserSessionService from "@/services/AuthService/UserSessionService";

/**
 * GET handler for retrieving all users.
 * @param request - The incoming request object
 * @returns A NextResponse containing the user data or an error message
 */
export async function GET(request: NextRequest) {

    try {

       await UserSessionService.authenticateUserByRequest(request, "USER");


        const { searchParams } = new URL(request.url);

        // Extract query parameters
        const page = searchParams.get('page') ? parseInt(searchParams.get('page') || '1', 10) : 1;
        const pageSize = searchParams.get('pageSize') ? parseInt(searchParams.get('pageSize') || '10', 10) : 10;
        const search = searchParams.get('search') || undefined;


        const {users, total} = await UserService.getAll({
            page,
            pageSize,
            search
        });      

        if (request?.user?.userRole !== "ADMIN") {
            //omit user data only id and name
            users.forEach((user: any) => {
                delete user.email;
                delete user.password;
                delete user.role;
                delete user.image;
                delete user.phone;
            });
        }

        return NextResponse.json({ users, total, page, pageSize });

    }
    catch (error: any) {
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}

/**
 * POST handler for creating a new user.
 * @param request - The incoming request object
 * @returns A NextResponse containing the new user data or an error message
 */
export async function POST(request: NextRequest) {
    try {

        await UserSessionService.authenticateUserByRequest(request, "ADMIN");

        const { email, password, name , phone, userRole } = await request.json();

        const user = await UserService.create({
            email,
            password,
            name,
            phone,
            userRole
        });

        return NextResponse.json({ user });

    }
    catch (error: any) {
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}


=== ./app/(api)/api/slots/[date]/route.ts ===
import { NextResponse } from 'next/server'
import SlotService from '@/services/AppointmentService/SlotService'
import { Day, Slot } from '@/types/CalendarTypes'
import UserSessionService from '@/services/AuthService/UserSessionService'

/**
 * [day] → MONDAY..SUNDAY
 * GET:   haftalık şablonu getirir
 * POST:  haftalık şablonu kaydeder  { slots: [{ time, length? }] }
 */

export async function GET(
    req: Request,
    { params }: { params: Promise<{ date: string }> }
) {
    try {
        const { date } = await params

        console.log("date", date);

        if (!date) {
            return NextResponse.json(
                { success: false, message: 'Date is required' },
                { status: 400 }
            )
        }

        const slots = await SlotService.getAllSlotsForDate(date)

        return NextResponse.json({ slots })
    } catch (error: any) {
        console.error(error);
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}

export async function POST(
    request: NextRequest,
    { params }: { params: Promise<{ day: Day }> }
) {

    await UserSessionService.authenticateUserByRequest(request, "ADMIN");

    const body = await request.json()

    const result = Slot.safeParse(body)
    if (!result.success) {
        return NextResponse.json(
            { success: false, message: 'Invalid slot data', issues: result.error.issues },
            { status: 400 }
        )
    }

    const slotData = result.data

    const createdSlot = await SlotService.createSlot(slotData)

    return NextResponse.json({ success: true, slot: createdSlot })
}



=== ./app/(api)/api/slots/route.ts ===
import SlotService from "@/services/AppointmentService/SlotService";
import { NextResponse } from "next/server";


export async function GET(
    req: Request
) {

    try {

        const { searchParams } = new URL(req.url);

        const page = parseInt(searchParams.get('page') || '1', 10);
        const pageSize = parseInt(searchParams.get('pageSize') || '10', 10);
        const startDate = searchParams.get('startDate') || undefined;
        const endDate = searchParams.get('endDate') || undefined;


        const { slots, total } = await SlotService.getAllSlotsForDateRange({
            startDate,
            endDate
        });

        return NextResponse.json({ slots, total });

    }
    catch (error: any) {
        console.error(error.message);
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}

=== ./app/(api)/api/settings/route.ts ===
"use server";

import { NextResponse } from "next/server";
   
import SettingService from "@/services/SettingService";
import UserSessionService from "@/services/AuthService/UserSessionService";
/**
 * GET handler for retrieving all settings.
 * @param request - The incoming request object
 * @returns A NextResponse containing the posts data or an error message
 */
export async function GET(request: NextRequest) {
    try {

        const settings = await SettingService.getSettings();

        return NextResponse.json({ settings });

    }
    catch (error: any) {
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}


/**
 * POST handler for updating settings.
 * @param request - The incoming request object
 * @returns A NextResponse containing the updated settings or an error message
 */
export async function POST(request: NextRequest) {
    try {

        await UserSessionService.authenticateUserByRequest(request, "ADMIN");        
        const { settings } = await request.json();
        const result = await SettingService.updateSettings(settings);

        return NextResponse.json({ settings: result });

    }
    catch (error: any) {
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}

=== ./app/(api)/api/booking/route.ts ===
import { NextResponse, NextRequest } from 'next/server'
import AppointmentService from '@/services/AppointmentService'
import Logger from '@/libs/logger'
import SlotService from '@/services/AppointmentService/SlotService'
// gerekirse: import UserSessionService from '@/services/AuthService/UserSessionService'

export async function POST(request: NextRequest) {
  try {
    // gerekirse auth:
    // await UserSessionService.authenticateUserByRequest(request, "USER")

    const body = await request.json()
    const { date, time , name, email, phone, note } = body || {}

    if (!!name || !email || !phone) {
      return NextResponse.json(
        { success: false, message: 'Missing required fields' },
        { status: 400 }
      )
    }

    // Assume slotId refers to a slot with date and time; fetch slot details
    const slot = await SlotService.getSlot(date, time)
    if (!slot) {
      return NextResponse.json(
        { success: false, message: 'Slot not found' },
        { status: 404 }
      )
    }

    const appointmentData = {
      status: "PENDING" as "PENDING",
      createdAt: new Date(),
      name,
      email,
      phone,
      appointmentId: crypto.randomUUID(),
      startTime: slot.startTime,
      endTime: slot.endTime,
      note: note ?? null
    }

    const result = await AppointmentService.createAppointment(appointmentData)

    console.log('Booking result:', result)


    return NextResponse.json(result)

    
  } catch (err: any) {
    Logger.error('API/booking POST: ' + err.message)
    return NextResponse.json(
      { success: false, message: 'Internal server error' },
      { status: 500 }
    )
  }
}


=== ./app/(api)/api/categories/route.ts ===
"use server";

import { NextResponse } from "next/server";
import CategoryService from "@/services/CategoryService";
import UserSessionService from "@/services/AuthService/UserSessionService";   


/**
 * GET handler for retrieving all posts with optional pagination and search.
 * @param request - The incoming request object
 * @returns A NextResponse containing the posts data or an error message
 */
export async function GET(request: Request) {
    try {
        const { searchParams } = new URL(request.url);

        // Extract query parameters
        const page = searchParams.get('page') ? parseInt(searchParams.get('page') || '1', 10) : 1;
        const pageSize = searchParams.get('pageSize') ? parseInt(searchParams.get('pageSize') || '10', 10) : 10;
        const search = searchParams.get('search') || undefined;

        const result = await CategoryService.getAllCategories(page, pageSize, search);

        return NextResponse.json({ categories: result.categories, total: result.total });

    }
    catch (error: any) {
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}

/**
 * POST handler for creating a new post.
 * @param request - The incoming request object
 * @returns A NextResponse containing the new post data or an error message
 */
export async function POST(request: NextRequest) {
    try {

        await UserSessionService.authenticateUserByRequest(request);

        const body = await request.json();

        const { title, description, slug, image } = body;

        const data = {
            title,
            description,
            slug,
            image,
        };

        const category = await CategoryService.createCategory(data);

        return NextResponse.json({ category });

    } catch (error: any) {
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}

/**
 * DELETE handler for deleting all categories.
 * @param request - The incoming request object
 * @returns A NextResponse containing a success message or an error message
 * */

export async function DELETE(request: Request) {
        try {
            await CategoryService.deleteAllCategories();

            return NextResponse.json(
                { message: "All categories deleted successfully." }
            );
        }
        catch (error: any) {
            return NextResponse.json(
                { message: error.message },
                { status: 500 }
            );
        }

    }

=== ./app/(api)/api/categories/[categoryId]/route.ts ===
"use server";
import { NextResponse } from "next/server";
import CategoryService from "@/services/CategoryService";
import UserSessionService from "@/services/AuthService/UserSessionService";

/**
 * GET handler for retrieving a category by its Id.
 * @param request - The incoming request object
 * @param context - Contains the URL parameters, including postId
 * @returns A NextResponse containing the post data or an error message
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ categoryId: string }> }
) {
  try {
    const { categoryId } = await params
    const category = await CategoryService.getCategoryById(categoryId);

    if (!category) {
      return NextResponse.json(
        { message: "Category not found." },
        { status: 404 }
      );
    }

    return NextResponse.json({ category });

  }
  catch (error: any) {
    return NextResponse.json(
      { message: error.message },
      { status: 500 }
    );
  }
}

/**
 * DELETE handler for deleting a category by its ID.
 * @param request - The incoming request object
 * @param context - Contains the URL parameters, including postId
 * @returns A NextResponse containing a success message or an error message
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ categoryId: string }> }
) {
  try {

    await UserSessionService.authenticateUserByRequest(request);


    const { categoryId } = await params;
    const category = await CategoryService.getCategoryById(categoryId);

    if (!category) {
      return NextResponse.json(
        { message: "Category not found." },
        { status: 404 }
      );
    }

    await CategoryService.deleteCategory(category.categoryId);

    return NextResponse.json(
      { message: "Category deleted successfully." }
    );
  }
  catch (error: any) {
    return NextResponse.json(
      { message: error.message },
      { status: 500 }
    );
  }
}

/**
 * PUT handler for updating a post by its ID.
 * @param request - The incoming request object
 * @param context - Contains the URL parameters, including postId
 * @returns A NextResponse containing the updated post data or an error message
 */
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ categoryId: string }> }
) {
  try {

    await UserSessionService.authenticateUserByRequest(request);

    const { categoryId } = await params;
    const post = await CategoryService.getCategoryById(categoryId);

    if (!post) {
      return NextResponse.json(
        { message: "Category not found." },
        { status: 404 }
      );
    }

    const data = await request.json();

    const updatedCategory = await CategoryService.updateCategory(post.categoryId, data);

    return NextResponse.json({ category: updatedCategory });
  }
  catch (error: any) {
    return NextResponse.json(
      { message: error.message },
      { status: 500 }
    );
  }
}

=== ./app/(api)/api/auth/logout/route.ts ===
// Original path: app/api/auth/logout/route.ts

 
import { NextResponse } from "next/server";
import AuthMessages from "@/messages/AuthMessages";

export async function POST(request: NextRequest) {
    try {

        return NextResponse.json({
            message: AuthMessages.LOGGED_OUT_SUCCESSFULLY,
        }, {
            status: 200,
            headers: {
                "Set-Cookie": [
                    `accessToken=; Path=/; HttpOnly; SameSite=Strict; Secure; Max-Age=0`,
                    `refreshToken=; Path=/; HttpOnly; SameSite=Strict; Secure; Max-Age=0`,
                ].join(", ")
            }
        });

    }
    catch (error: any) {
        console.error(error);
        return NextResponse.json({ error: error.message }, { status: 500 });
    }
}


=== ./app/(api)/api/auth/sso/[provider]/route.ts ===
// Original path: app/api/auth/callback/route.ts
import { NextResponse } from "next/server";
import SSOService from "@/services/AuthService/SSOService";
import RateLimiter from "@/libs/rateLimit";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ provider: string }> }
) {
  const { provider } = await params;

  try {
    await RateLimiter.useRateLimit(request);

    const url = await SSOService.generateAuthUrl(provider);

    return NextResponse.json({ url });
  } catch (error: any) {
    console.error(`Error generating SSO link for ${provider}:`, error);
    return NextResponse.json(
      { message: error.message },
      { status: 500 }
    );
  }
}






=== ./app/(api)/api/auth/session/route.ts ===
// path: app/api/auth/me/route.ts
import { NextResponse } from "next/server";
import UserSessionService from "@/services/AuthService/UserSessionService";
import RateLimiter from "@/libs/rateLimit";

export async function GET(request: NextRequest) {
    try {
        await RateLimiter.useRateLimit(request);
        await UserSessionService.authenticateUserByRequest(request, "USER");
        return NextResponse.json({ user: request.user }, { status: 200 });
    } catch (error: any) {
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }

}

=== ./app/(api)/api/auth/register/route.ts ===
// Original path: app/api/auth/register/route.ts

import { NextResponse } from "next/server";
import RateLimiter from "@/libs/rateLimit";

import AuthService from "@/services/AuthService";
import { RegisterRequest } from "@/dtos/AuthDTO";

export async function POST(request: NextRequest) {
    try {

        await RateLimiter.useRateLimit(request);


        const parsedData = RegisterRequest.safeParse(await request.json());

        if (!parsedData.success) {
            return NextResponse.json({
                error: parsedData.error.errors.map(err => err.message).join(", ")
            }, { status: 400 });
        }

        const { name, email, password, phone } = parsedData.data;
        
        const user = await AuthService.register({
            name,
            email,
            password,
            phone,
        });

        if (!user) {
            return NextResponse.json({ error: "Something went wrong." }, { status: 400 });
        }

        return NextResponse.json({ message: "User registered successfully." }, { status: 201 });
    }

    catch (error: any) {
        console.error(error);
        return NextResponse.json({ error: error.message }, { status: 500 });
    }
}


=== ./app/(api)/api/auth/forgot-password/route.ts ===
// Original path: app/api/auth/login/route.ts

import { NextResponse } from "next/server";
import AuthMessages from "@/messages/AuthMessages";
import RateLimiter from "@/libs/rateLimit";
import PasswordService from "@/services/AuthService/PasswordService";
import { ForgotPasswordRequest } from "@/dtos/AuthDTO";

export async function POST(request: NextRequest) {
    try {

        await RateLimiter.useRateLimit(request);

        const parsedData = ForgotPasswordRequest.safeParse(await request.json());

        if (!parsedData.success) {
            return NextResponse.json({
                error: parsedData.error.errors.map(err => err.message).join(", ")
            }, { status: 400 });
        }

        const { email } = parsedData.data;

        await PasswordService.forgotPassword({ email });

        return NextResponse.json({
            message: AuthMessages.FORGOT_PASSWORD_SUCCESSFUL,
        }, {
            status: 200,
            headers: {
                "Set-Cookie": [
                    `accessToken=; Path=/; HttpOnly; SameSite=Strict; Secure; Max-Age=0`,
                    `refreshToken=; Path=/; HttpOnly; SameSite=Strict; Secure; Max-Age=0`,
                ].join(", ")
            }
        });

    }
    catch (error: any) {
        console.error(error);
        return NextResponse.json({ error: error.message }, { status: 500 });
    }
}


=== ./app/(api)/api/auth/callback/[provider]/route.ts ===
// Original path: app/api/auth/callback/route.ts

import { NextRequest, NextResponse } from "next/server";
import UserSessionService from "@/services/AuthService/UserSessionService";
import SSOService from "@/services/AuthService/SSOService";
import MailService from "@/services/NotificationService/MailService";

// @ts-ignore
export async function GET(
    request: NextRequest,
    { params }: { params: Promise<{ provider: string }> }
) {
    const { provider } = await params;

    const searchParams = request.nextUrl.searchParams;

    const code = searchParams.get('code');
    const state = searchParams.get('state');

    if (!code) {
        //redirect to frontend
        NextResponse.redirect(process.env.APPLICATION_HOST + '/auth/login?error=Missing code');
    }

    const { user, newUser } = await SSOService.authCallback(provider, code as string);

    if (!user) {
        //redirect to frontend
        return NextResponse.redirect(`${process.env.APPLICATION_HOST}/auth/login?error=Failed to authenticate user`);

    }

    const { userSession, rawAccessToken, rawRefreshToken } = await UserSessionService.createSession(user, request as any);

    if (newUser) {
        await MailService.sendWelcomeEmail(user);
    } else {
        await MailService.sendNewLoginEmail(user, userSession);
    }

    if (!userSession) {
        //redirect to frontend
        return NextResponse.redirect(`${process.env.APPLICATION_HOST}/auth/login?error=Failed to create session`);
    }

    const response = NextResponse.redirect(
        `${process.env.APPLICATION_HOST}/auth/callback?rawAccessToken=${rawAccessToken}&rawRefreshToken=${rawRefreshToken}`
    )

    response.headers.set(
        'Set-Cookie',
        [
            `accessToken=${rawAccessToken}; Path=/; HttpOnly; SameSite=Strict; Secure`,
            `refreshToken=${rawRefreshToken}; Path=/; HttpOnly; SameSite=Strict; Secure`
        ].join(', ')
    )

    return response;

}



// @ts-ignore
export async function POST(
    request: NextRequest,
    { params }: { params: Promise<{ provider: string }> }
) {
    const { provider } = await params;

    const { code, state } = await request.json();

    if (!code) {
        //redirect to frontend
        NextResponse.redirect(process.env.APPLICATION_HOST + '/auth/login?error=Missing code');
    }

    const { user, newUser } = await SSOService.authCallback(provider, code as string);

    if (!user) {
        //redirect to frontend

    }

    const { userSession, rawAccessToken, rawRefreshToken } = await UserSessionService.createSession(user, request as any);

    if (newUser) {
        await MailService.sendWelcomeEmail(user);
    } else {
        await MailService.sendNewLoginEmail(user, userSession);
    }

    if (!userSession) {
        //redirect to frontend
        return NextResponse.redirect(`${process.env.APPLICATION_HOST}/auth/login?error=Failed to create session`);
    }

    //redirect to frontend
    return NextResponse.redirect(`${process.env.APPLICATION_HOST}/auth/callback?rawAccessToken=${rawAccessToken}&rawRefreshToken=${rawRefreshToken}`);

}




=== ./app/(api)/api/auth/login/route.ts ===
// Original path: app/api/auth/login/route.ts
 
import { NextResponse } from "next/server";
import AuthService from "@/services/AuthService";
import AuthMessages from "@/messages/AuthMessages";
import UserSessionService from "@/services/AuthService/UserSessionService";
import RateLimiter from "@/libs/rateLimit";
import { LoginRequest } from "@/dtos/AuthDTO";

export async function POST(request: NextRequest) {
    try {

        await RateLimiter.useRateLimit(request);


        const parsedData = LoginRequest.safeParse(await request.json());

        if (!parsedData.success) {
            return NextResponse.json({
                error: parsedData.error.errors.map(err => err.message).join(", ")
            }, { status: 400 });
        }

        const { email, password } = parsedData.data;

        const user = await AuthService.login({ email, password });

        if (!user) {
            throw new Error(AuthMessages.INVALID_CREDENTIALS);
        }

        const { userSession, rawAccessToken, rawRefreshToken, otpVerifyNeeded } = await UserSessionService.createSession(user, request);

        return NextResponse.json({
            user,
            accessToken: rawAccessToken,
            refreshToken: rawRefreshToken,
            otpVerifyNeeded,
        }, {
            status: 200,
            headers: {
                "Set-Cookie": [
                    `accessToken=${rawAccessToken}; Path=/; HttpOnly; SameSite=Strict; Secure`,
                    `refreshToken=${rawRefreshToken}; Path=/; HttpOnly; SameSite=Strict; Secure`,
                ].join(", ")    
            }
        });

    }
    catch (error: any) {
        console.error(error);
        return NextResponse.json({ error: error.message }, { status: 500 });
    }
}


=== ./app/(api)/api/auth/reset-password/route.ts ===
// Original path: app/api/auth/login/route.ts

 
import { NextResponse } from "next/server";
import AuthMessages from "@/messages/AuthMessages";
import RateLimiter from "@/libs/rateLimit";
import PasswordService from "@/services/AuthService/PasswordService";
import { ResetPasswordRequest } from "@/dtos/AuthDTO";

export async function POST(request: NextRequest) {
    try {

        await RateLimiter.useRateLimit(request);

        const { email , resetToken, password } = await request.json();

        const parsedData = ResetPasswordRequest.safeParse({ email, resetToken, password });

        if (!parsedData.success) {
            return NextResponse.json({
                error: parsedData.error.errors.map(err => err.message).join(", ")
            }, { status: 400 });
        }

        await PasswordService.resetPassword(parsedData.data);

        return NextResponse.json({
            message: AuthMessages.PASSWORD_RESET_SUCCESSFUL,
        }, {
            status: 200,
            headers: {
                "Set-Cookie": [
                    `accessToken=; Path=/; HttpOnly; SameSite=Strict; Secure; Max-Age=0`,
                    `refreshToken=; Path=/; HttpOnly; SameSite=Strict; Secure; Max-Age=0`,
                ].join(", ")
            }
        });

    }
    catch (error: any) {
        console.error(error);
        return NextResponse.json({ error: AuthMessages.PASSWORD_RESET_FAILED }, { status: 500 });
    }
}


=== ./app/(api)/api/appointments/[appointmentId]/cancel/route.ts ===
import { NextResponse } from 'next/server'
import Logger from '@/libs/logger'

import AppointmentService from '@/services/AppointmentService'

export async function POST(req: Request, { params }: { params: Promise<{ appointmentId: string }> }) {
  try {
    const { appointmentId } = await params

    const result = await AppointmentService.cancelAppointment(appointmentId)

    return NextResponse.json(result, {
      status: 200,
    })
  } catch (err: any) {
    Logger.error('API/appointments/[appointmentId]/cancel POST: ' + err.message)
    return NextResponse.json(
      { success: false, message: 'Internal server error' },
      { status: 500 }
    )
  }
}

=== ./app/(api)/api/appointments/[appointmentId]/book/route.ts ===
import { NextResponse } from 'next/server'
import Logger from '@/libs/logger'

import AppointmentService from '@/services/AppointmentService'

export async function POST(req: Request, { params }: { params: Promise<{ appointmentId: string }> }) {
  try {
    const { appointmentId } = await params

    const result = await AppointmentService.bookAppointment(appointmentId)

    return NextResponse.json(result, {
      status: 200,
    })
  } catch (err: any) {
    Logger.error('API/appointments/[appointmentId]/book POST: ' + err.message)
    return NextResponse.json(
      { success: false, message: 'Internal server error' },
      { status: 500 }
    )
  }
}

=== ./app/(api)/api/appointments/route.ts ===
import AppointmentService from '@/services/AppointmentService'
import { NextResponse } from 'next/server'
import Logger from '@/libs/logger'
import UserSessionService from '@/services/AuthService/UserSessionService'

export async function GET(request: NextRequest) {
    try {

        await UserSessionService.authenticateUserByRequest(request, "ADMIN");

        const { searchParams } = new URL(request.url);
        // Extract query parameters
        const page = parseInt(searchParams.get('page') || '1', 10);
        const pageSize = parseInt(searchParams.get('pageSize') || '10', 10);
        const date = searchParams.get('date') || undefined;
        const status = searchParams.get('status') || undefined;
        const appointmentId = searchParams.get('appointmentId') || undefined;
        const email = searchParams.get('email') || undefined;

        const result = await AppointmentService.getAllAppointments({
            page,
            pageSize,
            status,
            date,
            appointmentId,
            email
        });

        return NextResponse.json({ posts: result.posts, total: result.total , page, pageSize });

    }
    catch (error: any) {
        console.error(error.message);
        return NextResponse.json(
            { message: error.message },
            { status: 500 }
        );
    }
}


=== ./app/(auth)/layout.tsx ===
'use client';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome'
import Link from 'next/link';
import { ToastContainer } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';
import { usePathname } from 'next/navigation';
import { faCode } from '@fortawesome/free-solid-svg-icons';
import { Suspense } from 'react';
import SSOLogin from '@/components/auth/SSOLogin';


export default function AuthLayout({ children, title }: { children: React.ReactNode, title: string }) {

  //Create a context to store the user's authentication status

  const pathname = usePathname();

  const titles = [
    {
      path: '/auth/login',
      title: 'Welcome back!'
    },
    {
      path: '/auth/register',
      title: 'Create an account'
    },
    {
      path: '/auth/forgot-password',
      title: 'Forgot Password'
    },
    {
      path: '/auth/reset-password',
      title: 'Reset Password'
    },
    {
      path: '/auth/logout',
      title: 'Logging out...'
    }
  ]

  return (
    <Suspense>
      <div className="flex flex-col items-center justify-center min-h-screen bg-base-200">
        <div className="rounded-lg shadow-md w-full max-w-4xl grid grid-cols-1 md:grid-cols-2 min-h-screen md:min-h-[600px] rounded-lg shadow-md bg-base-100 border border-base-300">
          <div className="col-span-1 hidden md:block rounded-l-lg">
            <div className="flex flex-col items-center justify-center  rounded-l-lg" style={{
              backgroundImage: 'url(/assets/img/kuraykaraaslan.jpg)',

              backgroundSize: 'cover', backgroundPosition: 'center', height: '100%'
            }}>
            </div>
          </div>
          <div className="col-span-1 flex flex-col items-center justify-center w-full p-8 pt-0">
            <div className="flex items-center justify-center mb-3">
              <Link href="/" className="flex items-center justify-center space-x-2 font-bold text-4xl">
                <FontAwesomeIcon icon={faCode} className="w-8 h-8" />
                <span className='text-xl'>kuray.dev</span>
              </Link>
            </div>
            <h1 className="text-2xl font-bold text-center mb-4">{titles?.find((item) => pathname?.startsWith(item.path))?.title}</h1>
            <div className="w-full">
              {children}
              <div className="flex items-center justify-center mt-4 mb-4">
                <span className="text-sm font-semibold">Or</span>
              </div>
              <SSOLogin mode="pins" />
            </div>
          </div>
        </div>
      </div>
      <ToastContainer />
    </Suspense>
  )
}


=== ./app/(auth)/auth/logout/page.tsx ===
'use client';
import axiosInstance from '@/libs/axios';
import React, { useEffect } from 'react';
import { toast } from 'react-toastify';
import { useGlobalStore } from '@/libs/zustand';
import { useRouter } from 'next/navigation';


const LogoutPage = () => {

    const { setUser } = useGlobalStore();
    const router = useRouter();

    const handleLogout = async () => {
        await axiosInstance.post(`/api/auth/logout`).then(res => {
            if (res.status === 200) {
                toast.success(res.data.message);
            }
        }
        ).catch(err => {
            toast.error(err.response.data.message);
        }).finally(() => {
            setUser(null);
            localStorage.removeItem('user');
            localStorage.removeItem('accessToken');
            localStorage.removeItem('refreshToken');
            localStorage.removeItem('userSession');
            router.push('/');
        });
    }

    useEffect(() => {
        handleLogout();
    }, []);

    return (
        <>

        </>
    )
}

export default LogoutPage;

=== ./app/(auth)/auth/register/page.tsx ===
'use client';
import axiosInstance from '@/libs/axios';
import { faQuestion } from '@fortawesome/free-solid-svg-icons';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import Link from 'next/link';
import React, { useState } from 'react';
import { toast } from 'react-toastify';


const RegisterPage = () => {    
    
    const emailRegex = /\S+@\S+\.\S+/;
    const passwordRegex = /^.{6,}$/;

    const [email, setEmail] = useState<string>("");
    const [password, setPassword] = useState<string>("");
    const [confirmpassword, setConfirmpassword] = useState<string>("");



    const handleSubmit = async (e: React.MouseEvent<HTMLButtonElement>) => {
        e.preventDefault();
        
        if (!email) {
            return;
        }

        if (!password) {
            return;
        }

        if (!confirmpassword) {
            toast.error("Please confirm your password.");
        }

        if (typeof email !== "string") {
            return;
        }

        if (typeof password !== "string") {
            return;
        }

        if (typeof confirmpassword !== "string") {
            return;
        }

        if (!emailRegex.test(email)) {
            toast.error("Invalid email address.");
            return;
        }

        if (!passwordRegex.test(password)) {
            toast.error("Password must contain at least 6 characters.");
            return;
        }

        if (password !== confirmpassword) {
            toast.error("Passwords do not match.");
            return;
        }

        toast.success("Registering...");

        const res = await axiosInstance.post(`/api/auth/register`, {
            email: email,
            password: password
        }).then((res) => {
            if (res.data.error) {
                toast.error(res.data.error);
            } else {
                toast.success(res.data.message);
            }
        }
        ).catch((err) => {
            toast.error(err.response.data.error);
        });

        
    }

    return (
        <>
            <div className="space-y-3">
                <div>
                    <Link href="/auth/login"
                        type="button"
                        className="block w-full py-2.5 bg-primary font-semibold rounded-lg shadow-md text-white"
                    >
                        <span className="flex items-center justify-center">
                           Login
                        </span>
                    </Link>
                </div>
                <div className="flex items-center justify-center">
                    <span className="text-sm font-semibold">Or</span>
                </div>
                <div>
                    <div className="">
                        <input
                            id="email"
                            name="email"
                            type="email"
                            required
                            autoComplete="email"
                            value={email as string}
                            onChange={(e) => setEmail(e.target.value)}
                            pattern='[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,4}$'
                            placeholder="Email address"
                            className={"block w-full rounded-lg border-0 py-1.5 shadow-sm ring-1 ring-inset placeholder:text-primary sm:text-sm sm:leading-6 h-12"}
                        />
                    </div>
                </div>
                <div>
                    <div className="flex items-center justify-between">
                    </div>
                    <div className="relative">
                        <Link className="absolute inset-y-0 right-2 pl-3 flex items-center pointer-events-none" href="/auth/forgot-password">
                            <FontAwesomeIcon icon={faQuestion} className="h-5 w-5 text-primary" aria-hidden="true" />
                        </Link>
                        <input
                            id="password"
                            name="password"
                            type="password"
                            required
                            value={password as string}
                            onChange={(e) => setPassword(e.target.value)}
                            autoComplete="current-password"
                            placeholder="Password"
                            className={"block w-full rounded-lg border-0 py-1.5 shadow-sm ring-1 ring-inset placeholder:text-primary sm:text-sm sm:leading-6 h-12"}
                        />
                    </div>
                </div>
                 
                <div>
                    <div className="flex items-center justify-between">
                    </div>
                    <div className="relative">
                        <input
                            id="password"
                            name="confirmpassword"
                            type="password"
                            required
                            value={confirmpassword as string}
                            onChange={(e) => setConfirmpassword(e.target.value)}
                            autoComplete="current-password"
                            placeholder="Confirm Password"
                            className={"block w-full rounded-lg border-0 py-1.5 shadow-sm ring-1 ring-inset placeholder:text-primary sm:text-sm sm:leading-6 h-12"}
                        />
                    </div>
                </div>

                <div>
                    <button
                        type="submit"
                        onClick={handleSubmit}
                        className="block w-full py-2.5 bg-primary font-semibold rounded-lg shadow-md text-white"
                    >
                        Create Account
                    </button>
                </div>

            
            </div>
        </>
    );
};

RegisterPage.layout = "auth";

export default RegisterPage;

=== ./app/(auth)/auth/forgot-password/page.tsx ===
'use client';
import React, { useEffect, useState } from 'react';
import axiosInstance from '@/libs/axios';
import { toast } from 'react-toastify';
import { useSearchParams } from 'next/navigation';

const ForgotPasswordPage = () => {

    const searchParams = useSearchParams();

    const emailRegex = /\S+@\S+\.\S+/;

    const [email, setEmail] = useState('');
    const [resetToken, setResetToken] = useState('');
    const [password, setPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');

    useEffect(() => {
        //resetToken and email are passed as query params
        const resetToken = searchParams.get('resetToken');
        const email = searchParams.get('email');

        if (!resetToken || !email) {
            return;
        }

        setResetToken(resetToken);
        setEmail(email);

        //set step to 2 if resetToken is present
        setStep(2);
    }, [searchParams]);



    const [step, setStep] = useState(1);

    async function handleSubmit(e: React.MouseEvent<HTMLButtonElement>) {
        e.preventDefault();

        if (step === 1) {

            if (!email || emailRegex.test(email) === false) {
                toast.error('Email is required.');
                return;
            }


            await axiosInstance.post(`/api/auth/forgot-password`, {
                email: email,
            }).then(async (res) => {
                if (res.data.error) {
                    console.error(res.data.error);
                    return;
                }
                toast.success('Verification code sent to your email.');
                setStep(2);
            }).catch((error) => {
                toast.error(error.response.data.error);
            });

            setStep(2);
        } else {
            // Reset password
            if (password !== confirmPassword) {
                console.error('Passwords do not match');
                return;
            }

            await axiosInstance.post(`/api/auth/reset-password`, {
                email: email,
                resetToken: resetToken,
                password: password,
            }).then(async (res) => {
                if (res.data.error) {
                    console.error(res.data.error);
                    return;
                }
                toast.success('Password reset successfully.');
            }).catch((error) => {
                toast.error(error.response.data.error);
            });
            console.log('Resetting password for token:', resetToken);
        }
    };


    return (
        <>
            {step === 1 ? (
                <>
                    <div className="space-y-6">
                        <div>
                            <label htmlFor="email" className="block text-sm font-medium leading-6">
                                Email address
                            </label>
                            <div className="mt-2">
                                <input
                                    id="email"
                                    name="email"
                                    type="email"
                                    value={email}
                                    onChange={(e) => setEmail(e.target.value)}
                                    required
                                    autoComplete="email"
                                    className="block w-full rounded-md border-0 py-1.5 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-primary focus:ring-2 focus:ring-inset focus:ring-primary sm:text-sm sm:leading-6"
                                />
                            </div>
                        </div>

                        <div>
                            <button
                                type="submit"
                                className="block w-full py-2.5 bg-primary font-semibold rounded-lg shadow-md text-white"
                                onClick={handleSubmit}
                            >
                                Send Verification Code
                            </button>
                        </div>
                    </div>
                </>
            ) : (
                <div className="space-y-6">
                    <div>
                        <label htmlFor="verificationCode" className="block text-sm font-medium leading-6">
                            Verification Code
                        </label>
                        <div className="mt-2">
                            <input
                                id="verificationCode"
                                name="verificationCode"
                                value={resetToken}
                                onChange={(e) => setResetToken(e.target.value)}
                                type="text"
                                required
                                autoComplete="verificationCode"
                                className="block w-full rounded-md border-0 py-1.5 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-primary focus:ring-2 focus:ring-inset focus:ring-primary sm:text-sm sm:leading-6"
                            />
                        </div>
                    </div>

                    <div>
                        <label htmlFor="password" className="block text-sm font-medium leading-6">
                            New Password
                        </label>
                        <div className="mt-2">
                            <input
                                id="password"
                                name="password"
                                type="password"
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                required
                                autoComplete="new-password"
                                className="block w-full rounded-md border-0 py-1.5 shadow-sm ring-1 ring-inset ring-gray-300 focus:ring-2 focus:ring-inset focus:ring-primary sm:text-sm sm:leading-6"
                            />
                        </div>
                    </div>

                    <div>
                        <label htmlFor="password" className="block text-sm font-medium leading-6">
                            Confirm Password
                        </label>
                        <div className="mt-2">
                            <input
                                id="password"
                                name="password"
                                type="password"
                                value={confirmPassword}
                                onChange={(e) => setConfirmPassword(e.target.value)}
                                required
                                autoComplete="current-password"
                                className="block w-full rounded-md border-0 py-1.5 shadow-sm ring-1 ring-inset ring-gray-300 focus:ring-2 focus:ring-inset focus:ring-primary sm:text-sm sm:leading-6"
                            />
                        </div>
                    </div>

                    <div>
                        <button
                            type="submit"
                            className="block w-full py-2.5 bg-primary font-semibold rounded-lg shadow-md text-white"
                            onClick={handleSubmit}
                        >
                            Reset Password
                        </button>
                    </div>
                </div>

            )}

        </>
    );
};


export default ForgotPasswordPage;

=== ./app/(auth)/auth/callback/page.tsx ===
'use client';
import axiosInstance from '@/libs/axios';
import React, { useEffect } from 'react';
import { toast } from 'react-toastify';
import { useGlobalStore } from '@/libs/zustand';
import { useRouter } from 'next/navigation';
import { useSearchParams } from 'next/navigation';


export default function CallbackPage() {
    const searchParams = useSearchParams();

    const accessToken = searchParams.get('accessToken');
    const refreshToken = searchParams.get('refreshToken');

    const router = useRouter();
    const { setUser } = useGlobalStore();

    useEffect(() => {
        
        const fetchSession = async () => {

            await axiosInstance.get('/api/auth/session').then(res => {
                if (res.status === 200) {
                    setUser(res.data.user);
                    toast.success('Logged in successfully.');
                } else {
                    toast.error(res.data.error);
                }
            }).catch(err => {
                toast.error(err.response.data.error);
            }
            ).finally(() => {
                router.push('/');
            });
        }

        fetchSession();

    }, [accessToken, refreshToken]);


    return (
        <div>
            <h1>we are logging you in...</h1>
        </div>
    );
}



=== ./app/(auth)/auth/login/page.tsx ===
'use client';
import axiosInstance from '@/libs/axios';
import { faQuestion } from '@fortawesome/free-solid-svg-icons';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import Link from 'next/link';
import React, { useState } from 'react';
import { toast } from 'react-toastify';
import { useGlobalStore } from '@/libs/zustand';
import { useRouter } from 'next/navigation';

const LoginPage = () => {

    const emailRegex = /\S+@\S+\.\S+/;
    const passwordRegex = /^.{6,}$/;

    const [email, setEmail] = useState<String>("");
    const [password, setPassword] = useState<String>("");

    const { setUser } = useGlobalStore();

    const router = useRouter();


    const handleSubmit = async (e: React.MouseEvent<HTMLButtonElement>) => {
        e.preventDefault();

        if (!email) {
            return;
        }

        if (!password) {
            return;
        }

        if (typeof email !== "string") {
            toast.error("Invalid email address.");
            return;
        }

        if (typeof password !== "string") {
            toast.error("Password must contain at least 6 characters.");
            return;
        }

        if (!emailRegex.test(email)) {
            toast.error("Invalid email address.");
            return;
        }

        if (!passwordRegex.test(password)) {
            toast.error("Password must contain at least 8 characters, one uppercase, one lowercase, one number.");
            return;
        }

        await axiosInstance.post(`/api/auth/login`, {
            email: email,
            password: password
        }).then(async (res) => {
            if (res.data.error) {
                toast.error(res.data.error);
            } else {
                toast.success(res.data.message);
            }

            const { user } = res.data;
            setUser(user);

            router.push("/");
        }
        ).catch((err) => {
            console.error(err);
            toast.error(err.response.data.error);
        });



    }

    return (
        <>
            <div className="space-y-6">
                <div>
                    <Link href="/auth/register"
                        type="button"
                        className="block w-full py-2.5 bg-primary font-semibold rounded-lg shadow-md text-white"
                    >
                        <span className="flex items-center justify-center">
                            Create an account
                        </span>
                    </Link>
                </div>
                <div className="flex items-center justify-center">
                    <span className="text-sm font-semibold">Or</span>
                </div>
                <div>
                    <div className="mt-2">
                        <input
                            id="email"
                            name="email"
                            type="email"
                            required
                            autoComplete="email"
                            value={email as string}
                            onChange={(e) => setEmail(e.target.value)}
                            pattern='[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,4}$'
                            placeholder="Email address"
                            className={"block w-full rounded-lg border-0 py-1.5 shadow-sm ring-1 ring-inset placeholder:text-primary sm:text-sm sm:leading-6 h-12"}
                        />
                    </div>
                </div>

                <div>
                    <div className="flex items-center justify-between">
                    </div>
                    <div className="relative mt-2">
                        <Link className="absolute inset-y-0 right-2 pl-3 flex items-center" href="/auth/forgot-password">
                            <button
                                type="button"
                                className="text-primary hover:text-primary focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary rounded-md text-sm font-medium"
                            >
                                <FontAwesomeIcon icon={faQuestion} />
                            </button>
                        </Link>
                        <input
                            id="password"
                            name="password"
                            type="password"
                            required
                            value={password as string}
                            onChange={(e) => setPassword(e.target.value)}
                            autoComplete="current-password"
                            placeholder="Password"
                            className={"block w-full rounded-lg border-0 py-1.5 shadow-sm ring-1 ring-inset placeholder:text-primary sm:text-sm sm:leading-6 h-12"}
                        />
                    </div>
                </div>
                <div>
                    <button
                        type="submit"
                        onClick={handleSubmit}
                        disabled={!email || !password}
                        className="block w-full py-2.5 bg-primary font-semibold rounded-lg shadow-md text-white"
                    >
                        Sign in
                    </button>
                </div>

            </div>
        </>
    );
};

LoginPage.layout = "auth";

export default LoginPage;

=== ./app/(admin)/layout.tsx ===
'use client'
import React, { Suspense } from "react";
import "react-toastify/dist/ReactToastify.css";

const Layout = ({
    children,
}: {
    children: React.ReactNode;
}) => {

    return (
        <Suspense>
            {children}
        </Suspense>
    );
}

export default Layout;

=== ./app/(admin)/admin/layout.tsx ===
'use client'
import React, { useEffect, useState } from "react";
import { ToastContainer } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
import useGlobalStore from "@/libs/zustand";
import { useRouter } from "next/navigation";
import dynamic from "next/dynamic";

// Make sure to import the Navbar component from the correct path
const Navbar = dynamic(() => import('@/components/admin/Navbar'), { ssr: false });

const Layout = ({
    children,
}: {
    children: React.ReactNode;
}) => {





    return (
        <>
            <Navbar />
            <div style={{ flex: 1 }} className="container mx-auto px-4 pt-4 md:pt-12 lg:px-8 max-w-8xl mb-8 mt- flex flex-col md:flex-row gap-4">
                {/* [children] */}
                {children}
            </div>
            <ToastContainer />
        </>
    );
}

export default Layout;

=== ./app/(admin)/admin/posts/page.tsx ===
'use client'
import React from 'react';
import PostTable from '@/components/admin/Tables/PostTable';

const Page = () => {

    return (
        <>
            <PostTable/>
        </>
    );
}

export default Page;


=== ./app/(admin)/admin/posts/[postId]/page.tsx ===
'use client';
import React, { useEffect, useMemo, useState } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import axiosInstance from '@/libs/axios';
import { Editor } from '@tinymce/tinymce-react';
import { toast } from 'react-toastify';
import CategorySelect from '@/components/admin/Selects/CategorySelect';
import UserSelect from '@/components/admin/Selects/UserSelect';
import ImageLoad from '@/components/common/ImageLoad';
import AIPrompt from '@/components/admin/AIPrompt';

type PostStatus = 'DRAFT' | 'PUBLISHED' | 'ARCHIVED';

const SinglePost: React.FC = () => {
  // Route param (tek kaynak)
  const params = useParams<{ postId: string }>();
  const routePostId = params?.postId;
  const router = useRouter();

  // Mode, paramdan türetiliyor (state değil)
  const mode: 'create' | 'edit' = useMemo(
    () => (routePostId === 'create' ? 'create' : 'edit'),
    [routePostId]
  );

  const [loading, setLoading] = useState(true);

  // Model fields
  const [title, setTitle] = useState('');
  const [image, setImage] = useState('');
  const [content, setContent] = useState('');
  const [description, setDescription] = useState('');
  const [slug, setSlug] = useState('');
  const [keywords, setKeywords] = useState<string[]>([]);
  const [authorId, setAuthorId] = useState<string>('');
  const [categoryId, setCategoryId] = useState<string>('');
  const [status, setStatus] = useState<PostStatus>('DRAFT');
  const [createdAt, setCreatedAt] = useState<Date>(new Date());
  const [views, setViews] = useState<number>(0);

  // Slug üretimi (sadece create modda ve loading bittiyse)
  useEffect(() => {
    if (mode === 'edit' || loading) return;
    if (!title) return;

    const invalidChars = /[^\w\s-]/g;
    let slugifiedTitle = title.replace(invalidChars, '');
    slugifiedTitle = slugifiedTitle.replace(/\s+/g, '-');
    slugifiedTitle = slugifiedTitle.replace(/--+/g, '-');
    slugifiedTitle = slugifiedTitle.toLowerCase();

    const month = createdAt.getMonth() + 1;
    const year = createdAt.getFullYear();
    const monthString = month < 10 ? `0${month}` : String(month);

    setSlug(`${slugifiedTitle}-${monthString}${year}`);
  }, [title, mode, loading, createdAt]);

  // Postu yükle (edit modda)
  useEffect(() => {
    let cancelled = false;

    const load = async () => {
      // Param yoksa
      if (!routePostId) {
        setLoading(false);
        return;
      }
      // Create mod
      if (routePostId === 'create') {
        setLoading(false);
        return;
      }

      try {
        const res = await axiosInstance.get('/api/posts', {
          params: { postId: routePostId, status: 'ALL' },
        });

        const posts = res.data?.posts ?? [];
        const post = posts.find((p: any) => p.postId === routePostId);
        if (!post) {
          toast.error('Post not found');
          return;
        }
        if (cancelled) return;

        setTitle(post.title ?? '');
        setImage(post.image ?? '');
        setContent(post.content ?? '');
        setDescription(post.description ?? '');
        setSlug(post.slug ?? '');
        setKeywords(Array.isArray(post.keywords) ? post.keywords : []);
        setAuthorId(post.authorId ?? '');
        setCategoryId(post.categoryId ?? '');
        setStatus((post.status as PostStatus) ?? 'DRAFT');
        setCreatedAt(post.createdAt ? new Date(post.createdAt) : new Date());
        setViews(typeof post.views === 'number' ? post.views : 0);
      } catch (error: any) {
        console.error(error);
        toast.error(error?.response?.data?.message ?? 'Failed to load post');
      } finally {
        if (!cancelled) setLoading(false);
      }
    };

    load();
    return () => {
      cancelled = true;
    };
  }, [routePostId]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    // Güvenli zorunlu alan kontrolü (eval YOK)
    const errors: string[] = [];
    const required: Record<string, unknown> = {
      title,
      content,
      description,
      slug,
      authorId,
      categoryId,
    };

    for (const [key, val] of Object.entries(required)) {
      if (typeof val === 'string' && val.trim() === '') {
        errors.push(`${key} is required`);
      }
      if (Array.isArray(val) && val.length === 0) {
        errors.push(`${key} is required`);
      }
    }

    if (errors.length) {
      errors.forEach((msg) => toast.error(msg));
      return;
    }

    const body = {
      postId: routePostId !== 'create' ? routePostId : undefined,
      title,
      content,
      description,
      slug,
      keywords,
      authorId,
      categoryId,
      status,
      createdAt,
      views,
      image,
    };

    try {
      if (mode === 'create') {
        await axiosInstance.post('/api/posts', body);
        toast.success('Post created successfully');
      } else {
        await axiosInstance.put('/api/posts', body); // trailing slash kaldırıldı
        toast.success('Post updated successfully');
      }
      router.push('/admin/posts');
    } catch (error: any) {
      toast.error(error?.response?.data?.message ?? 'Save failed');
    }
  };

  return (
    <>
      <div className="container mx-auto">
        <div className="flex justify-between items-center flex-row">
          <h1 className="text-3xl font-bold h-16 items-center">
            {mode === 'create' ? 'Create Post' : 'Edit Post'}
          </h1>
          <div className="flex gap-2 h-16">
            <AIPrompt
              setTitle={setTitle}
              setContent={setContent}
              setDescription={setDescription}
              setKeywords={setKeywords}
              setSlug={setSlug}
              setCreatedAt={setCreatedAt}
              toast={toast}
            />
            <Link className="btn btn-primary btn-sm h-12" href="/admin/posts">
              Back to Posts
            </Link>
          </div>
        </div>

        <form className="bg-base-200 p-6 rounded-lg shadow-md" onSubmit={handleSubmit}>
          <div className="form-control">
            <label className="label">
              <span className="label-text">Title</span>
            </label>
            <input
              type="text"
              placeholder="Title"
              className="input input-bordered"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
            />
          </div>

          <div className="form-control">
            <label className="label">
              <span className="label-text">Status</span>
            </label>
            <select
              className="select select-bordered"
              value={status}
              onChange={(e) => setStatus(e.target.value as PostStatus)}
            >
              <option value="DRAFT">Draft</option>
              <option value="PUBLISHED">Published</option>
              <option value="ARCHIVED">Archived</option>
            </select>
          </div>

          <div className="form-control">
            <label className="label">
              <span className="label-text">Category</span>
            </label>
            <CategorySelect
              setSelectedCategoryId={setCategoryId}
              selectedCategoryId={categoryId}
            />
          </div>

          <div className="form-control">
            <label className="label">
              <span className="label-text">Created At</span>
            </label>
            <input
              type="date"
              placeholder="Created At"
              className="input input-bordered"
              value={isNaN(createdAt.getTime()) ? '' : createdAt.toISOString().split('T')[0]}
              onChange={(e) => setCreatedAt(new Date(e.target.value))}
            />
          </div>

          <div className="form-control">
            <label className="label">
              <span className="label-text">Views</span>
            </label>
            <input
              type="number"
              placeholder="Views"
              className="input input-bordered"
              value={views}
              onChange={(e) => setViews(Number(e.target.value))}
            />
          </div>

          <div className="form-control">
            <label className="label">
              <span className="label-text">Content</span>
            </label>
            <Editor
              init={{
                height: 500,
                menubar: false,
                plugins: [
                  'advlist autolink lists link image charmap print preview anchor',
                  'searchreplace visualblocks code fullscreen',
                  'insertdatetime media table paste code help wordcount',
                ],
                toolbar:
                  'undo redo | formatselect | bold italic backcolor | ' +
                  'alignleft aligncenter alignright alignjustify | ' +
                  'bullist numlist outdent indent | removeformat | help',
              }}
              apiKey={process.env.NEXT_PUBLIC_TINYMCE_API_KEY}
              value={content}
              onEditorChange={(val) => setContent(val)}
            />
          </div>

          <div className="form-control">
            <label className="label">
              <span className="label-text">Description</span>
            </label>
            <textarea
              placeholder="Description"
              className="textarea textarea-bordered"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
            />
          </div>

          <div className="form-control">
            <label className="label">
              <span className="label-text">Slug</span>
            </label>
            <input
              type="text"
              placeholder="Slug"
              className="input input-bordered"
              value={slug}
              onChange={(e) => setSlug(e.target.value)}
            />
          </div>

          <div className="form-control">
            <label className="label">
              <span className="label-text">Keywords</span>
            </label>
            <input
              type="text"
              placeholder="Keywords (comma separated)"
              className="input input-bordered"
              value={keywords.join(',')}
              onChange={(e) =>
                setKeywords(
                  e.target.value
                    .split(',')
                    .map((s) => s.trim())
                    .filter((s) => s.length > 0)
                )
              }
            />
          </div>

          <div className="form-control">
            <label className="label">
              <span className="label-text">Author</span>
            </label>
            {/* key ekleyerek param değişiminde remount sağlıyoruz */}
            <UserSelect
              key={routePostId}
              setSelectedUserId={setAuthorId}
              selectedUserId={authorId}
            />
          </div>

          <div className="form-control mb-4 mt-4">
            <label className="label">
              <span className="label-text">Image</span>
            </label>
            <ImageLoad
              image={image}
              setImage={setImage}
              uploadFolder="projects"
              toast={toast}
            />
          </div>

          <button type="submit" className="btn btn-primary block w-full mt-4" disabled={loading}>
            {loading ? 'Loading...' : mode === 'create' ? 'Create Post' : 'Update Post'}
          </button>
        </form>
      </div>
    </>
  );
};

export default SinglePost;


=== ./app/(admin)/admin/page.tsx ===
import React from "react";
import StatsSection from "@/components/admin/StatsSection";


const Page = () => {
    return (
        <div className="container mx-auto items-center justify-center">
            <StatsSection />
        </div>
    );
}

export default Page;


=== ./app/(admin)/admin/projects/page.tsx ===
import React from 'react';
import ProjectTable from '@/components/admin/Tables/ProjectTable';

const Page = () => {

    return (
        <>
            <ProjectTable />
        </>
    );
}

export default Page;


=== ./app/(admin)/admin/projects/[projectId]/page.tsx ===
'use client';
import React, { useState, useEffect, } from 'react';
import { useRouter, useParams } from 'next/navigation';
import Link from 'next/link';
import axiosInstance from '@/libs/axios';
import { toast } from 'react-toastify';
import ImageLoad from '@/components/common/ImageLoad';
import TinyMCEEditor from '@/components/admin/Editor';

import ProjectLinkTable from '@/components/admin/Tables/ProjectLinkTable';


const SingleProject = () => {

    const params = useParams();
    

    const mandatoryFields = ['title', 'content', 'description', 'slug', 'platforms'];
    const router = useRouter();
    const [mode, setMode] = useState(params.projectId === 'create' ? 'create' : 'edit');
    const [loading, setLoading] = useState(true);


    // Model fields
    const [title, setTitle] = useState('');
    const [image, setImage] = useState('');
    const [content, setContent] = useState('');
    const [description, setDescription] = useState('');
    const [slug, setSlug] = useState('');
    const [platforms, setPlatforms] = useState<string[]>([]);
    const [technologies, setTechnologies] = useState<string[]>([]);
    const [status, setStatus] = useState('PUBLISHED');
    const [projectLinks, setProjectLinks] = useState<string[]>([]);

    // Platform fields
    const allowedPlatforms = [
        'ui/ux',
        'web',
        'mobile',
        'desktop',
        'embedded',
        'other',
        'iot',
        'gaming',
        'machine learning',
    ];

    // Technologies fields
    const allowedTechnologies = [
        'react',
        'react native',
        'express',
        'next',
        'java',
        'python',
        'c',
        'c++',
        'c#',
        'aws',
        'azure',
        'gcp',
        'chrome extension',
        'other'
    ];


    useEffect(() => {
        //if we are in edit mode and never update slug again
        if (mode === 'edit' || loading) {
            return;
        }

        if (title) {
            // Remove all non-english characters
            const invalidChars = /[^\w\s-]/g;
            // Remove all non-english characters
            let slugifiedTitle = title.replace(invalidChars, '');
            // Replace all spaces with hyphens
            slugifiedTitle = slugifiedTitle.replace(/\s+/g, '-');
            // Remove all double hyphens
            slugifiedTitle = slugifiedTitle.replace(/--+/g, '-');
            // Convert to lowercase
            slugifiedTitle = slugifiedTitle.toLowerCase();

            setSlug(slugifiedTitle);
        }
    }, [title]);

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();

        var errors: string[] = [];

        mandatoryFields.forEach((fieldName) => {
            // integer or string
            const fieldValue = eval(fieldName);
            const fieldType = typeof fieldValue;

            switch (fieldType) {
                case 'string':
                    if (!fieldValue || fieldValue === '') {
                        toast.error(`${fieldName} is required`);
                        return;
                    }
                    break;
                case 'object':
                    if (!fieldValue.length || fieldValue.length === 0) {
                        toast.error(`${fieldName} is required`);
                        return;
                    }
                    break;
                default:
                    break;
            }
        });


        if (errors.length > 0) {
            errors.forEach((error) => {
                toast.error(error);
            });
            return;
        }


        const body = {
            projectId: params.projectId === 'create' ? undefined : params.projectId,
            title,
            content,
            description,
            slug,
            platforms,
            technologies,
            status,
            image,
            projectLinks
        };

        if (mode === 'create') {
            await axiosInstance.post('/api/projects', body).then((response) => {
                const { project } = response.data;
                toast.success('Project created successfully');
                router.push('/admin/projects/' + project.projectId);
            }).catch((error) => {
                toast.error(error.response.data.message);
            });
        } else {
            await axiosInstance.put('/api/projects/', body).then(() => {
                toast.success('Project updated successfully');
                router.push('/admin/projects');
            }).catch((error) => {
                toast.error(error.response.data.message);
            });
        }


    };

    useEffect(() => {
        if (params.projectId === 'create') {
            setMode('create');
            setLoading(false);
        } else {
            setMode('edit');

            axiosInstance.get(`/api/projects`, {
                params: {
                    projectId: params.projectId
                }
            }).then((res) => {
                const { projects } = res.data;
                const project = projects[0];
                setTitle(project.title);
                setContent(project.content);
                setDescription(project.description);
                setSlug(project.slug);
                setPlatforms(project.platforms);
                setTechnologies(project.technologies);
                setStatus(project.status);
                setImage(project.image);
                setProjectLinks(project.projectLinks);
            }).catch((error) => {
                console.error(error);
            });

            setLoading(false);
        }

    }, [params.projectId]);

    return (
        <>
            <div className="container mx-auto">
                <div className="flex justify-between items-center flex-row">
                    <h1 className="text-3xl font-bold h-16 items-center">{mode === 'create' ? 'Create Project' : title}</h1>
                    <div className="flex gap-2 h-16">
                        <Link className="btn btn-primary btn-sm h-12" href="/admin/projects">
                            Back to Projects
                        </Link>
                    </div>
                </div>

                <div className="bg-base-200 p-6 rounded-lg shadow-md mb-4">
                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Title</span>
                        </label>
                        <input
                            type="text"
                            placeholder="Title"
                            className="input input-bordered"
                            value={title}
                            onChange={(e) => setTitle(e.target.value)}
                        />
                    </div>

                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Status</span>
                        </label>
                        <select
                            className="select select-bordered"
                            value={status}
                            onChange={(e) => setStatus(e.target.value)}
                        >
                            <option value="DRAFT">Draft</option>
                            <option value="PUBLISHED">Published</option>
                            <option value="ARCHIVED">Archived</option>
                        </select>
                    </div>

                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Content</span>
                        </label>
                        <TinyMCEEditor
                            value={content}
                            onChange={setContent}
                        />
                    </div>

                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Description</span>
                        </label>
                        <textarea
                            placeholder="Description"
                            className="textarea textarea-bordered"
                            value={description}
                            onChange={(e) => setDescription(e.target.value)}
                        />
                    </div>

                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Slug</span>
                        </label>
                        <input
                            type="text"
                            placeholder="Slug"
                            className="input input-bordered"
                            value={slug}
                            onChange={(e) => setSlug(e.target.value)}
                        />
                    </div>

                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Platforms</span>
                        </label>
                        <div className="flex flex-wrap gap-2">

                            {allowedPlatforms.map((platform) => (
                                <div key={platform} className="bg-base-100 p-2 rounded-lg">
                                    <input
                                        type='checkbox'
                                        className='mr-2'
                                        value={platform}
                                        checked={platforms.includes(platform)}
                                        onChange={(e) => {
                                            if (e.target.checked) {
                                                setPlatforms([...platforms, platform]);
                                            } else {
                                                setPlatforms(platforms.filter(p => p !== platform));
                                            }
                                        }}
                                    />
                                    <span className='mt-2'>{platform}</span>
                                </div>
                            ))}

                        </div>
                    </div>
                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Technologies</span>
                        </label>
                        <div className="flex flex-wrap gap-2">
                            {allowedTechnologies.map((technology) => (
                                <div key={technology} className="bg-base-100 p-2 rounded-lg">
                                    <input
                                        type='checkbox'
                                        className='mr-2'
                                        value={technology}
                                        checked={technologies.includes(technology)}
                                        onChange={(e) => {
                                            if (e.target.checked) {
                                                setTechnologies([...technologies, technology]);
                                            } else {
                                                setTechnologies(technologies.filter(t => t !== technology));
                                            }
                                        }}
                                    />
                                    <span className='mt-2'>{technology}</span>
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="form-control mb-4 mt-4">
                        <label className="label">
                            <span className="label-text">Links</span>
                            <button className="btn btn-sm btn-primary" onClick={() => setProjectLinks([...projectLinks, ''])}>
                                Add Link
                            </button>
                        </label>
                        <ProjectLinkTable projectLinks={projectLinks} setProjectLinks={setProjectLinks} />
                    </div>

                    <div className="form-control mb-4 mt-4">
                        <label className="label">
                            <span className="label-text">Image</span>
                        </label>
                        <ImageLoad
                            image={image}
                            setImage={setImage}
                            uploadFolder='projects'
                            toast={toast}
                        />
                    </div>
                </div>
                <button type="submit" className="btn btn-primary block w-full mt-4" onClick={handleSubmit} disabled={loading}>
                    { loading ? 'Loading...' : mode === 'create' ? 'Create Project' : 'Update Project'}
                </button>
            </div>
        </>
    );
}

export default SingleProject;

=== ./app/(admin)/admin/comments/page.tsx ===
'use client'

import CommentTable from '@/components/admin/Tables/CommentTable';

const Page = () => {

    return (
        <>
            <CommentTable/>
        </>
    );
}

export default Page;


=== ./app/(admin)/admin/users/page.tsx ===
import UserTable from "@/components/admin/Tables/UserTable";

const Page = () => {


    return (
        <>
            <UserTable/>
        </>
    );


}

export default Page;


=== ./app/(admin)/admin/users/[userId]/page.tsx ===
'use client';
import React, { useState, useEffect } from 'react';
import { useRouter, useParams } from 'next/navigation';
import Link from 'next/link';
import axiosInstance from '@/libs/axios';
import { toast } from 'react-toastify';


const UpdateUser = () => {

    const params = useParams();


    const [name, setName] = useState('');
    const [email, setEmail] = useState('');
    const [role, setRole] = useState('USER');

    const [imageUrl, setImageUrl] = useState<String | null>(null);

    const router = useRouter();

    const uploadImage = async () => {
        const input = document.getElementById('file') as HTMLInputElement;
        const files = input.files;

        if (!files) {
            return;
        }

        const imageFile = files[0];

        const formData = new FormData();
        formData.append('file', imageFile);
        formData.append('folder', 'users');

        await axiosInstance.post('/api/aws', formData,
            {
                headers: {
                    'Content-Type': 'multipart/form-data'
                }
            }
        ).then((res) => {
            setImageUrl(res.data.url);
        }).catch((error) => {
            console.error(error);
        });
    }

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();

        if (name === '') {
            toast.error('Name is required');
            return;
        }

        if (email === '') {
            toast.error('Email is required');
            return;
        }


        if (role === '') {
            toast.error('Role is required');
            return;
        }

        await axiosInstance.put('/api/users/' + params.userId, {
            name,
            email,
            role,
            image: imageUrl,
        }).then(() => {
            toast.success('User updated successfully');
            router.push('/admin/users');
        }).catch((error) => {
            toast.error(error.response.data.message);
        });

    };

    const showModal = () => {
        if (!document) {
            return;
        }

        const modal = document.getElementById('my_modal_4');

        if (modal) {
            //@ts-ignore
            modal?.showModal();
        }

    }


    useEffect(() => {

        if (params.userId) {
            axiosInstance.get(`/api/users/${params.userId}`).then((res) => {
                const { user } = res.data;
                setName(user.name);
                setEmail(user.email);
                setRole(user.role);
                setImageUrl(user.image);
            }).catch((error) => {
                console.error(error);
            });
        }
    }, []);

    return (
        <>
            <div className="container mx-auto">
                <div className="flex justify-between items-center flex-row">
                    <h1 className="text-3xl font-bold h-16 items-center">Update User</h1>
                    <div className="flex gap-2 h-16">
                        <Link className="btn btn-primary btn-sm h-12" href="/admin/users">
                            Back to Users
                        </Link>
                    </div>
                </div>

                <form className="bg-base-200 p-6 rounded-lg shadow-md" onSubmit={handleSubmit}>
                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Name</span>
                        </label>
                        <input
                            type="text"
                            placeholder="Name"
                            className="input input-bordered"
                            value={name}
                            onChange={(e) => setName(e.target.value)}
                        />
                    </div>

                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Email</span>
                        </label>
                        <input
                            type="email"
                            placeholder="Email"
                            className="input input-bordered"
                            value={email}
                            onChange={(e) => setEmail(e.target.value)}
                        />
                    </div>

                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Role</span>
                        </label>
                        <select
                            className="select select-bordered"
                            value={role}
                            onChange={(e) => setRole(e.target.value)}
                        >
                            <option value="USER">User</option>
                            <option value="ADMIN">Admin</option>
                        </select>
                    </div>

                    <div className="form-control mb-4 mt-4">
                        <label className="label">
                            <span className="label-text">Image</span>
                        </label>
                        <img src={imageUrl ? imageUrl as string : '/assets/img/og.png'}

                            width={400} height={400}
                            alt="Image" className="h-96 w-96 object-cover rounded-lg" />
                        <div className="relative flex justify-between items-center">
                            <input
                                type="file"
                                id="file"
                                placeholder="Image URL"
                                className="input input-bordered mt-2 p-4 flex-1 h-16"
                                //only images
                                accept="image/*"
                            />
                            <div className="absolute right-2 top-2 text-black p-2 rounded-lg">
                                <button type="button" className="h-12 text-black p-2 rounded-lg bg-primary mr-2" onClick={uploadImage}>
                                    Upload Image
                                </button>
                            </div>
                        </div>
                    </div>

                    <button type="submit" className="btn btn-primary block w-full mt-4">Update User</button>
                </form>
            </div>
        </>
    );
}

export default UpdateUser;

=== ./app/(admin)/admin/users/create/page.tsx ===
'use client';
import React, { useState} from 'react';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import axiosInstance from '@/libs/axios';
import { Editor } from '@tinymce/tinymce-react';
import { toast } from 'react-toastify';
import Image from 'next/image';


const CreateUser = () => {

    const [name, setName] = useState('');
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [phone, setPhone] = useState('');
    const [role, setRole] = useState('USER');
    const [slug, setSlug] = useState('');
    const [image, setImage] = useState('');
    const [bio, setBio] = useState('');

    const [imageUrl, setImageUrl] = useState<String | null>(null);
    //image upLoad
    const [imageFile, setImageFile] = useState<File | null>(null);
    const router = useRouter();


    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();

        const neededFields = [name, email, password, phone, role, slug, image, bio];

        const user = {
            name,
            email,
            password,
            phone,
            role,
            slug,
            image,
            bio, 
        };

        if (name === '') {
            toast.error('Name is required');
            return;
        }


        if (email === '') {
            toast.error('Email is required');
            return;
        }

        if (password === '') {
            toast.error('Password is required');
            return;
        }

        if (phone === '') {
            toast.error('Phone is required');
            return;
        }


        if (role === '') {
            toast.error('Role is required');
            return;
        }

        if (slug === '') {
            toast.error('Slug is required');
            return;
        }


        await axiosInstance.post('/api/users', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: {
                name,
                email,
                password,
                phone,
                role,
                slug,
                image,
                bio,
            },

        }).then(() => {
            toast.success('User created successfully');
            // router.push('/admin/posts');
        }).catch((error) => {
            toast.error(error.response.data.message);
        });

    };


    const uploadImage = async () => {
        if (!imageFile) {
            return;
        }

        const formData = new FormData();
        formData.append('file', imageFile);
        formData.append('folder', 'categories');

        await axiosInstance.post('/api/aws', formData).then((res) => {
            setImageUrl(res.data.url);
        }).catch((error) => {
            console.error(error);
        });
    }

    return (
        <>
            <div className="container mx-auto">
                <div className="flex justify-between items-center flex-row">
                    <h1 className="text-3xl font-bold h-16 items-center">Create User</h1>
                    <div className="flex gap-2 h-16">
                        <Link className="btn btn-primary btn-sm h-12" href="/admin/users">
                            Back to Users
                        </Link>
                    </div>
                </div>

                <form className="bg-base-200 p-6 rounded-lg shadow-md" onSubmit={handleSubmit}>
                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Name</span>
                        </label>
                        <input
                            type="text"
                            placeholder="Name"
                            className="input input-bordered"
                            value={name}
                            onChange={(e) => setName(e.target.value)}
                        />
                    </div>

                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Email</span>
                        </label>
                        <input
                            type="email"
                            placeholder="Email"
                            className="input input-bordered"
                            value={email}
                            autoComplete="off"
                            onChange={(e) => setEmail(e.target.value)}
                        />
                    </div>

                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Password</span>
                        </label>
                        <input
                            type="password"
                            placeholder="Password"
                            className="input input-bordered"
                            value={password}
                            autoComplete="new-password"
                            onChange={(e) => setPassword(e.target.value)}
                        />
                    </div>

                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Phone</span>
                        </label>
                        <input
                            type="text"
                            placeholder="Phone"
                            className="input input-bordered"
                            value={phone}
                            onChange={(e) => setPhone(e.target.value)}
                        />
                    </div>

                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Role</span>
                        </label>
                        <select
                            className="select select-bordered"
                            value={role}
                            onChange={(e) => setRole(e.target.value)}
                        >
                            <option value="USER">User</option>
                            <option value="ADMIN">Admin</option>
                        </select>
                    </div>

                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Slug</span>
                        </label>
                        <input
                            type="text"
                            placeholder="Slug"
                            className="input input-bordered"
                            value={slug}
                            onChange={(e) => setSlug(e.target.value)}
                        />
                    </div>

                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Bio</span>
                        </label>
                        <Editor
                            init={{
                                height: 500,
                                menubar: false,
                                plugins: [
                                    'advlist autolink lists link image charmap print preview anchor image',
                                    'searchreplace visualblocks code fullscreen',
                                    'insertdatetime media table paste code help wordcount'
                                ],
                                toolbar:
                                    'undo redo | image | formatselect | bold italic backcolor | \
                                alignleft aligncenter alignright alignjustify | \
                                bullist numlist outdent indent | removeformat | help',
                            }}
                            apiKey={process.env.NEXT_PUBLIC_TINYMCE_API_KEY}
                            value={bio}
                            onEditorChange={(content) => setBio(content)}
                        />

                    </div>

                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Slug</span>
                        </label>
                        <input
                            type="text"
                            placeholder="Slug"
                            className="input input-bordered"
                            value={slug}
                            onChange={(e) => setSlug(e.target.value)}
                        />
                    </div>
                
                    <div className="form-control mb-4 mt-4">
                        <label className="label">
                            <span className="label-text">Image</span>
                        </label>
                        <Image src={imageUrl ? imageUrl as string : '/assets/img/og.png'}
                        
                        width={384} height={256}
                            alt="Image" className="h-64 w-96 object-cover rounded-lg" />
                        <div className="relative flex justify-between items-center">
                            <input
                                type="file"
                                placeholder="Image URL"
                                className="input input-bordered mt-2 p-4 flex-1 h-16"
                                //only images
                                accept="image/*"

                                onChange={(e) => {
                                    const file = e.target.files?.[0];
                                    if (file) {
                                        setImageFile(file);
                                        //setImageUrl(URL.createObjectURL(file));
                                    }
                                }}
                            />
                            <div className="absolute right-2 top-2 text-black p-2 rounded-lg">
                                <button type="button" className="h-12 text-black p-2 rounded-lg bg-primary mr-2" onClick={uploadImage}>
                                    Upload Image
                                </button>
                            </div>
                        </div>
                    </div>
                    <button type="submit" className="btn btn-primary block w-full mt-4">Create Post</button>
                </form>
            </div>
        </>
    );
}

export default CreateUser;

=== ./app/(admin)/admin/slots/page.tsx ===
'use client'
import React, { useState } from 'react'
import type { Day } from '@/types/CalendarTypes'

import SlotTemplateBuilder from '@/components/admin/SlotTemplateBuilder'
import SlotsEditor from '@/components/admin/SlotsEditor'

export default function SlotTemplatesPage() {
    const [selectedDay, setSelectedDay] = useState<Day>('monday')
    const [selectedDate, setSelectedDate] = useState<Date>(new Date())

    const TIME_INTERVALS = [15, 30, 45, 60]
    const DAYS: Day[] = [
        'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'
    ]

    return (
        <div className="container mx-auto px-4 py-6">
            <h1 className="text-3xl font-bold mb-6">Slot Templates & Calendar</h1>
            <div className="grid lg:grid-cols-2 gap-6">
                <SlotTemplateBuilder selectedDay={selectedDay} setSelectedDay={setSelectedDay} DAYS={DAYS} TIME_INTERVALS={TIME_INTERVALS} selectedDate={selectedDate} setSelectedDate={setSelectedDate} />
                <SlotsEditor selectedDay={selectedDay} setSelectedDay={setSelectedDay} selectedDate={selectedDate} setSelectedDate={setSelectedDate} />
            </div>
        </div>
    )
}


=== ./app/(admin)/admin/settings/page.tsx ===
'use client'
import React, { useState, useEffect, useCallback } from 'react';
import axiosInstance from "@/libs/axios";
import { Setting } from '@prisma/client';


const Page = () => {

    const [defaultSettings, setDefaultSettings] = useState<Pick<Setting, 'key' | 'value'>[]>([
        {
            key: 'ALLOW_REGISTRATION',
            value: 'true'
        }
    ]);

    const [settings, setSettings] = useState<Pick<Setting, 'key' | 'value'>[]>([]);

    useEffect(() => {
        fetchSettings();
    }, []);

    const fetchSettings = async () => {
        await axiosInstance.get('/api/settings').then((res) => {

            const incomingSettings = res.data.settings as Pick<Setting, 'key' | 'value'>[];

            //merge default settings with incoming settings
            const mergedSettings = defaultSettings.map(ds => {
                const existingSetting = incomingSettings.find(s => s.key === ds.key);
                return existingSetting ? existingSetting : ds;
            });


            //set settings
            setSettings(mergedSettings);

        }).catch((error) => {
            console.error(error);
        });
    }



    const updateSettings = async () => {
        await axiosInstance.post('/api/settings', { settings }).then((res) => {
            setSettings(res.data.settings);
        }).catch((error) => {
            console.error(error);
        });
    }






    return (
        <div className="container mx-auto">
            <div className="flex justify-between md:items-center flex-col md:flex-row">
                <h1 className="text-3xl font-bold h-16 md:items-center">Settings</h1>
                <div className="flex gap-2 h-16 w-full md:w-auto md:flex-none">
                    <button className="btn btn-primary btn-sm h-12" onClick={() => updateSettings()}>
                        Update Settings
                    </button>
                </div>
            </div>

            {settings.length === 0 ? (
                <div className="flex justify-center items-center h-[400px]">
                    <p>Loading...</p>
                </div>
            ) :
                <div className="overflow-x-auto w-full bg-base-200 mt-4 rounded-lg min-h-[400px] grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 p-4">
                    <div className="card bordered bg-base-100">
                        <div className="card-body">
                            <h2 className="card-title">General Settings</h2>
                            <div className="form-control flex flex-row items-center">
                                <label className="label">
                                    <span className="label-text">Allow Registration</span>
                                </label>
                                <input type="checkbox" className="toggle toggle-primary"
                                    onChange={(e) => {
                                        const value = e.target.checked ? 'true' : 'false';
                                        setSettings(settings.map(s => s.key === 'ALLOW_REGISTRATION' ? { ...s, value } : s));
                                    }}
                                    checked={settings.find(s => s.key === 'ALLOW_REGISTRATION')?.value === 'true'} />
                            </div>

                        </div>
                    </div>

                </div>
            }

        </div>
    );
}

export default Page;


=== ./app/(admin)/admin/categories/page.tsx ===
import CategoryTable from "@/components/admin/Tables/CategoryTable";

const Page = () => {

    return (
        <>
            <CategoryTable/>
        </>
    );
  
}

export default Page;


=== ./app/(admin)/admin/categories/create/page.tsx ===
'use client';
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import axiosInstance from '@/libs/axios';
import { toast } from 'react-toastify';


const CreateCategory = () => {

    const [title, setTitle] = useState('Default Title');
    const [description, setDescription] = useState('Default Description');
    const [slug, setSlug] = useState('default-slug');
    const [keywords, setKeywords] = useState<string[]>([]);

    const [imageUrl, setImageUrl] = useState<String | null>(null);

    const router = useRouter();

    const uploadImage = async () => {
        const input = document.getElementById('file') as HTMLInputElement;
        const files = input.files;

        if (!files) {
            return;
        }

        const imageFile = files[0];

        const formData = new FormData();
        formData.append('file', imageFile);
        formData.append('folder', 'categories');

        await axiosInstance.post('/api/aws', formData,
            {
                headers: {
                    'Content-Type': 'multipart/form-data'
                }
            }
        ).then((res) => {
            setImageUrl(res.data.url);
        }).catch((error) => {
            console.error(error);
        });
    }

    const uploadFromUrl = async (url: string) => {
        await axiosInstance.post('/api/aws/from-url', {
            url,
            folder : 'categories'
        }).then((res) => {
            setImageUrl(res.data.url);
            toast.success('Image uploaded successfully');
        }).catch((error) => {
            console.error(error);
        });
    }

    const generateImage = async () => {
        const response = await axiosInstance.post('/api/ai/dall-e', {
            prompt: 'create a category image for title ' + title + ' and description ' + description + ' and keywords ' + keywords.join(','),
        }).then((res) => {
            toast.success('Image generated successfully,');
            setImageUrl(res.data.url);
            return res;
        }).then((res) => {
            toast.success('Now uploading image to S3');
            uploadFromUrl(res.data.url);
        }).
        catch((error) => {
            console.error(error);
        });
    }


    useEffect(() => {
        setSlug(title.toLowerCase().replace(/ /g, '-'));
    }, [title]);


    useEffect(() => {

    }
        , [imageUrl]);

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();

        const neededFields = [title, description, slug, keywords];

        const blogCategory = {
            title,
            description,
            slug,
            keywords
        };

        if (title === '') {
            toast.error('Title is required');
            return;
        }

        if (description === '') {
            toast.error('Description is required');
            return;
        }

        if (slug === '') {
            toast.error('Slug is required');
            return;
        }

        if (keywords.length === 0) {
            toast.error('Keywords are required');
            return;
        }
        
        await axiosInstance.post('/api/categories', blogCategory).then(() => {
            toast.success('Category created successfully');
            router.push('/admin/categories');
        }).catch((error) => {
            console.error(error);
        });


    };

    const showModal = () => {
        if (!document) {
            return;
        }

        const modal = document.getElementById('my_modal_4');

        if (modal) {
            //@ts-ignore
            modal?.showModal();
        }

    }

    return (
        <>
            <div className="container mx-auto">
                <div className="flex justify-between items-center flex-row">
                    <h1 className="text-3xl font-bold h-16 items-center">Create Category</h1>
                    <div className="flex gap-2 h-16">
                        <Link className="btn btn-primary btn-sm h-12" href="/admin/categories">
                            Back to Categories
                        </Link>
                    </div>
                </div>

                <form className="bg-base-200 p-6 rounded-lg shadow-md" onSubmit={handleSubmit}>
                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Title</span>
                        </label>
                        <input
                            type="text"
                            placeholder="Title"
                            className="input input-bordered"
                            value={title}
                            onChange={(e) => setTitle(e.target.value)}
                        />
                    </div>
                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Description</span>
                        </label>
                        <textarea
                            placeholder="Description"
                            className="textarea textarea-bordered"
                            value={description}
                            onChange={(e) => setDescription(e.target.value)}
                        />
                    </div>
                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Slug</span>
                        </label>
                        <input
                            type="text"
                            placeholder="Slug"
                            className="input input-bordered"
                            value={slug}
                            onChange={(e) => setSlug(e.target.value)}
                        />
                    </div>
                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Keywords</span>
                        </label>
                        <input
                            type="text"
                            placeholder="Keywords"
                            className="input input-bordered"
                            value={keywords.join(',')}
                            onChange={(e) => setKeywords(e.target.value.split(','))}
                        />
                    </div>
                    <div className="form-control mb-4 mt-4">
                        <label className="label">
                            <span className="label-text">Image</span>
                        </label>
                        <img src={imageUrl ? imageUrl as string : '/assets/img/og.png'}
                        
                        width={384} height={256}
                            alt="Image" className="h-64 w-96 object-cover rounded-lg" />
                        <div className="relative flex justify-between items-center">
                            <input
                                type="file"
                                id="file"
                                placeholder="Image URL"
                                className="input input-bordered mt-2 p-4 flex-1 h-16"
                                //only images
                                accept="image/*"
                            />
                            <div className="absolute right-2 top-2 text-black p-2 rounded-lg">
                                <button type="button" className="h-12 text-black p-2 rounded-lg bg-primary mr-2" onClick={uploadImage}>
                                    Upload Image
                                </button>
                                <button type="button" className="h-12 text-black p-2 rounded-lg bg-secondary" onClick={generateImage}>
                                    Generate Image
                                </button>
                            </div>
                        </div>
                    </div>
                    <button type="submit" className="btn btn-primary block w-full mt-4">Create Post</button>
                </form>
            </div>
        </>
    );
}

export default CreateCategory;

=== ./app/(admin)/admin/categories/[categoryId]/posts/page.tsx ===
'use client';
import React from 'react';
import CategoryService from '@/services/CategoryService';
import PostTable from '@/components/admin/Tables/PostTable';
import { notFound } from 'next/navigation';
import { useParams } from 'next/navigation';

const Page = async () => {

    const params = useParams();

    const categoryId = params.categoryId;
    const category = await CategoryService.getCategoryById(categoryId as string);

    if (!category) {
        return notFound();
    }

    return (
        <>
            <PostTable category={category} />
        </>
    );
}

export default Page;


=== ./app/(admin)/admin/categories/[categoryId]/page.tsx ===
'use client';
import React, { useState, useEffect, use } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import axiosInstance from '@/libs/axios';
import { toast } from 'react-toastify';

const EditCategory = () => {

    const params = useParams();

    const [title, setTitle] = useState('');
    const [description, setDescription] = useState('');
    const [slug, setSlug] = useState('');
    const [keywords, setKeywords] = useState<string[]>([]);

    const [loading, setLoading] = useState(true);

    const [imageUrl, setImageUrl] = useState<String | null>(null);

    //image upload
    const [imageFile, setImageFile] = useState<File | null>(null);

    const router = useRouter();

    const uploadImage = async () => {
        if (!imageFile) {
            return;
        }

        const formData = new FormData();
        formData.append('file', imageFile);
        formData.append('folder', 'categories');

        await axiosInstance.post('/api/aws', formData,
            {
                headers: {
                    'Content-Type': 'multipart/form-data'
                }
            }
        ).then((res) => {
            setImageUrl(res.data.url);
        }).catch((error) => {
            console.error(error);
        });
    }

    const uploadFromUrl = async (url: string) => {
        await axiosInstance.post('/api/aws/from-url', {
            url,
            folder: 'categories'
        }
        ).then((res) => {
            setImageUrl(res.data.url);
            toast.success('Image uploaded successfully');
        }).catch((error) => {
            console.error(error);
        });
    }

    const generateImage = async () => {
        const response = await axiosInstance.post('/api/ai/dall-e', {
            prompt: 'create a category image for title ' + title + ' and description ' + description + ' and keywords ' + keywords.join(','),
        }).then((res) => {
            toast.success('Image generated successfully,');
            setImageUrl(res.data.url);
            return res;
        }).then((res) => {
            toast.success('Now uploading image to S3');
            uploadFromUrl(res.data.url);
        }).
            catch((error) => {
                console.error(error);
            });
    }

    useEffect(() => {
        const fetchCategory = async () => {
            await axiosInstance.get(`/api/categories/${params.categoryId}`).then((res) => {
                const { category } = res.data;
                setTitle(category.title);
                setDescription(category.description);
                setSlug(category.slug);
                setKeywords(category.keywords);
                setImageUrl(category.image);
                setLoading(false);
            }).catch((error) => {
                console.error(error);
            });
        }

        fetchCategory();
    }, []);

    useEffect(() => {

        return;

        if (!title) {
            return;
        }

        if (loading) {
            return;
        }


        const invalidChars = /[^\w\s-]/g;
        const slugifiedTitle = title.toLowerCase().replace(invalidChars, '').replace(/\s+/g, '-');
        setSlug(slugifiedTitle);    
    }, [title]);


    useEffect(() => {

    }
        , [imageUrl]);

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();

        const neededFields = [title, description, slug, keywords];

        const blogCategory = {
            title,
            description,
            slug,
            keywords: keywords,
            image: imageUrl,
        };

        if (title === '') {
            toast.error('Title is required');
            return;
        }

        if (description === '') {
            toast.error('Description is required');
            return;
        }

        if (slug === '') {
            toast.error('Slug is required');
            return;
        }

        await axiosInstance.put('/api/categories/' + params.categoryId, blogCategory).then(() => {
            toast.success('Category updated successfully');
            router.push('/admin/categories/' + params.categoryId);
        }).catch((error) => {
            console.error(error);
        });

    };

    const showModal = () => {
        if (!document) {
            return;
        }

        const modal = document.getElementById('my_modal_4');

        if (modal) {
            //@ts-ignore
            modal?.showModal();
        }

    }



    return (
        <>
            <div className="container mx-auto">
                <div className="flex justify-between items-center flex-row">
                    <h1 className="text-3xl font-bold h-16 items-center">Create Category</h1>
                    <div className="flex gap-2 h-16">
                        <Link className="btn btn-primary btn-sm h-12" href="/admin/categories">
                            Back to Categories
                        </Link>
                    </div>
                </div>

                <form className="bg-base-200 p-6 rounded-lg shadow-md" onSubmit={handleSubmit}>
                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Title</span>
                        </label>
                        <input
                            type="text"
                            placeholder="Title"
                            className="input input-bordered"
                            value={title}
                            onChange={(e) => setTitle(e.target.value)}
                        />
                    </div>
                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Description</span>
                        </label>
                        <textarea
                            placeholder="Description"
                            className="textarea textarea-bordered"
                            value={description}
                            onChange={(e) => setDescription(e.target.value)}
                        />
                    </div>
                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Slug</span>
                        </label>
                        <input
                            type="text"
                            placeholder="Slug"
                            className="input input-bordered"
                            value={slug}
                            onChange={(e) => setSlug(e.target.value)}
                        />
                    </div>
                    <div className="form-control">
                        <label className="label">
                            <span className="label-text">Keywords</span>
                        </label>
                        <input
                            type="text"
                            placeholder="Keywords"
                            className="input input-bordered"
                            value={keywords.join(',')}
                            onChange={(e) => setKeywords(e.target.value.split(','))}
                        />
                    </div>
                    <div className="form-control mb-4 mt-4">
                        <label className="label">
                            <span className="label-text">Image</span>
                        </label>
                        <img src={imageUrl ? imageUrl as string : '/assets/img/og.png'}
                        
                        width={384} height={256}
                            alt="Image" className="h-64 w-96 object-cover rounded-lg" />
                        <div className="relative flex justify-between items-center">
                            <input
                                type="file"
                                placeholder="Image URL"
                                className="input input-bordered mt-2 p-4 flex-1 h-16"
                                //only images
                                accept="image/*"

                                onChange={(e) => {
                                    const file = e.target.files?.[0];
                                    if (file) {
                                        setImageFile(file);
                                        //setImageUrl(URL.createObjectURL(file));
                                    }
                                }}
                            />
                            <div className="absolute right-2 top-2 text-black p-2 rounded-lg">
                                <button type="button" className="h-12 text-black p-2 rounded-lg bg-primary mr-2" onClick={uploadImage}>
                                    Upload Image
                                </button>
                                <button type="button" className="h-12 text-black p-2 rounded-lg bg-secondary" onClick={generateImage}>
                                    Generate Image
                                </button>
                            </div>
                        </div>
                    </div>
                    <button type="submit" className="btn btn-primary block w-full mt-4">Update Category</button>
                </form>
            </div>
        </>
    );
}

export default EditCategory;

=== ./app/(my-links)/layout.tsx ===
'use client';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome'
import Link from 'next/link';
import { ToastContainer } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';
import { usePathname } from 'next/navigation';
import { faCode } from '@fortawesome/free-solid-svg-icons';


export default function LinksLayout({ children, title }: { children: React.ReactNode, title: string }) {

  //Create a context to store the user's authentication status

  const pathname = usePathname();

  const titles = [
    {
      path: '/my-links',
      title: 'My Links'
    }
  ]

  return (
    <>
      <div className="flex flex-col items-center justify-center min-h-screen bg-base-200">
        <div className="rounded-lg shadow-md w-full max-w-4xl grid grid-cols-1 md:grid-cols-2 min-h-screen md:min-h-[600px] rounded-lg shadow-md bg-base-100 border border-base-300">
          <div className="col-span-1 hidden md:block rounded-l-lg">
            <div className="flex flex-col items-center justify-center  rounded-l-lg" style={{
              backgroundImage: 'url(/assets/img/kuraykaraaslan.jpg)',
      
              backgroundSize: 'cover', backgroundPosition: 'center', height: '100%'
            }}>
            </div>
          </div>
          <div className="col-span-1 flex flex-col items-center justify-center w-full p-8">
            <div className="flex items-center justify-center mb-3">
              <Link href="/" className="flex items-center justify-center space-x-2 font-bold text-4xl">
                <FontAwesomeIcon icon={faCode} className="w-8 h-8" />
                <span className='text-xl'>kuray.dev</span>
              </Link>
            </div>
            <h1 className="text-3xl font-bold text-center mb-4">Links</h1>
            <div className="w-full">
              {children}
            </div>
          </div>
        </div>
      </div>
      <ToastContainer />
    </>
  )
}


=== ./app/(my-links)/my-links/page.tsx ===
import { faGithub, faInstagram, faLinkedin, faTiktok, faTwitch, faXTwitter, faYoutube } from '@fortawesome/free-brands-svg-icons';
import { faSnowman } from '@fortawesome/free-solid-svg-icons';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import Link from 'next/link';
import React from 'react';

const links = [
  { href: '/', title: 'Blog' , icon: faSnowman, color: 'bg-primary', textColor: 'text-white'},
  { href: 'https://github.com/kuraykaraaslan', title: 'Github', icon: faGithub, color: 'bg-[#333]', textColor: 'text-white'},
  { href: 'https://linkedin.com/in/kuraykaraaslan', title: 'Linkedin', icon: faLinkedin, color: 'bg-[#0077b5]', textColor: 'text-white'},
  { href: 'https://www.youtube.com/channel/UC-EzbpSWTrO97CejgrUyQXQ', title: 'Youtube', icon: faYoutube, color: 'bg-[#FF0000]', textColor: 'text-white'},
  { href: 'https://www.instagram.com/kuraykaraaslan/', title: 'Instagram', icon: faInstagram, color: 'bg-[#E1306C]', textColor: 'text-white'},
  { href: 'https://x.com/kuraykaraaslan', title: 'X', icon: faXTwitter, color: 'bg-black', textColor: 'text-white'},
  { href: 'https://www.twitch.tv/kuraykaraaslan', title: 'Twitch', icon: faTwitch, color: 'bg-[#6441A4]', textColor: 'text-white'},
  { href: 'https://www.tiktok.com/@kuraykaraaslan', title: 'Tiktok', icon: faTiktok, color: 'bg-[#000000]', textColor: 'text-white'},

];


export default function MyLinks() {
  return (
    <div className="p-4 rounded-lg shadow-md space-y-3">
        {links.map((link, index) => (
          <Link href={link.href} key={index}
           className={`btn btn-block space-x-2 font-bold py-0 text-sm ${link.color} ${link.textColor}`}>
            <FontAwesomeIcon icon={link.icon} className="w-4 h-4" />
            <span>{link.title}</span>
          </Link>
        ))}
    </div>
  );
}


=== ./app/sitemap.xml/route.ts ===
// app/sitemap.xml/route.ts
import { NextResponse } from 'next/server';
import { getBaseUrl, renderSitemapIndex } from '@/helpers/SitemapGenerator';

export async function GET() {
  const BASE = getBaseUrl();

  const xml = renderSitemapIndex([
    `${BASE}/sitemap-static.xml`,
    `${BASE}/blog/sitemap.xml`,
    `${BASE}/project/sitemap.xml`,
  ]);

  return new NextResponse(xml, {
    headers: {
      'Content-Type': 'application/xml; charset=utf-8',
      'Cache-Control': 'public, max-age=0, s-maxage=3600, stale-while-revalidate=86400',
    },
  });
}


=== ./app/sitemap-static.xml/route.ts ===
// app/sitemap-static.xml/route.ts
import { NextResponse } from 'next/server';
import { getBaseUrl, renderUrlSet } from '@/helpers/SitemapGenerator';
import redisInstance from '@/libs/redis';
import type { SitemapUrl } from '@/types/SitemapTypes';

const CACHE_KEY = 'sitemap:static';
const CACHE_TTL = 24 * 60 * 60; // 1 gün

export async function GET() {
  const cached = await redisInstance.get(CACHE_KEY);
  if (cached) {
    return new NextResponse(cached, {
      headers: { 'Content-Type': 'application/xml; charset=utf-8' },
    });
  }

  const BASE = getBaseUrl();
  const urls: SitemapUrl[] = [
    { loc: `${BASE}/`, changefreq: 'daily', priority: 1.0 },
    { loc: `${BASE}/about`, changefreq: 'monthly', priority: 0.5 },
    { loc: `${BASE}/projects`, changefreq: 'weekly', priority: 0.8 },
    { loc: `${BASE}/blog`, changefreq: 'daily', priority: 0.9 },
    { loc: `${BASE}/contact`, changefreq: 'monthly', priority: 0.5 },
    { loc: `${BASE}/privacy-policy`, changefreq: 'yearly', priority: 0.3 },
    { loc: `${BASE}/terms-of-use`, changefreq: 'yearly', priority: 0.3 },
  ];

  const xml = renderUrlSet(urls);
  await redisInstance.set(CACHE_KEY, xml, 'EX', CACHE_TTL);

  return new NextResponse(xml, {
    headers: { 'Content-Type': 'application/xml; charset=utf-8' },
  });
}


=== ./next-env.d.ts ===
/// <reference types="next" />
/// <reference types="next/image-types/global" />
/// <reference path="./.next/types/routes.d.ts" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


=== ./types/BlogTypes.ts ===
import { z } from 'zod';
import { SafeUser } from './UserTypes';

const CommentStatus = z.enum(["NOT_PUBLISHED", "PUBLISHED", "SPAM"]).default("NOT_PUBLISHED");
const PostStatus = z.enum(["PUBLISHED", "DRAFT", "ARCHIVED"]).default("PUBLISHED");


const Comment = z.object({
    commentId: z.string(),
    content: z.string(),
    createdAt: z.date(),
    postId: z.string(),
    parentId: z.string().nullable(),
    email: z.string().email().nullable(),
    name: z.string().nullable(),
    status: z.enum(["PUBLISHED", "DRAFT", "ARCHIVED"]).default("PUBLISHED") 
});


const Post = z.object({
    postId: z.string(),
    title: z.string(),
    content: z.string(),
    authorId: z.string(),
    description: z.string().nullable(),
    slug: z.string(),
    keywords: z.array(z.string()),
    createdAt: z.date(),
    categoryId: z.string(),
    image: z.string().nullable(),
    status: z.string().default("PUBLISHED"),
    views: z.number().default(0),
    deletedAt: z.date().nullable().optional(),
});

const Category = z.object({
    categoryId: z.string(),
    title: z.string(),
    description: z.string().nullable(),
    slug: z.string(),
    createdAt: z.date(),
    updatedAt: z.date().optional(),
    image: z.string().nullable(),
    keywords: z.array(z.string()).optional(),
});

const PostWithData = Post.extend({
    author: SafeUser.pick({
        userId: true,
        name: true,
        profilePicture: true,
    }),
    category: Category.pick({
        categoryId: true,
        title: true,
        slug: true,
        image: true,
        keywords: true,
        description: true,
        createdAt: true,
        updatedAt: true,
    }),
});


const CommentWithData = Comment.extend({
    post: Post.pick({
        postId: true,
        title: true,
        slug: true,
    }),
});

const PostLike = z.object({
  postLikeId: z.string(),
  postId: z.string(),
  userId: z.string().nullable().optional(),
  ipAddress: z.string().nullable().optional(),
  deviceFingerprint: z.string().nullable().optional(),
  createdAt: z.date(),
});

export type Comment = z.infer<typeof Comment>;
export type Post = z.infer<typeof Post>;
export type Category = z.infer<typeof Category>;
export type PostWithData = z.infer<typeof PostWithData>;
export type CommentWithData = z.infer<typeof CommentWithData>;
export type PostLike = z.infer<typeof PostLike>;
export { Comment, Post, Category, PostWithData, CommentWithData , PostLike, CommentStatus, PostStatus };

=== ./types/GitTypes.ts ===
import { z } from "zod";

const ContributionDay = z.object({
    color: z.string(),
    contributionCount: z.number(),
    date: z.string(),
    weekday: z.number(),
});


const Week = z.object({
    contributionDays: z.array(ContributionDay),
    firstDay: z.string(),
    isMilitaryTime: z.boolean().optional(),
});

const Weeks = z.array(Week);

const GraphQLRes = z.object({
    user: z.object({
        contributionsCollection: z.object({
            contributionCalendar: z.object({
                weeks: Weeks,
            }),
        }),
    }),
});


export type ContributionDay = z.infer<typeof ContributionDay>;
export type Week = z.infer<typeof Week>;
export type Weeks = z.infer<typeof Weeks>;
export type GraphQLRes = z.infer<typeof GraphQLRes>;


export type { ContributionDay, Week, Weeks, GraphQLRes };

=== ./types/SkillTypes.ts ===
import { IconProp } from "@fortawesome/fontawesome-svg-core";

import {z} from 'zod';

const Skill = z.object({
  className: z.string().optional(),
  icon: z.any(), // IconProp is not directly supported by Zod
  bgColor: z.string().optional(),
  title: z.string(),
  textColor: z.string().optional(),
});

const Tool = z.object({
  icon: z.any(), // IconProp is not directly supported by Zod
  title: z.string(),
  description: z.string(),
  hoverBgColor: z.string().optional(),
  hoverTextColor: z.string().optional(),
});

export type Tool = z.infer<typeof Tool>;
export type Skill = z.infer<typeof Skill>;
export { Skill , Tool };

=== ./types/UITypes.ts ===
import { IconDefinition } from '@fortawesome/fontawesome-svg-core';

import { z } from 'zod';

const MenuItem = z.object({
    id: z.string().nullable(),
    page: z.string(),
    name: z.string(),
    icon: z.any().optional(), // IconDefinition is not directly supported by Zod
    external: z.boolean().default(false),
    onlyAdmin: z.boolean().default(false),
    textColour: z.string().optional(),
    backgroundColour: z.string().optional(),
    hideTextOnDesktop: z.boolean().default(false),
});

export type MenuItem = z.infer<typeof MenuItem>;
export { MenuItem };


=== ./types/UserTypes.ts ===

import { z } from 'zod';

const UserRole = z.enum(['ADMIN', 'USER']).default('USER');
const OTPMethod = z.enum(['EMAIL', 'SMS', 'TOTP_APP', 'PUSH_APP']);
const UserStatus = z.enum(['ACTIVE', 'INACTIVE', 'BANNED']).default('ACTIVE');

const User = z.object({
    userId: z.string(),
    email: z.string().email(),
    phone: z.string().nullable().optional(),
    password: z.string().min(8, "Password must be at least 8 characters long"),
    name: z.string().nullable().optional(),
    lastName: z.string().nullable().optional(),
    userRole: UserRole.default('USER'),
    userStatus: UserStatus.optional(),
    createdAt: z.date().optional(),
    updatedAt: z.date().optional(),
    deletedAt: z.date().nullable().optional(),
    profilePicture: z.string().nullable().optional(),
    otpMethods: z.array(OTPMethod).default([]),
    otpSecret: z.string().nullable().optional(),

    headerImage: z.string().nullable().optional(),
    biography: z.string().nullable().optional(),
});


const SafeUser = z.object({
    userId: z.string(),
    email: z.string().email(),
    phone: z.string().nullable().optional(),
    name: z.string().nullable().optional(),
    userRole: z.string(),
    createdAt: z.date().optional(),
    updatedAt: z.date().optional(),
    profilePicture: z.string().nullable().optional(),
    otpMethods: z.array(OTPMethod).optional(),

    headerImage: z.string().nullable().optional(),
    biography: z.string().nullable().optional(),
});


export type SafeUser = z.infer<typeof SafeUser>;
export type User = z.infer<typeof User>;
export type UserRole = z.infer<typeof UserRole>;
export type OTPMethod = z.infer<typeof OTPMethod>;
export type UserStatus = z.infer<typeof UserStatus>;

export { SafeUser, User, UserRole, OTPMethod, UserStatus };

=== ./types/CalendarTypes.ts ===
import { time } from 'console'
import { z } from 'zod'

export const Day = z.enum([
  'monday',
  'tuesday',
  'wednesday',
  'thursday',
  'friday',
  'saturday',
  'sunday',
])

export type Day = z.infer<typeof Day>

 
export const Slot = z.object({
  startTime: z.preprocess(
    (val) => (typeof val === "string" ? new Date(val) : val),
    z.date()
  ),
  endTime: z.preprocess(
    (val) => (typeof val === "string" ? new Date(val) : val),
    z.date()
  ),

  capacity: z.number().min(0).default(1), // max appointments for this slot
})


export const SlotTemplate = z.object({
  day: Day,
  slots: Slot.array(),
})


export const AppointmentStatus = z.enum(['PENDING', 'BOOKED', 'CANCELLED', 'COMPLETED'])
export type AppointmentStatus = z.infer<typeof AppointmentStatus>


export const Appointment = z.object({
  appointmentId: z.string(),

  startTime: z.date(),  // YYYY-MM-DDTHH:mm UTC format
  endTime: z.date(),    // YYYY-MM-DDTHH:mm UTC format

  name: z.string(),
  email: z.string(),
  phone: z.string(),
  note: z.string().nullable().optional(),

  status: AppointmentStatus.default('PENDING'),
  createdAt: z.date(),
})

export type Appointment = z.infer<typeof Appointment>
export type Slot = z.infer<typeof Slot>
export type SlotTemplate = z.infer<typeof SlotTemplate>


=== ./types/SettingTypes.ts ===
import { z } from "zod";

const Setting = z.object({
  key: z.string(),
  value: z.string(),
  createdAt: z.date(),
  updatedAt: z.date().nullable(),
  group: z.string().default("general"),
  type: z.string().default("string"),
});

export type Setting = z.infer<typeof Setting>;
export { Setting };


=== ./types/ContactTypes.ts ===
import { z } from 'zod';

const ContactForm = z.object({
  contactId: z.string().nullable(),
  name: z.string(),
  email: z.string().email(),
  phone: z.string().optional(),
  message: z.string(),
  createdAt: z.date().optional(),
});

export type ContactForm = z.infer<typeof ContactForm>;
export { ContactForm };

=== ./types/ProjectTypes.ts ===
import { z } from 'zod';


const Url = z.object({
    type: z.enum(["GitHub", "Demo", "Other"]).optional(),
    title: z.string().optional(),
    icon: z.any().optional(), // IconDefinition is not directly supported by Zod
    url: z.string().url(),
});


const Tag = z.object({
    name: z.string(),
    color: z.string(),
    icon: z.any(), // IconDefinition is not directly supported by Zod
});



const Project = z.object({
    projectId: z.string(),
    title: z.string(),
    description: z.string().nullable(),
    slug: z.string(),
    image: z.string().nullable(),
    status: z.string().default("PUBLISHED"),
    platforms: z.array(z.string()).default([]),
    technologies: z.array(z.string()).default([]),
    content: z.string(),
    createdAt: z.date(),
    updatedAt: z.date().nullable(),
    projectLinks: z.array(z.string()).default([]),
});

const Platform = z.object({
    name: z.string(),
    icon: z.string(),
    url: z.string().url().optional(),
    bgColor: z.string().optional(),
    borderColor: z.string().optional(),
    zoom: z.number().optional(),
});


const Service = z.object({
  id: z.string(),
  image: z.string(),
  title: z.string(),
  description: z.string(),
  urls: z.array(Url),
  tags: z.array(Tag),
  bgColor: z.string().optional(),
  borderColor: z.string().optional(),
  textColor: z.string().optional(),
});


export type Project = z.infer<typeof Project>;
export type Platform = z.infer<typeof Platform>;
export type Tag = z.infer<typeof Tag>;
export type Service = z.infer<typeof Service>;
export type Url = z.infer<typeof Url>;

export { Project, Platform, Tag, Service, Url };

=== ./types/SSOTypes.ts ===
import { z } from 'zod';

export const SSOProfileResponse = z.object({
    sub: z.string(),
    name: z.string().optional(),
    email: z.string(),
    picture: z.string().optional(),
    provider: z.string(),
});

export type SSOProfileResponse = z.infer<typeof SSOProfileResponse>;



=== ./types/UserAgent.ts ===
enum OSName {
  Windows = "Windows",
  macOS = "macOS",
  Android = "Android",
  iOS = "iOS",
  ChromeOS = "Chrome OS",
  Linux = "Linux",
  Unix = "Unix",
  Unknown = "Unknown"
}

enum DeviceType {
  Mobile = "Mobile",
  Tablet = "Tablet",
  Desktop = "Desktop"
}

enum BrowserName {
  Chrome = "Chrome",
  Firefox = "Firefox",
  Safari = "Safari",
  Edge = "Edge",
  IE = "IE",
  Opera = "Opera",
  Postman = "Postman",
  Unknown = "Unknown"
}

type GeoLocation = {
  city: string | null;
  state: string | null;
  country: string | null;
};

type OSPattern = {
  pattern: RegExp;
  name: OSName;
};

export type { GeoLocation, OSPattern };
export { OSName, DeviceType, BrowserName };

=== ./types/TestimonialTypes.ts ===
const Testimonial = z.object({
  id: z.number(),
  name: z.string(),
  title: z.string(),
  review: z.string(),
})

export type Testimonial = z.infer<typeof Testimonial>
export { Testimonial }

=== ./types/SitemapTypes.ts ===
// types/SitemapTypes.ts
import type { ChangeFreq } from '@/helpers/SitemapGenerator';

export type SitemapUrl = {
  loc: string;
  lastmod?: string;       // ISO8601
  changefreq?: ChangeFreq;
  priority?: number;      // 0.0 - 1.0
};


=== ./types/UserSessionTypes.ts ===
import {z} from 'zod';

const UserAgentData = z.object({
    os: z.string().nullable(),
    device: z.string().nullable(),
    city: z.string().nullable(),
    state: z.string().nullable(),
    country: z.string().nullable(),
    ip: z.string().nullable(),
    browser: z.string().nullable(),
    deviceFingerprint: z.string().nullable(),
});

const SafeUserSession = z.object({
    userSessionId: z.string(),
    userId: z.string(),
    otpVerifyNeeded: z.boolean(),
    sessionExpiry: z.date(),
});



export type SafeUserSession = z.infer<typeof SafeUserSession>;
export type UserAgentData = z.infer<typeof UserAgentData>;

export { SafeUserSession, UserAgentData };

=== ./types/SubscriptionTypes.ts ===
import { z } from "zod";

const Subscription = z.object({
  email: z.string().email(),
  createdAt: z.date(),
  deletedAt: z.date().nullable(),
});

export type Subscription = z.infer<typeof Subscription>;    
export { Subscription };

=== ./messages/AuthMessages.ts ===
export enum AuthMessages {
    EITHER_EMAIL_OR_PHONE_MUST_BE_PROVIDED = "EITHER_EMAIL_OR_PHONE_MUST_BE_PROVIDED",
    INVALID_CREDENTIALS = "INVALID_CREDENTIALS",
    INVALID_PASSWORD = "INVALID_PASSWORD",
    INVALID_PHONE_NUMBER = "INVALID_PHONE_NUMBER",
    INVALID_EMAIL_ADDRESS = "INVALID_EMAIL_ADDRESS",
    INVALID_REFRESH_TOKEN = "INVALID_REFRESH_TOKEN",
    PASSWORD_MUST_BE_AT_LEAST_8_CHARACTERS_LONG = "PASSWORD_MUST_BE_AT_LEAST_8_CHARACTERS_LONG",
    PASSWORDS_DO_NOT_MATCH = "PASSWORDS_DO_NOT_MATCH",
    REGISTRATION_SUCCESSFUL = "REGISTRATION_SUCCESSFUL",
    LOGIN_SUCCESSFUL = "LOGIN_SUCCESSFUL",
    PASSWORD_RESET_EMAIL_SENT = "PASSWORD_RESET_EMAIL_SENT",
    PASSWORD_RESET_SUCCESSFUL = "PASSWORD_RESET_SUCCESSFUL",
    PASSWORD_RESET_FAILED = "PASSWORD_RESET_FAILED",
    UNKNOWN_ERROR = "UNKNOWN_ERROR",
    INVALID_TOKEN = "INVALID_TOKEN",
    SESSION_NOT_FOUND = "SESSION_NOT_FOUND",
    USER_NOT_FOUND = "USER_NOT_FOUND",
    EMAIL_ALREADY_EXISTS = "EMAIL_ALREADY_EXISTS",
    INVALID_EMAIL_OR_PASSWORD = "INVALID_EMAIL_OR_PASSWORD",
    INVALID_OTP = "INVALID_OTP",
    OTP_EXPIRED = "OTP_EXPIRED",
    USER_HAS_NO_PHONE_NUMBER = "USER_HAS_NO_PHONE_NUMBER",
    USER_HAS_NO_EMAIL = "USER_HAS_NO_EMAIL",
    OTP_ALREADY_ENABLED = "OTP_ALREADY_ENABLED",
    OTP_ALREADY_DISABLED = "OTP_ALREADY_DISABLED",
    OTP_CHANGED_SUCCESSFULLY = "OTP_CHANGED_SUCCESSFULLY",
    INVALID_PROVIDER = "INVALID_PROVIDER",
    INVALID_PROVIDER_TOKEN = "INVALID_PROVIDER_TOKEN",
    OTP_SENT_SUCCESSFULLY = "OTP_SENT_SUCCESSFULLY",
    OTP_VERIFIED_SUCCESSFULLY = "OTP_VERIFIED_SUCCESSFULLY",
    PHONE_ALREADY_EXISTS = "PHONE_ALREADY_EXISTS",
    LOGGED_OUT_SUCCESSFULLY = "LOGGED_OUT_SUCCESSFULLY",
    OTP_NOT_NEEDED = "OTP_NOT_NEEDED",
    INVALID_METHOD = "INVALID_METHOD",
    USER_NOT_AUTHENTICATED = "USER_NOT_AUTHENTICATED",
    USER_DOES_NOT_HAVE_REQUIRED_ROLE = "USER_DOES_NOT_HAVE_REQUIRED_ROLE",
    OTP_NEEDED = "OTP_NEEDED",
    DEVICE_FINGERPRINT_NOT_MATCH = "DEVICE_FINGERPRINT_NOT_MATCH",
    SOCIAL_ACCOUNT_NOT_FOUND = "SOCIAL_ACCOUNT_NOT_FOUND",
    TOKEN_EXPIRED = "TOKEN_EXPIRED",
    REFRESH_TOKEN_REUSED = "REFRESH_TOKEN_REUSED",
    TWO_AUTH_SOURCES = "TWO_AUTH_SOURCES",
    INVALID_OTP_METHOD = "INVALID_OTP_METHOD",
    FORGOT_PASSWORD_SUCCESSFUL = "FORGOT_PASSWORD_SUCCESSFUL",
    OTHER_SESSIONS_DESTROYED = "OTHER_SESSIONS_DESTROYED",
    OTP_ALREADY_SENT = "OTP_ALREADY_SENT",
    RATE_LIMIT_EXCEEDED = "RATE_LIMIT_EXCEEDED",
    REGISTRATION_DISABLED = "REGISTRATION_DISABLED",
}


export default AuthMessages;

=== ./messages/SSOMessages.ts ===
export enum SSOMessages {
    INVALID_PROVIDER = "INVALID_PROVIDER",
    AUTHENTICATION_FAILED = "AUTHENTICATION_FAILED",
    OAUTH_ERROR = "OAUTH_ERROR",
    USER_NOT_FOUND = "USER_NOT_FOUND",
    EMAIL_NOT_FOUND = "EMAIL_NOT_FOUND",
    CODE_NOT_FOUND = "CODE_NOT_FOUND",
}

=== ./global.d.ts ===
import { NextRequest as OriginalNextRequest } from 'next/server'
import SafeUser from './types/SafeUser'

declare global {
    declare interface NextRequest extends OriginalNextRequest {
        user: SafeUser
    }
} 

=== ./tailwind.config.ts ===
import type { Config } from "tailwindcss";

import plugin from "tailwindcss/plugin";

const rotateY = plugin(function ({ addUtilities }) {
  addUtilities({
    ".rotate-y-60": {
      transform: "rotateY(60deg)",
    },
    ".rotate-y-90": {
      transform: "rotateY(90deg)",
    },
    ".rotate-y-120": {
      transform: "rotateY(120deg)",
    },
    ".rotate-y-180": {
      transform: "rotateY(180deg)",
    },
    ".rotate-y-270": {
      transform: "rotateY(270deg)",
    },
    ".rotate-y-0": {
      transform: "rotateY(0deg)",
    },
  });
});


const config: Config = {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      colors: {
        background: "var(--background)",
        foreground: "var(--foreground)",
      },
      keyframes: {
        typing: {
          "0%": {
            width: "0%",
            visibility: "hidden"
          },
          "100%": {
            width: "100%"
          }
        },
        blink: {
          "50%": {
            borderColor: "transparent"
          },
          "100%": {
            borderColor: "white"
          }
        }
      },
      animation: {
        typing: "typing 0.5s steps(20) infinite alternate, blink .7s infinite"
      },
      textShadow: {
        sm: '0 1px 2px var(--tw-shadow-color)',
        DEFAULT: '0 2px 4px var(--tw-shadow-color)',
        lg: '0 8px 16px var(--tw-shadow-color)',
      },
    },
  },
  plugins: [
    plugin(function ({ matchUtilities, theme }) {
      matchUtilities(
        {
          'text-shadow': (value) => ({
            textShadow: value,
          }),
        },
        { values: theme('textShadow') }
      )
    }),
    require("daisyui"), 
    require("@tailwindcss/typography"), 
    rotateY, 
    require('@tailwindcss/forms')],
  daisyui: {
    themes: [
      'light',
      'dark',
    ]
  },
};
export default config;


=== ./dtos/AuthDTO.ts ===
import { z } from "zod";

import  AuthMessages from "@/messages/AuthMessages";

const LoginRequest = z.object({
    email: z.string().email().refine(
        (email) => email.length > 0,
        {
            message: AuthMessages.INVALID_EMAIL_ADDRESS,
        }
    ),
    password: z.string().min(8,  {
        message: AuthMessages.INVALID_PASSWORD,
    }),
});

const RegisterRequest = z.object({
    email: z.string().email().refine(
        (email) => email.length > 0,
        {
            message: AuthMessages.INVALID_EMAIL_ADDRESS,
        }
    ),
    password: z.string().min(8, {
        message: AuthMessages.INVALID_PASSWORD,
    }),
    name: z.string(),
    phone: z.string().optional(),
});

const ForgotPasswordRequest = z.object({
    email: z.string().email().refine(
        (email) => email.length > 0,
        {
            message: AuthMessages.INVALID_EMAIL_ADDRESS,
        }
    )
    });

const ResetPasswordRequest = z.object({
    email: z.string().email().refine(
        (email) => email.length > 0,
        {
            message: AuthMessages.INVALID_EMAIL_ADDRESS,
        }
    ),
    resetToken: z.string().min(1, {
        message: AuthMessages.INVALID_TOKEN,
    }),
    password: z.string().min(8, {
        message: AuthMessages.INVALID_PASSWORD,
    }),
});

export type LoginRequest = z.infer<typeof LoginRequest>;
export type RegisterRequest = z.infer<typeof RegisterRequest>;
export type ForgotPasswordRequest = z.infer<typeof ForgotPasswordRequest>;
export type ResetPasswordRequest = z.infer<typeof ResetPasswordRequest>;

export { LoginRequest, RegisterRequest, ForgotPasswordRequest, ResetPasswordRequest };

=== ./components/frontend/Whatsapp/index.tsx ===
'use client';
import React, { useEffect, useState } from "react";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faWhatsapp } from "@fortawesome/free-brands-svg-icons";
import { useTranslation } from "react-i18next";

const Whatsapp = () => {

    const { t } = useTranslation();

    const [ count, setCount ] = useState(0);
    const [ sayac, setSayac ] = useState<NodeJS.Timeout | null>(null);

    const [resetted, setResetted] = useState(false);

    const [message, setMessage] = useState(t("whatsapp.message"));

    useEffect(() => {
        const scrollToTopBtn = document.getElementById(
            "whatsapp",
        ) as HTMLElement;
        const main = document.getElementById("main");

        //make the button appear slowly  when the user scrolls down 20px from the top to 500ms

        window?.addEventListener("scroll", () => {

            var totalWindowHeight = document.body.scrollHeight - window?.innerHeight;
            var aligned = window?.scrollY * 0.1 - 80;
            if (aligned > 20) {
                aligned = 20;
            }
            scrollToTopBtn.style.right = aligned + "px";
            if (
                document.body.scrollTop > 20 ||
                document.documentElement.scrollTop > 20
            ) {
                scrollToTopBtn.style.display = "flex";
            } else {
                scrollToTopBtn.style.display = "none";
            }

            //if it is end of the page, for footer raise it up to 100px
            if (
                window?.innerHeight + window?.scrollY >=
                document.body.offsetHeight - 50
            ) {
                const diff =
                    window?.innerHeight + window?.scrollY - document.body.offsetHeight + 50;
                scrollToTopBtn.style.bottom = diff + 100 + "px";
            } else {
                scrollToTopBtn.style.bottom = "100px";
            }
        });
    });


    useEffect(() => {

        if (sayac) {
            return;
        }

        if (resetted) {
            setSayac(null);
            return;
        }

        // create a Timeout
        setSayac(setTimeout(() => {
            // 10 to 100 seconds
            setCount(prev => prev + 1);
            //new Audio("/assets/wav/beep-07a.wav").play();

            //Clear the Timeout
            setSayac(null);
        }
        , Math.floor(Math.random() * 10000) + 10000));

    }, []);

            
    return (
        <div
            className="fixed transition duration-1000 ease-in-out bg-[#25D366] text-white cursor-pointer shadow-lg rounded-full"
            style={{ zIndex: 103, right: "-80px", bottom: "100px" }}
            id="whatsapp"
            onClick={() => window?.open("https://wa.me/905459223554")}
        >
            <div className="relative transition duration-1000 ease-in-out bg-[#25D366] cursor-pointer p-4 rounded-full group">
                <FontAwesomeIcon
                    icon={faWhatsapp}
                    className="text-l text-white w-8 h-8 md:w-6 md:h-6"
                />
                {count > 0 && 
                <span className="absolute top-0 right-0 bg-red-500 text-white rounded-full px-1 text-sm">{count}</span>
                }

                {count > 0 &&
                <div className="absolute bg-white text-black rounded-lg p-2 bottom-0 w-48 right-0 transform -translate-y-1/2 -translate-x-1/3 shadow-lg hidden group-hover:block transition duration-1000 ease-in-out"
                onMouseEnter={() => setResetted(true)}
                onClick={() => setResetted(true)}
                >
                    <p>{t("whatsapp.message")}</p>
                </div>
                }

        
            </div>
        </div>

    );
}

export default Whatsapp;

=== ./components/frontend/AppointmentCalendar/index.tsx ===
'use client'

import React, { useEffect, useState } from 'react'
import Calendar from 'react-calendar'
import './style.css'
import { toast } from 'react-toastify'
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome'
import { faCalendar, faClock, faStopwatch, faX } from '@fortawesome/free-solid-svg-icons'
import { format, parseISO, differenceInMinutes } from 'date-fns'
import type { Slot } from '@/types/CalendarTypes'
import axios from 'axios'
import AppointmentModal from './AppointmentModal'

export default function AppointmentCalendar() {
  const [availableSlots, setAvailableSlots] = useState<Slot[]>([])
  const [selectedDate, setSelectedDate] = useState<Date>(new Date())
  const [selectedSlot, setSelectedSlot] = useState<Slot | null>(null)
  const today = new Date()

  /** Format date as yyyy-MM-dd */
  const formatDate = (date: Date) => format(date, 'yyyy-MM-dd')

  /** Tile styling */
  const getTileClassName = ({ date }: { date: Date }): string => {
    const d = formatDate(date)
    const todayStr = formatDate(today)
    const hasSlot = availableSlots.some(
      (s) => format(new Date(s.startTime), 'yyyy-MM-dd') === d
    )
    const isSelected = format(selectedDate, 'yyyy-MM-dd') === d
    const isPast = date < new Date(todayStr)

    const classes: string[] = []
    if (isSelected) classes.push('selected')
    if (d === todayStr) classes.push('now')
    classes.push(hasSlot ? 'available' : 'unavailable')
    if (isPast) classes.push('disabled')
    return classes.join(' ')
  }

  const slotsOf = (date: Date) => {
    const d = format(date, 'yyyy-MM-dd')
    return availableSlots.filter(
      (s) => format(new Date(s.startTime), 'yyyy-MM-dd') === d
    )
  }

  const handleDateSelect = (
    value: Date | Date[] | null,
    event?: React.MouseEvent<HTMLButtonElement, MouseEvent>
  ) => {
    if (value instanceof Date) {
      setSelectedDate(value)
      setSelectedSlot(null)
    }
  }

  const handleTimeSelect = (slot: Slot) => {
    setSelectedSlot(slot)
  }

  const preloadRange = async () => {
    const start = new Date()
    const end = new Date()
    end.setDate(start.getDate() + 14)

    try {
      const res = await axios.get(
        `/api/slots?startDate=${formatDate(start)}&endDate=${formatDate(end)}`
      )
      const data = (res.data?.slots || []) as Slot[]
      setAvailableSlots(data)

      // Select first available date automatically
      if (!selectedDate && data.length > 0) {
        const first = new Date(data[0].startTime)
        setSelectedDate(first)
      }
    } catch (err) {
      console.error(err)
      toast.error('Slotlar alınamadı')
    }
  }

  useEffect(() => {
    preloadRange()
  }, [])

  return (
    <section className="bg-base-200 pt-16" id="appointments">
      <div className="px-4 mx-auto max-w-screen-xl lg:pb-16 lg:px-6">
        <div className="mx-auto max-w-screen-sm text-center -mt-8 lg:mt-0">
          <h2 className="mb-4 text-3xl lg:text-4xl tracking-tight font-extrabold">
            Randevu
          </h2>
          <p className="font-light sm:text-xl">Uygun bir günü ve saati seçin</p>
        </div>

        <div className="flex flex-wrap justify-center gap-4 mb-8 mt-3">
          <div className="w-1/2 sm:w-1/3 md:w-1/4">
            <Calendar
              // @ts-ignore
              onChange={handleDateSelect}
              value={selectedDate}
              tileClassName={getTileClassName}
              minDate={today}
              maxDate={new Date(today.getTime() + 14 * 24 * 60 * 60 * 1000)}
            />
          </div>

          <div className="w-1/2 sm:w-1/3 md:w-1/4">
            {slotsOf(selectedDate).length > 0 ? (
              <div>
                <h3 className="text-lg font-semibold mb-2">Mevcut Saatler</h3>
                <div className="grid grid-cols-2 gap-2 max-h-96 overflow-y-auto pr-2">
                  {slotsOf(selectedDate).map((slot, idx) => {
                    const start = new Date(slot.startTime)
                    const end = new Date(slot.endTime)
                    const length = differenceInMinutes(end, start)
                    const label = `${format(start, 'HH:mm')}`
                    const isSelected =
                      selectedSlot?.startTime === slot.startTime &&
                      selectedSlot?.endTime === slot.endTime

                    return (
                      <button
                        key={idx}
                        disabled={slot.capacity <= 0}
                        className={`btn btn-outline btn-sm btn-block text-left h-16 ${isSelected ? 'btn-primary' : ''
                          } ${slot.capacity <= 0 ? 'btn-disabled cursor-not-allowed' : ''}`}
                        onClick={() => handleTimeSelect(slot)}
                      >
                        <FontAwesomeIcon icon={slot.capacity <= 0 ? faX : faClock} className="mr-2" />
                        {label} ({length} dk)
                      </button>
                    )
                  })}
                </div>
              </div>
            ) : (
              <p className="text-sm text-gray-500">Seçilen gün için müsait saat yok.</p>
            )}

            {selectedSlot && (
              <div className="mt-4">
                <h3 className="text-lg font-semibold mb-2">Seçilen Saat</h3>
                <p className="text-sm space-x-2">
                  <span className="font-semibold">
                    <FontAwesomeIcon icon={faCalendar} className="mr-2" />
                    {format(parseISO(selectedSlot.startTime.toString()), 'yyyy-MM-dd')}
                  </span>
                  <span className="font-semibold">
                    <FontAwesomeIcon icon={faClock} className="mr-2" />
                    {format(new Date(selectedSlot.startTime), 'HH:mm')} -{' '}
                    {format(new Date(selectedSlot.endTime), 'HH:mm')}
                  </span>
                  <span className="font-semibold">
                    <FontAwesomeIcon icon={faStopwatch} className="mr-2" />
                    {differenceInMinutes(
                      new Date(selectedSlot.endTime),
                      new Date(selectedSlot.startTime)
                    )}{' '}
                    dk
                  </span>
                </p>
                <button
                  className="btn btn-primary btn-block mt-4"
                  onClick={() =>
                    (document.getElementById('appt_modal') as HTMLDialogElement)?.showModal()
                  }
                >
                  Randevu Al
                </button>
              </div>
            )}
          </div>
        </div>
      </div>

      <AppointmentModal selectedSlot={selectedSlot} preloadRange={preloadRange} />
    </section>
  )
}


=== ./components/frontend/AppointmentCalendar/AppointmentModal.tsx ===
import { Slot } from "@/types/CalendarTypes"
import { differenceInMinutes, format } from "date-fns"
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome"
import { faCalendar, faClock, faStopwatch } from "@fortawesome/free-solid-svg-icons"
import { toast } from "react-toastify"
import axiosInstance from "@/libs/axios"

const AppointmentModal = ({ selectedSlot , preloadRange}: { selectedSlot: Slot | null, preloadRange: () => Promise<void> }) => {
    
    const handleFormSubmit = async (e: React.FormEvent) => {
        e.preventDefault()
        if (!selectedSlot) return toast.error('Önce bir saat seçin.')

        const data = new FormData(e.currentTarget as HTMLFormElement)
        const name = data.get('name') as string
        const email = data.get('email') as string
        const phone = data.get('phone') as string
        const note = (data.get('note') as string) || ''

        try {
            const res = await axiosInstance.post('/api/booking', {
                startTime: selectedSlot.startTime,
                endTime: selectedSlot.endTime,
                name,
                email,
                phone,
                note,
            })
            if (res.data?.success) {
                toast.success('Randevunuz oluşturuldu.')
                await preloadRange()
                    ; (document.getElementById('appt_modal') as HTMLDialogElement)?.close()
            } else {
                toast.error(res.data?.message || 'Randevu alınamadı')
            }
        } catch (err) {
            console.error(err)
            toast.error('Bir hata oluştu')
        }
    }


    return (
        <dialog id="appt_modal" className="modal">
            <div className="modal-box">
                <h3 className="font-bold text-lg mb-4">Randevu Bilgileri</h3>
                {selectedSlot && (
                    <p className="text-sm space-x-2 mb-4">
                        <span className="font-semibold">
                            <FontAwesomeIcon icon={faCalendar} className="mr-2" />
                            {format(new Date(selectedSlot.startTime), 'yyyy-MM-dd')}
                        </span>
                        <span className="font-semibold">
                            <FontAwesomeIcon icon={faClock} className="mr-2" />
                            {format(new Date(selectedSlot.startTime), 'HH:mm')} -{' '}
                            {format(new Date(selectedSlot.endTime), 'HH:mm')}
                        </span>
                        <span className="font-semibold">
                            <FontAwesomeIcon icon={faStopwatch} className="mr-2" />
                            {differenceInMinutes(
                                new Date(selectedSlot.endTime),
                                new Date(selectedSlot.startTime)
                            )}{' '}
                            dk
                        </span>
                    </p>
                )}

                <form onSubmit={handleFormSubmit} className="space-y-3">
                    <label className="label">
                        <span className="label-text">Ad Soyad</span>
                    </label>
                    <input type="text" name="name" required className="input input-bordered w-full" />

                    <label className="label">
                        <span className="label-text">E-posta</span>
                    </label>
                    <input type="email" name="email" required className="input input-bordered w-full" />

                    <label className="label">
                        <span className="label-text">Telefon</span>
                    </label>
                    <input type="tel" name="phone" required className="input input-bordered w-full" />

                    <label className="label">
                        <span className="label-text">Not</span>
                    </label>
                    <textarea name="note" rows={3} className="textarea textarea-bordered w-full" />

                    <button type="submit" className="btn btn-primary w-full">
                        Randevuyu Oluştur
                    </button>
                </form>

                <div className="modal-action">
                    <form method="dialog" className="w-full">
                        <button className="btn btn-secondary btn-block">Kapat</button>
                    </form>
                </div>
            </div>
        </dialog>
    )
}
export default AppointmentModal

=== ./components/frontend/AppointmentCalendar/SSOLogin/index.tsx ===
'use client'
import React from 'react'
import axiosInstance from '@/libs/axios'
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome'
import {
  faApple,
  faGithub,
  faGoogle,
  faMicrosoft
} from '@fortawesome/free-brands-svg-icons'
import { useRouter } from 'next/navigation'
import { toast } from 'react-toastify'

const SSOLogin: React.FC = () => {
  const router = useRouter()

  const handleGoogleLogin = async () => {
    axiosInstance
      .get('/api/auth/sso/google')
      .then(response => {
        const url = response.data.url
        router?.push(url)
      })
      .catch(error => {
        console.log(error)
      })
  }

  const handleAppleLogin = () => {
    axiosInstance
      .get('/api/auth/sso/apple')
      .then(response => {
        const url = response.data.url
        router?.push(url)
      })
      .catch(error => {
        console.log(error)
      })
  }

  const handleGithubLogin = () => {
    //disabled for now
    toast.error('Github login is disabled for now')
    return

    axiosInstance
      .get('/api/auth/sso/github')
      .then(response => {
        const url = response.data.url
        router?.push(url)
      })
      .catch(error => {
        console.log(error)
      })
  }

  const handleMicrosoftLogin = () => {
    //disabled for now
    toast.error('Microsoft login is disabled for now')
    return

    axiosInstance
      .get('/api/auth/sso/microsoft')
      .then(response => {
        const url = response.data.url
        router?.push(url)
      })
      .catch(error => {
        console.log(error)
      })
  }

  return (
    <>
      <div className='flex flex-row items-center justify-center mb-8 mt-2'>
        <div className='flex-1 text-sm font-semibold leading-6'>
          <span className='select-none'>
            you need to login with one of the following:
          </span>
        </div>
        <div className='flex flex-row space-x-2 flex-wrap justify-center'>
          <button
            type='button'
            className='btn text-sm text-white font-semibold leading-6 bg-[#405de6] rounded-lg'
            onClick={handleGoogleLogin}
          >
            <FontAwesomeIcon
              icon={faGoogle}
              className='h-4 w-4'
              aria-hidden='true'
            />
          </button>
          <button
            type='button'
            className='btn text-sm text-white font-semibold leading-6 bg-[#000000] rounded-lg'
            onClick={handleAppleLogin}
          >
            <FontAwesomeIcon
              icon={faApple}
              className='h-4 w-4'
              aria-hidden='true'
            />
          </button>
          <button
            type='button'
            className='btn text-sm text-white font-semibold leading-6 bg-[#333] rounded-lg'
            onClick={handleGithubLogin}
          >
            <FontAwesomeIcon
              icon={faGithub}
              className='h-4 w-4'
              aria-hidden='true'
            />
          </button>

          <button
            type='button'
            className='btn text-sm text-white font-semibold leading-6 bg-[#00acee] rounded-lg'
            onClick={handleMicrosoftLogin}
          >
            <FontAwesomeIcon
              icon={faMicrosoft}
              className='h-4 w-4'
              aria-hidden='true'
            />
          </button>
        </div>
      </div>
      <div className='text-sm text-primary mb-4 select-none'>
        <p className="text-xs text-base-content">for verification purposes, only registered users can book appointments. If you are not registered, you can still book an appointment by using the contact form.</p>
      </div>
    </>
  )
}

export default SSOLogin


=== ./components/frontend/MenuItems/index.tsx ===
import { faFilePdf, faShield } from '@fortawesome/free-solid-svg-icons';
import { faGithub, faLinkedin } from '@fortawesome/free-brands-svg-icons';
import MenuItem from '@/types/UITypes';

const MenuItems = [
        { id: "home", page: '/', name: 'home' },
        { id: "portfolio", page: '/', name: 'portfolio' },
        //{ id: "timeline", page: '/', name: 'experience' },
        { id: "contact", page: '/#contact', name: 'contact' },
        { id: null, page: '/blog', name: 'blog' },
        //{ id: "freelance", page: '/freelance', name: 'freelance' },
        { id: "backend", page: '/admin', name: 'backend' , onlyAdmin: true , hideTextOnDesktop: true , icon: faShield , textColour: 'text-primary' },
        { id: "github", page: 'https://github.com/kuraykaraaslan', name: 'github', external: true , icon: faGithub , hideTextOnDesktop: true },
        //{ id: "linkedin", page: 'https://www.linkedin.com/in/kuraykaraaslan/', name: 'linkedin', external: true , icon: faLinkedin , hideTextOnDesktop: true , textColour: 'text-[#0a66c2]' },
        //{ id: "resume", page: 'https://drive.google.com/file/d/17Ya5AC2nvcvccN-bS2pFsKFIm5v8dcWN/view', name: 'resume', external: true , icon: faFilePdf , hideTextOnDesktop: true , textColour: 'text-[#b24020]' },
    ] as MenuItem[];

export default MenuItems;

=== ./components/frontend/Article/index.tsx ===
//default article

import React from "react";
import { Post } from "@prisma/client";
import Image from "next/image";


const NEXT_PUBLIC_APPLICATION_HOST = process.env.APPLICATION_HOST;

export default function Article(post: Partial<Post>) {

    const image = post.image ? post.image : null;
    
    return (
        <div className="max-w-none justify-center text-left mx-auto prose mb-8">
            {image && <img src={image ? image : `${NEXT_PUBLIC_APPLICATION_HOST}/api/posts/${post.postId}/cover.jpeg`}
            alt={post.title} className="w-full h-64 object-cover" />}
            <div dangerouslySetInnerHTML={{ __html: post.content as string }}></div>
        </div>
    );
}

=== ./components/frontend/ScrollToTop/index.tsx ===
'use client';
import React, { useEffect } from "react";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faArrowUp } from "@fortawesome/free-solid-svg-icons";

const ScrollToTop = () => {

    useEffect(() => {
        const scrollToTopBtn = document.getElementById(
            "scrollToTop",
        ) as HTMLElement;
        const main = document.getElementById("main");

        //make the button appear slowly  when the user scrolls down 20px from the top to 500ms
        window?.addEventListener("scroll", () => {
            var totalWindowHeight = document.body.scrollHeight - window?.innerHeight;
            var aligned = window?.scrollY * 0.1 - 80;
            if (aligned > 20) {
                aligned = 20;
            }
            scrollToTopBtn.style.right = aligned + "px";
            if (
                document.body.scrollTop > 20 ||
                document.documentElement.scrollTop > 20
            ) {
                scrollToTopBtn.style.display = "flex";
            } else {
                scrollToTopBtn.style.display = "none";
            }

            //if it is end of the page, for footer raise it up to 100px
            if (
                window?.innerHeight + window?.scrollY >=
                document.body.offsetHeight - 50
            ) {
                const diff =
                    window?.innerHeight + window?.scrollY - document.body.offsetHeight + 50;
                scrollToTopBtn.style.bottom = diff + 20 + "px";
            } else {
                scrollToTopBtn.style.bottom = "20px";
            }
        });
    });

    return (
        <div
          className="fixed transition duration-1000 ease-in-out bg-accent hover:bg-base-400 cursor-pointer p-4 shadow-lg rounded-full hover:rounded-box"
          style={{ zIndex: 100, right: "-80px", bottom: "20px" }}
          id="scrollToTop"
          onClick={() => window?.scrollTo({ top: 0, behavior: "smooth" })}
        >
          <FontAwesomeIcon
            icon={faArrowUp}
            className="text-l text-white w-8 h-8 md:w-6 md:h-6"
          />
        </div>
        
    );
    }

export default ScrollToTop;

=== ./components/frontend/Feed/index.tsx ===
'use client';
import { useEffect, useState } from 'react';
import axiosInstance from '@/libs/axios';
import { Category } from '@prisma/client';
import { SafeUser } from '@/types/UserTypes';
import FeedCardImage, { FeedCardProps } from "./Partials/FeedCardImage";

const NEXT_PUBLIC_APPLICATION_HOST = process.env.APPLICATION_HOST;

interface FeedProps {
    category?: Pick<Category, 'categoryId' | 'title'>;
    author?: Pick<SafeUser, 'userId' | 'name' | 'profilePicture'>;
}

export default function Feed(props: FeedProps) {

    const { category, author } = props;

    const [feeds, setFeeds] = useState<FeedCardProps[]>([]);
    const [page, setPage] = useState(0);
    const [pageSize, setPageSize] = useState(5);
    const [isMoreAvailable, setIsMoreAvailable] = useState(true);

    useEffect(() => {
        axiosInstance.get("/api/posts" + `?page=${page + 1}&pageSize=${pageSize}&sort=desc` + (category ? `&categoryId=${category.categoryId}` : '') + `${author ? `&authorId=${author.userId}` : ''}`)
            .then(response => {


                const incomingFeeds = response.data.posts.map((post: any) => {

                    //dont allow duplicate posts
                    if (feeds.find(feed => feed.postId === post.postId)) {
                        return null;
                    }
                    
                    return {
                        ...post,
                        category: post.category,
                        title: post.title,
                        description: post.description,
                        createdAt: new Date(post.createdAt),
                        image: post.image ? post.image : `${NEXT_PUBLIC_APPLICATION_HOST}/api/posts/${post.postId}/cover.jpeg`,
                    };
                });

                setFeeds(prev => [...prev, ...incomingFeeds]);
            

                setIsMoreAvailable((response.data.total > (page + 1) * pageSize) && incomingFeeds.length === pageSize);
            });

    }, [page]); // Make sure to include all dependencies that affect the API call

    return (
        <section className="min-h-screen bg-base-100 pt-32 " id="blog">
            <div
                className="px-4 mx-auto max-w-screen-xl lg:pb-16 lg:px-6 duration-1000"
            >
                <div className="mx-auto text-center lg:mb-8 -mt-8 lg:mt-0 ">
                    <h2 className="mb-8 hidden sm:block text-3xl lg:text-4xl tracking-tight font-extrabold">
                        {category ? category.title : author ? `Posts by ${author.name}` : 'Latest Posts'}
                    </h2>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4 mt-4">
                        {feeds.map((feed, index) => {
                            if (index < 2) {
                                return <FeedCardImage key={index} {...feed} />
                            } else {
                                return null;
                            }
                        })}

                    </div>
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                        {feeds.map((feed, index) => {
                            if (index >= 2) {
                                return <FeedCardImage key={index} {...feed} />
                            } else {
                                return null;
                            }
                        })}
                    </div>
                </div>

                {isMoreAvailable ? (
                    <div className="flex justify-center mb-3">
                        <button
                            className="btn btn-primary"
                            onClick={() => setPage(page + 1)}
                        >
                            Load More
                        </button>
                    </div>
                ) : (
                    <div className="flex justify-center mb-3">
                        <span className="text-base opacity-50 select-none">
                            No more posts available
                        </span>
                    </div>
                )}
            </div>
        </section>
    );
};


=== ./components/frontend/Feed/Partials/FeedCardImage.tsx ===
'use client';
import React, { useEffect, useState } from 'react';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faCalendar, faCaretRight } from '@fortawesome/free-solid-svg-icons';
import Link from 'next/link';
import { PostWithData } from '@/types/BlogTypes';
import Image from 'next/image';

export interface FeedCardProps extends PostWithData {
    className?: string;
}

const FeedCardImage = (props: FeedCardProps) => {

    const [dateText, setDateText] = useState("");

    useEffect(() => {
        if (!props.createdAt) {
            return;
        }

        try {

            const today = new Date();
            if (props.createdAt.toDateString() === today.toDateString()) {
                setDateText("Today");
                return;
            }
            const diff = today.getTime() - new Date(props.createdAt).getTime();
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 7) {
                setDateText(props.createdAt.toDateString());
                return;
            } else if (days > 1) {
                setDateText(`${days} days ago`);
                return;
            } else if (days === 1) {
                setDateText("Yesterday");
                return;
            } else if (hours > 1) {
                setDateText(`${hours} hours ago`);
                return;
            } else if (hours === 1) {
                setDateText("An hour ago");
                return;
            } else if (minutes > 1) {
                setDateText(`${minutes} minutes ago`);
                return;
            } else if (minutes === 1) {
                setDateText("A minute ago");
                return;
            }
            setDateText("Just now");
        } catch (error) {
            console.error(error);
            setDateText("Just now");
        }
    }

        , [props.createdAt]);


    return (
        <div className={"bg-base-100 grid grid-row-2 grid-cols-12 gap-4 shadow-md rounded-lg  from-base-100 to-base-300 bg-gradient-to-b border-t-2 border-primary border-opacity-50 drop-shadow-lg "
            + (props.className || "")}>
            <Link className="col-span-12 justify-center flex border-b-2 border-base-300 rounded-t-lg select-none h-60"
                href={"/blog/" + props?.category?.slug + "/" + props.slug}>
                <img src={props.image!} alt={props.title}
                className="w-full object-cover rounded-t-lg" />
            </Link>
            <div className="col-span-12 justify-center px-4">
                <Link className="text-primary" href={"/blog/" + props.category?.slug + "/" + props.slug}>
                    <h3 className="text-xl font-bold">{props.title || "Title"}</h3>
                </Link>
                <p className="text-base mt-2">{props.description?.substring(0, 200) || "lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."}</p>
            </div>
            <div className="col-span-12 justify-between flex  px-4 pb-4 select-none">
                <div className="flex items-center">
                    <FontAwesomeIcon icon={faCalendar} className="w-4"
                    />
                    <p className="text-sm ml-2">{props.createdAt ? new Date(props.createdAt).toDateString() : dateText}</p>
                    <span className="text-primary ml-2 hidden xl:flex">•</span>
                    <span className="text-primary ml-2 hidden xl:flex">{props.views} views</span>
                </div>
                <div className="flex items-center gap-1">
                    <Link href={"/blog/" + props.category.slug + "/" + props.slug}
                        className="text-primary">Read More
                    <FontAwesomeIcon icon={faCaretRight} className="text-primary mt-1" style={{ height: '1rem', width: '1rem' }} />
                    </Link>
                </div>
            </div>
        </div>
    );
};

export default FeedCardImage;

=== ./components/frontend/Footer/index.tsx ===
'use client';
import React from "react";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import {
  faXTwitter,
  faGithub,
  faLinkedin,
} from "@fortawesome/free-brands-svg-icons";

import Link from "next/link";
import { useTranslation } from "react-i18next";

const Footer = (props: any) => {

  const { t } = useTranslation();

  return (
    <>
      <footer className="footer grid grid-cols-1 lg:grid-cols-2 gap-4 bg-base-300 p-4 min-w-full shadow-lg">
        <div className="col-span-1 flex flex-row flex-wrap justify-start">
          <p>
              © {new Date().getFullYear()} Kuray Karaaslan. {t("footer.all_rights_reserved")}
          </p>
        </div>
        <div className="col-span-1 flex flex-row flex-wrap justify-start">

        </div>
        <div className="col-span-1 flex flex-row flex-wrap justify-end">
          <Link
            href="https://twitter.com/kuraykaraaslan"
            target="_blank"
            rel="noopener noreferrer"
          >
            <FontAwesomeIcon icon={faXTwitter} style={{ width: "24px", height: "24px" }} />
          </Link>
          <Link
            href="https://github.com/kuraykaraaslan"
            target="_blank"
            rel="noopener noreferrer"
          >
            <FontAwesomeIcon icon={faGithub} style={{ width: "24px", height: "24px" }} />
          </Link>
          <Link
            href="https://www.linkedin.com/in/kuraykaraaslan/"
            target="_blank"
            rel="noopener noreferrer"
          >
            <FontAwesomeIcon icon={faLinkedin} style={{ width: "24px", height: "24px" }} />
          </Link>
        </div>
      </footer>
    </>
  );
};

export default Footer;


=== ./components/frontend/Newsletter/index.tsx ===
'use client';
import React, { useState } from 'react';
import axiosInstance from '@/libs/axios';
import { toast } from 'react-toastify';



const Newsletter = ({ backgroundColor }: { backgroundColor?: string }) => {

    const emailRegex = /\S+@\S+\.\S+/;

    const [email, setEmail] = useState<string>("");

    const subscribe = async () => {
        try {

            if (!email || email === "") {
                return;
            }

            if (!emailRegex.test(email)) {
                return;
            }

            await axiosInstance.post("/api/contact/subscription", { email }).then((response) => {
                toast.success(response.data.message);
            });

        } catch (error) {
            console.error(error);
        }
    }

    return (
        <div className={"py-16 px-6" + (backgroundColor ? " " + backgroundColor : " bg-base-200")}>
            <div className="max-w-5xl mx-auto text-center">
                <h2 className="text-5xl font-bold mb-6">Subscribe to my newsletter</h2>
                <p className="text-base">Stay up to date! Get all the latest & greatest posts delivered straight to your inbox</p>
                <div className="mt-12 flex items-center overflow-hidden rounded-md max-w-xl mx-auto">
                    <input
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                        type="email" placeholder="Enter your email" className="w-full bg-transparent py-3.5 px-4 text-base focus:outline-none bg-base-100 border border-primary focus:border-primary rounded p-12" />
                    <button
                        onClick={subscribe}
                        className="button bg-primary text-white text-base font-bold rounded-r-md h-12 px-6 border-primary border-l-0">
                        Subscribe
                    </button>
                </div>
            </div>
        </div>
    );
};

export default Newsletter;

=== ./components/frontend/Navbar/index.tsx ===
'use client';
import React, { useState, useEffect } from 'react';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faBars, faCode } from '@fortawesome/free-solid-svg-icons';
import Link from 'next/link';
import Menu from '../Menu';
import ThemeButton from './Partials/ThemeButton';
import LangButton from './Partials/LangButton';

import dynamic from 'next/dynamic';
import { usePathname,useRouter } from 'next/navigation';
import Logo from '@/components/common/Logo';

const AuthButton = dynamic(
    () => import('./Partials/AuthButton'),
    { ssr: false }
);


const Navbar = () => {


    const path = usePathname();
    const router = useRouter();

    const [isTopReached, setIsTopReached] = useState(true);


    useEffect(() => {
        const handleScroll = () => {
            if (window?.scrollY > 40) {
                setIsTopReached(false);
            } else {
                setIsTopReached(true);
            }
        };

        window?.addEventListener("scroll", handleScroll);

        return () => {
            window?.removeEventListener("scroll", handleScroll);
        };
    }
        , []);



    const scrollTo100IfNot = () => {
        if (window?.scrollY < 60) {
            window?.scrollTo(0, 60);
        }
    }


    return (
        <div
            className={"fixed top-0 z-50 w-full transition-all duration-300 ease-in-out " +
                (isTopReached ? " pl-2  sm:px-6 lg:px-8 pt-3 pb-6" : " px-0 pt-0 pb-6")}

            style={{ zIndex: 60, width: "100%" }}
        >
            <div
                className={
                    "navbar rounded-full shadow-lg border border-base-200 self-center	" +
                    (isTopReached ? " rounded-full bg-transparent backdrop-blur-lg" : " rounded-none from-base-100 to-base-300 bg-gradient-to-b")
                }
            >
                <div className="flex-none xl:hidden">
                    <label htmlFor="my-drawer" aria-label="open sidebar" className="btn btn-circle btn-ghost" onClick={scrollTo100IfNot}>
                        <FontAwesomeIcon
                            icon={faBars}
                            style={{ width: "24px", height: "24px" }}
                        />
                    </label>
                </div>
                <div className="mx-2 flex-1 px-2 text-lg font-semibold">
                    <Logo/>
 
                    <div className="items-center gap-2 ml-1">
                        <ThemeButton />
                        <LangButton />
                        
                    </div>
                </div>
                <div className="hidden flex-none xl:block">
                    <ul className="menu menu-horizontal gap-1 hidden lg:flex">
                        {/* Navbar menu content here */}
                        <Menu />
                    </ul>
                </div>
                <div className="">
                    <ul className="menu menu-horizontal gap-1">
                        <AuthButton />
                    </ul>
                </div>
            </div>
        </div >
    );
};

export default Navbar;

=== ./components/frontend/Navbar/Partials/LangButton.tsx ===
import React, { useState, useEffect } from "react";
import { CircleFlag } from "react-circle-flags";
import useGlobalStore from "@/libs/zustand";
import { useTranslation } from "react-i18next";

const LangButton = () => {
  const [hasMounted, setHasMounted] = useState(false);

  const { language, setLanguage, availableLanguages } = useGlobalStore();
  const { i18n } = useTranslation();

  const languageFlags = {
    en: "us",
    tr: "tr",
    de: "de",
    gr: "gr",
    et: "ee",
    mt: "mt",
    th: "th",
  };

  const nextLanguage = (e: React.MouseEvent<HTMLButtonElement>) => {
    e.preventDefault();
    e.stopPropagation();
    const currentIndex = availableLanguages.indexOf(language);

    const nextLang =
      currentIndex === -1 || currentIndex === availableLanguages.length - 1
        ? availableLanguages[0]
        : availableLanguages[currentIndex + 1];

    setLanguage(nextLang);
  };

  useEffect(() => {
    if (hasMounted) return;

    const currentLanguage = useGlobalStore.getState().language;
    if (i18n.language !== currentLanguage) {
      i18n.changeLanguage(currentLanguage);
    }
    setHasMounted(true);
  }, [i18n, hasMounted]);

  useEffect(() => {
    if (!hasMounted) return;

    i18n.changeLanguage(language);
  }, [language, i18n, hasMounted]);

  return (
    <button
      className="btn btn-square btn-ghost rounded-full items-center justify-center duration-300"
      onClick={nextLanguage}
    >
      <CircleFlag
        height="24"
        width="24"
        countryCode={languageFlags[language as keyof typeof languageFlags] ?? "us"}
      />
    </button>
  );
};

export default LangButton;


=== ./components/frontend/Navbar/Partials/ThemeButton.tsx ===
'use client';
import React, { useEffect } from "react";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import {
  faMoon,
  faSun,
} from "@fortawesome/free-solid-svg-icons";
import { useGlobalStore } from "@/libs/zustand";

const ThemeButton = () => {
  const { theme, setTheme, availableThemes } = useGlobalStore();

  const themeIcons = {
    "dark": faMoon,
    "light": faSun,
  };

  const nextTheme = () => {
    const currentIndex = availableThemes.indexOf(theme);

    var nextTheme: string;

    switch (currentIndex) {
      case -1:
        nextTheme = availableThemes[0];
        break;
      case availableThemes.length - 1:
        nextTheme = availableThemes[0];
        break;
      default:
        nextTheme = availableThemes[currentIndex + 1];
        break;
    }
    setTheme(nextTheme);
  }

  useEffect(() => {
    switch (theme) {
      case "dark":
        document.querySelector("html")?.setAttribute("data-theme", "dark");
        break;
      case "light":
        document.querySelector("html")?.setAttribute("data-theme", "light");
        break;
      default:
        //document.querySelector("html")?.setAttribute("data-theme", "dark");
        break;
    }
  }, [theme]);

  return (
    <button
      className="btn btn-square btn-ghost rounded-full items-center justify-center grayscale duration-300 hover:grayscale-0"
      onClick={nextTheme}

    >
      <FontAwesomeIcon
        icon={themeIcons[theme as keyof typeof themeIcons] ? themeIcons[theme as keyof typeof themeIcons] : faMoon}
        style={{ width: "24px", height: "24px" }}
      />
    </button>
  );
};

export default ThemeButton;


=== ./components/frontend/Navbar/Partials/AuthButton.tsx ===
'use client'
import React, { useEffect } from "react";
import { faGear, faRightFromBracket, faUser } from "@fortawesome/free-solid-svg-icons";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import Link from "next/link";
import useGlobalStore from "@/libs/zustand";
import { UserRole } from "@prisma/client";

const AuthButton = () => {
    const { user } = useGlobalStore();


    if (!user) {
        return (
            <Link href="/auth/login" className="bg-primary text-white rounded-full p-2 w-10 h-10 flex items-center justify-center hidden md:flex">
                <div className="">
                    <FontAwesomeIcon icon={faUser} className="" />
                </div>
            </Link>
        );
    }

    return (
        <Link href="/auth/logout" className="bg-primary text-white rounded-full p-2 w-10 h-10 flex items-center justify-center">
            <div className="">
                <FontAwesomeIcon icon={faRightFromBracket} className="" />
            </div>
        </Link>
    );
};

export default AuthButton;


=== ./components/frontend/Hero/Projects/index.tsx ===
'use client';
import React, { useState } from 'react';
import {
  faAnglesDown,
  faAnglesUp,
} from "@fortawesome/free-solid-svg-icons";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";

//i18n
import { useTranslation } from "react-i18next";

import SingleProject from './Partials/SingleProject'
import { useRouter } from 'next/navigation'
import { Project } from '@prisma/client';
import axiosInstance from '@/libs/axios';

const ProjectsHero = () => {

  const allowedFilters = [
    'ui/ux',
    'web',
    'mobile',
    'desktop',
    'embedded',
    'other',
    'iot',
    'gaming',
    'machine learning'
  ];

  const { t } = useTranslation()
  const [filter, setFilter] = useState("");

  const [expanded, setExpanded] = React.useState(false);
  const container = React.useRef(null);

  const [search, setSearch] = React.useState('');
  const [projects, setProjects] = React.useState<Project[]>([]);
  const [page, setPage] = React.useState(0);
  const [pageSize, setPageSize] = React.useState(100);
  const [total, setTotal] = React.useState(0);

  const router = useRouter();

  React.useEffect(() => {

    axiosInstance.get("/api/projects" + `?page=${page + 1}&pageSize=${pageSize}&search=${search}&sort=desc&onlyPublished=true`)
      .then((response) => {
        setProjects(response.data.projects);
        setTotal(response.data.total);
      })
      .catch((error) => {
        console.error(error);
      });
  }
    , [page, pageSize, search]);


  const continueOnGitHub: Project = {
    projectId: '',
    title: 'Other Projects',
    description: 'For other projects, check my GitHub profile. You can find various projects that I have worked on.',
    slug: 'not-slug',
    image: "/assets/img/projects/github-wallpaper-scaled.webp",
    status: '',
    platforms: [],
    technologies: [],
    content: '',
    createdAt: new Date(),
    updatedAt: new Date(),
    projectLinks: [
      'https://github.com/kuraykaraaslan/'
    ]
  }

  const filteredProjects = projects.filter((project) => {
    if (filter === "") {
      return true;
    }
    return project.platforms.includes(filter);
  });


  const handleClick = () => {
    // get container current height
    const panel = container?.current as unknown as HTMLElement;

    if (panel === null) return;

    //make height is auto
    panel.style.height = expanded ? "560px" : `${panel.scrollHeight + 80}px`;

    //toggle the state
    setExpanded(!expanded);
  };


  return (
    <>
      <section className="bg-base-200 pt-16" id="portfolio">
        <div
          className="px-4 mx-auto max-w-screen-xl lg:pb-16 lg:px-6 duration-1000"
          style={{ height: "560px", overflow: "clip" }}
          ref={container}
        >
          <div className="mx-auto max-w-screen-sm text-center lg:mb-8 -mt-8 lg:mt-0 ">
            <h2 className="mb-4 text-3xl lg:text-4xl tracking-tight font-extrabold">
              {t("projects.title")}
            </h2>
            <p className="font-light sm:text-xl">
              {t("projects.description")}
            </p>
          </div>

          <div className="flex flex-wrap justify-center gap-4 mb-8 mt-3">
            <button
              className={`btn btn-primary ${filter === "" ? "btn-active" : ""}`}
              onClick={() => setFilter("")}
            >
              all
            </button>
            {allowedFilters.map((tag, index) => (
              <button
                key={index}
                className={`btn btn-primary ${filter === tag ? "btn-active" : ""}`}
                onClick={() => setFilter(tag)}
              >
                {tag}
              </button>
            ))}
          </div>

          <div className="grid gap-8 lg:grid-cols-3 mt-8">
            {filteredProjects.map((project: Project, index: number) => (
              <SingleProject key={index}
                project={project} />
            ))}
            <SingleProject key={filteredProjects.length}
              project={continueOnGitHub} />
          </div>

        </div>

        <div
          className="flex carousel-indicators gap-2 bg-transparent select-none"
          style={{
            zIndex: 8,
            position: "relative",
            left: "0",
            right: "0",
            margin: "auto",
            height: "0px",
            width: "100%",
            bottom: "20",
            display: "flex",
            justifyContent: "center",
          }}
        >
          <div
            className="flex carousel-indicators gap-2 bg-gradient-to-b from-base-200/20 to-base-300"
            style={{
              zIndex: 8,
              position: "relative",
              left: "0",
              right: "0",
              margin: "auto",
              height: "80px",
              width: "100%",
              display: "flex",
              justifyContent: "center",
              transform: "translateY(-80px)",
            }}
          >
            {!expanded ? (
              <button
                className="flex flex-col items-center gap-2 animate-bounce"
                style={{ height: "80px", width: "130px" }}
                onClick={handleClick}
              >
                <FontAwesomeIcon
                  icon={faAnglesDown}
                  style={{
                    width: "2.0rem",
                    height: "2.0rem",
                  }}
                />{" "}
                <span>{expanded ? "Show Less" : "Show More"}</span>
              </button>
            ) : (
              <button
                className="flex flex-col items-center gap-2"
                style={{ height: "80px", width: "130px" }}
                onClick={handleClick}
              >
                <FontAwesomeIcon
                  icon={faAnglesUp}
                  style={{ width: "2.0rem", height: "2.0rem" }}
                />{" "}
                <span>{expanded ? "Show Less" : "Show More"}</span>
              </button>
            )}
          </div>
        </div>
        
      </section>
    </>
  );
};


export default ProjectsHero;

=== ./components/frontend/Hero/Projects/Partials/SingleProject.tsx ===
// SingleProject.tsx
import React, { use } from "react";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { IconDefinition, faGlobe } from "@fortawesome/free-solid-svg-icons";
import { faGithub } from "@fortawesome/free-brands-svg-icons";
import Link from "next/link";
import { Project } from "@prisma/client";
import Image from 'next/image';
import SingleLink from "./SingleLink";
import SingleTag from "./SingleTag";


const SingleProject = ({ project }: { project: Project }) => {
  return (
    <article
      className={`rounded-lg border from-base-100 to-base-300 bg-gradient-to-b shadow-lg border-base-200 text-base-900`}
    >
      <div className="shadow-md rounded-t-lg">
        <Image
          width="1000"
          height="1000"
          unoptimized={true}
          src={project.image ? project.image : ""}
          alt={project.title}
          className="w-full h-48 object-cover object-top rounded-t-lg"
        /> 
      </div>
      <div className="pt-6 px-6 flex items-center mb-5 text-black">
        {project.technologies.map((tag, index) => (
          <SingleTag technology={tag} key={index} />
        ))}
        
        </div>
      <h2 className="px-6 mb-2 text-2xl font-bold tracking-tight">
        <Link href="">{project.title}</Link>
      </h2>
      <p className="px-6 mb-5 font-light">{project?.description!.substring(0, 250)}...</p>
      <div className="px-6 pb-6 flex justify-between items-center">
        <div className="flex items-center space-x-4">
          {project.projectLinks.map((link, index) => (
            <SingleLink  url={link} key={index} />
          ))}   
        </div>
      </div>
    </article>
  );
};

export default SingleProject;


=== ./components/frontend/Hero/Projects/Partials/SingleTag.tsx ===
import React from 'react';

import {
    faReact,
    faBootstrap,
    faHtml5,
    faPython,
    faPhp,
    faJava,
    faJs,
    faAmazon,
    faAndroid,
    faChrome,
    faOpera,
    faApple,
    faGithub,
    faGit,
    faNodeJs,
    faAws,
    faGoogle,
  } from "@fortawesome/free-brands-svg-icons";
  import {
    faAnchor,
    faAnglesDown,
    faAnglesUp,
    faCloud,
    faCode,
    faFire,
    faGear,
    faGlobe,
    faMobileScreenButton,
    faTv,
    faWind,
    IconDefinition,
  } from "@fortawesome/free-solid-svg-icons";
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';


const SingleTag = ({ technology } : { technology: string }) => {

    const allowedTechnologies = [
        'react',
        'react native',
        'express',
        'next',
        'java',
        'python',
        'c',
        'c++',
        'c#',
        'aws',
        'azure',
        'gcp',
        'chrome extension',
        'other'
    ];

    const data: { [key: string]: { name: string, color: string, icon: IconDefinition, bgColor: string } } = {
        'react': { name: 'React', color: 'text-[#000000]', icon: faReact, bgColor: "bg-[#61DBFB]" },
        'react native': { name: 'React Native', color: 'text-[#000000]', icon: faReact, bgColor: "bg-[#61DBFB]" },
        'express': { name: 'Express', color: 'text-[#FFFFFF]', icon: faNodeJs, bgColor: "bg-[#68A063]" },
        'next': { name: 'Next.js', color: 'text-[#FFFFFF]', icon: faReact, bgColor: "bg-[#000000]" },
        'java': { name: 'Java', color: 'text-[#FFFFFF]', icon: faJava, bgColor: "bg-[#007396]" },
        'python': { name: 'Python', color: 'text-[#000000]', icon: faPython, bgColor: "bg-[#3776AB]" },
        'c': { name: 'C', color: 'text-[#FFFFFF]', icon: faCode, bgColor: "bg-[#A8B9CC]" },
        'c++': { name: 'C++', color: 'text-[#FFFFFF]', icon: faCode, bgColor: "bg-[#00599C]" },
        'c#': { name: 'C#', color: 'text-[#FFFFFF]', icon: faCode, bgColor: "bg-[#178600]" },
        'aws': { name: 'AWS', color: 'text-[#232F3E]', icon: faAws, bgColor: "bg-[#FF9900]" },
        'azure': { name: 'Azure', color: 'text-[#FFFFFF]', icon: faCloud, bgColor: "bg-[#0078D7]" },
        'gcp': { name: 'GCP', color: 'text-[#FFFFFF]', icon: faGoogle, bgColor: "bg-[#4285F4]" },
        'chrome extension': { name: 'Chrome Extension', color: 'text-[#000000]', icon: faChrome, bgColor: "bg-[#4285F4]" }
    };

    return (
        <span
            key={technology}
            className={`text-xs font-medium me-2 px-2.5 pt-0.5 pb-1 rounded flex items-center ${data[technology] ? data[technology].color : "text-base-900"} ${data[technology] ? data[technology].bgColor : "bg-[#f7f7f7]"}`}
        >
            <FontAwesomeIcon
                icon={data[technology] ? data[technology].icon : faGlobe}
                style={{
                    width: "1rem",
                    height: "1rem",
                    marginRight: "0.25rem",
                    paddingTop: "0.25rem",
                }}
            />
            <span className="text-sm hidden lg:block">{data[technology] ? data[technology].name : technology}</span>
        </span>
    );
};

export default SingleTag;

=== ./components/frontend/Hero/Projects/Partials/SingleLink.tsx ===
import React from 'react';
import Link from 'next/link';
import {
  faReact,
  faBootstrap,
  faHtml5,
  faPython,
  faPhp,
  faJava,
  faJs,
  faGithub,
  faGitlab,
  faGooglePlay,
  faYoutube,
  faLinkedin,
  faTwitter,
  faInstagram,
  faFacebook,
  faDiscord,
} from "@fortawesome/free-brands-svg-icons";
import {
  faGlobe,
  faFile,
  faCloud,
  IconDefinition,
} from "@fortawesome/free-solid-svg-icons";
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';

// Map URLs to icons and titles
const iconAndTitleMap: { pattern: RegExp; icon: IconDefinition; title: string }[] = [
  { pattern: /github\.com/, icon: faGithub, title: "GitHub" },
  { pattern: /gitlab\.com/, icon: faGitlab, title: "GitLab" },
  { pattern: /youtube\.com/, icon: faYoutube, title: "YouTube" },
  { pattern: /linkedin\.com/, icon: faLinkedin, title: "LinkedIn" },
  { pattern: /twitter\.com/, icon: faTwitter, title: "Twitter" },
  { pattern: /instagram\.com/, icon: faInstagram, title: "Instagram" },
  { pattern: /facebook\.com/, icon: faFacebook, title: "Facebook" },
  { pattern: /discord\.com/, icon: faDiscord, title: "Discord" },
  { pattern: /react/, icon: faReact, title: "React" },
  { pattern: /html/, icon: faHtml5, title: "HTML5" },
  { pattern: /python/, icon: faPython, title: "Python" },
  { pattern: /php/, icon: faPhp, title: "PHP" },
  { pattern: /java/, icon: faJava, title: "Java" },
  { pattern: /javascript|js/, icon: faJs, title: "JavaScript" },
  { pattern: /cloud/, icon: faCloud, title: "Cloud Service" },
  { pattern: /file/, icon: faFile, title: "File Resource" },
  { pattern: /.*\..*/, icon: faGlobe, title: "Website" }, // Default for general websites
];

const SingleLink = ({ url }: { url: string }) => {
  // Find a matching icon and title based on the URL
  const match = iconAndTitleMap.find((entry) => entry.pattern.test(url));

  const icon = match?.icon || faGlobe; // Default icon
  const title = match?.title || "Link"; // Default title

  return (
    <Link
      href={url}
      className="inline-flex items-center font-medium hover:underline"
    >
      <FontAwesomeIcon
        icon={icon}
        style={{
          width: "1rem",
          height: "1rem",
          marginRight: "0.25rem",
          paddingTop: "0.25rem",
        }}
      />
      {title}
    </Link>
  );
};

export default SingleLink;


=== ./components/frontend/Hero/GitContributions/index.tsx ===
import React from "react";
import Link from "next/link";
import { faGithub } from "@fortawesome/free-brands-svg-icons";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";

import HeatMap from "./Partial/HeatMap";


const GitContributions = () => {

    return (
        <>
            <div className="hero min-h-screen bg-base-100 hidden lg:flex items-center justify-center">
                <div className="hero-content text-center">
                    <div className="">
                        <h1 className="text-5xl font-bold">
                        a unstoppable developer
                        </h1>
                        <p className="py-6">
                        After switching to the software industry, I continued to develop without a break. 
                        </p>
                        <HeatMap />
                        <div className="flex justify-center py-6">
                            <Link href="https://github.com/kuraykaraaslan">
                                <button className="btn btn-primary">
                                   <FontAwesomeIcon icon={faGithub} className="mr-2 text-xl" height="20" width="20" />
                                    View my GitHub profile
                                </button>
                            </Link>
                        </div>
                    </div>
                </div>
            </div>
        </>
    );
};

export default GitContributions;


=== ./components/frontend/Hero/GitContributions/Partial/HeatMap.tsx ===
'use client';
import React, { useEffect, Suspense, useState } from "react";
import axiosInstance from "@/libs/axios";
import  { ContributionDay, Week, Weeks, GraphQLRes } from "@/types/GitTypes";

const HeatMap = () => {

    const [weeks, setWeeks] = useState<Weeks>([]); 

    
    useEffect(() => {
        axiosInstance.get("/api/sections/github").then((response) => {
            const data: GraphQLRes = response.data;
            setWeeks(data.user.contributionsCollection.contributionCalendar.weeks);
        }).catch((error) => {
            console.error(error);
        });

        if (weeks.length === 0) {
            return;
        }

    }, []);



    return (
        <div className="flex flex-col items-center justify-center">
            <div id="contributions" className="flex gap-1">
                {weeks.map((week, i) => {
                    return (
                        <div key={i} className="relative grid grid-row-7 space-y-1">
                            {week?.contributionDays.map((day, j) => {
                                const isToday = day.date === new Date().toISOString().slice(0, 10);
                                return (
                                    <div key={j} className="relative w-4 h-4 bg-base-200 border border-base-200 shadow"
                                    title={`${day.date} - ${day.contributionCount} contributions`} >
                                        <div
                                            className="absolute w-4 h-4 bg-base-200"
                                            style={{
                                                opacity: day.date === "0" ? 0 : 1,
                                            }}
                                        ></div>
                                        <div
                                            className={"absolute w-4 h-4 bg-primary " + (isToday ? "animate-pulse" : "")}
                                            style={{
                                                opacity: isToday ? 1 : day.date === "0" ? 0 : day.contributionCount / 3,
                                            }}
                                        ></div>
                                    </div>

                                );
                            })}

                        </div>
                    );
                })}
            </div>
        </div>
    );
};


export default HeatMap;

=== ./components/frontend/Hero/Contact/index.tsx ===

"use client";

import { useState, useEffect, useRef } from "react";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faEnvelope, faPhone } from "@fortawesome/free-solid-svg-icons";
import {
  faXTwitter,
  faLinkedin,
  faTelegram,
  faFacebook,
  faInstagram,
  faWhatsapp,
} from "@fortawesome/free-brands-svg-icons";
import { CircleFlag } from "react-circle-flags";

import dynamic from "next/dynamic";
import Link from "next/link";

//axios
import axios from "axios";

//reCAPTCHA
import ReCAPTCHA from "react-google-recaptcha";
import { useTranslation } from "react-i18next";

const recaptchaSiteKey = process.env.RECAPTCHA_CLIENT_KEY || "";

const Form = dynamic(
  () => import("./Partials/Form"),
  { ssr: false },
);

interface Phone {
  CountryCode: string;
  PhoneNumber: string;
  noSpacePhoneNumber: string;
  hasTelegram: boolean;
  hasWhatsapp: boolean;
}

interface Mail {
  mail: string;
}

interface ContactProps {
  bsckgroundColor?: string;
}

const Contact = (props: ContactProps) => {

  const { t, i18n } = useTranslation()

  const [phoneNumbers, setPhoneNumbers] = useState<Phone[]>([]);
  const [mails, setMails] = useState<Mail[]>([]);
  const [token, setToken] = useState<string>("x");

  const recaptchaRef = useRef<ReCAPTCHA>(null);

  useEffect(() => {
    const token = recaptchaRef.current?.getValue();
    setToken(token as string);
  }
    , []);

  useEffect(() => {
    if (token === "") {
      return;
    }
    getMails();
  }
    , [token]);


  const getPhoneNumbers = async () => {

    if (token === "") {
      alert(t("alert.can_not_verify_that_you_are_not_a_robot"));
      return;
    }

    if (phoneNumbers.length === 0) {
      axios.get("/api/contact/info/phone").then((response) => {
        setPhoneNumbers(response.data.phones);
      });
    }



  }

  function getMails() {

    if (token === "") {
      alert(t("alert.can_not_verify_that_you_are_not_a_robot"));
      return;
    }

    if (mails.length === 0) {
      axios.get("/api/contact/info/mail").then((response) => {
        setMails(response.data.mails);
      });
    }


  }



  return (
    <>
      {/* <section className="md:bg-base-100 bg-base-200 px-4 py-8  md:px-20" id="contact"> */}
      <section className={"min-h-screen md:pt-24 " + (props.bsckgroundColor ? props.bsckgroundColor : "bg-base-100")}
        id="contact">
        {/* <div className="container px-2 py-8 mx-auto mx-4 md:px-24 md:bg-base-200 mt-0 md:-mt-24 rounded-box shadow-2xl border-full border-2 border-black contactHero"> */}
        <div className="container  mx-auto mx-4 mt-0 md:rounded-box md:shadow-2xl border-full md:border-2 md:border-black contactHero">
          <div className="mx-4 md:mx-8 pt-2 rounded-box md:mb-4">
            <div className="grid max-w-6xl grid-cols-1 px-6 mx-auto lg:px-8 md:grid-cols-2 md:divide-x pt-12 pb-12 mb-2">
              <div className="py-6 md:py-0 md:px-6">
                <h1 className="text-4xl font-bold">
                  {t("contact.title")}
                </h1>

                <p className="pt-2 pb-4">
                  {t("contact.description")}
                </p>
                <div className="space-y-4">
                  <h3 className="text-xl font-bold">
                    {t("contact.phone_and_mail")}
                  </h3>

                  {token !== "" ?
                    <>
                      {mails?.length === 0 &&
                        <button className="flex transform transition-transform duration-500 hover:scale-105" onClick={getMails}>
                          <FontAwesomeIcon
                            icon={faEnvelope}
                            className="w-5 h-5 mr-2 sm:mr-6"
                          />
                          <span>{t("contact.reveal_mail")}</span>
                        </button>
                      }

                      {mails?.map((mail, index) => (
                        <p key={index} className="flex">
                          <FontAwesomeIcon
                            icon={faEnvelope}
                            className="w-5 h-5 mr-2 sm:mr-6"
                          />
                          <Link
                            href={"mailto:" + mail.mail}
                            target="_blank"
                            rel="noopener noreferrer"
                          >
                            <span>{mail.mail}</span>
                          </Link>
                        </p>
                      ))}

                      {phoneNumbers.length === 0 &&
                        <button className="flex transform transition-transform duration-500 hover:scale-105" onClick={getPhoneNumbers}>
                          <FontAwesomeIcon
                            icon={faPhone}
                            className="w-5 h-5 mr-2 sm:mr-6"
                          />
                          <span>{t("contact.reveal_phone")}</span>
                        </button>
                      }

                      {phoneNumbers.map((phone, index) => (
                        <p key={index} className="flex">
                          <CircleFlag
                            countryCode={phone.CountryCode}
                            className="rounded-full w-5 h-5 mr-2 sm:mr-6"
                          />
                          <Link
                            href={"tel:" + phone.noSpacePhoneNumber}
                            target="_blank"
                            rel="noopener noreferrer"
                          >
                            <span>{phone.PhoneNumber}</span>
                          </Link>
                          <span className="ml-2">
                            {phone.hasWhatsapp &&
                              <Link href={"https://wa.me/" + phone.noSpacePhoneNumber}>
                                <FontAwesomeIcon
                                  icon={faWhatsapp}
                                  className="w-5 h-5 mr-2 sm:mr-3"
                                />
                              </Link>
                            }
                            {phone.hasTelegram &&
                              <Link href={"https://t.me/" + phone.noSpacePhoneNumber}>
                                <FontAwesomeIcon
                                  icon={faTelegram}
                                  className="w-5 h-5 mr-2 sm:mr-3"
                                />
                              </Link>
                            }
                          </span>
                        </p>
                      ))
                      }
                    </>
                    :
                    <>
                      <ReCAPTCHA
                        ref={recaptchaRef}
                        size="normal"
                        sitekey={recaptchaSiteKey}
                      />
                    </>
                  }



                </div>

                <div className="space-y-4 mt-4">
                  <h3 className="text-xl font-bold">
                    {t("contact.social_media")}
                  </h3>

                  <p className="flex items-center text-green-500 animate-pulse">
                    <FontAwesomeIcon
                      icon={faWhatsapp}
                      className="w-5 h-5 mr-2 sm:mr-6"
                    />
                    <Link
                      href="https://wa.me/905459223554"
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      <span>Whatsapp</span>
                    </Link>
                  </p>

                  <p className="flex items-center">
                    <FontAwesomeIcon
                      icon={faTelegram}
                      className="w-5 h-5 mr-2 sm:mr-6"
                    />
                    <Link
                      href="https://t.me/kuraykaraaslan"
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      <span>Telegram</span>
                    </Link>
                  </p>

                  <p className="flex items-center">
                    <FontAwesomeIcon
                      icon={faLinkedin}
                      className="w-5 h-5 mr-2 sm:mr-6"
                    />
                    <Link
                      href="https://www.linkedin.com/in/kuraykaraaslan"
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      <span>LinkedIn</span>
                    </Link>
                  </p>

                  <div className="flex items-center">
                    <FontAwesomeIcon
                      icon={faXTwitter}
                      className="w-5 h-5 mr-2 sm:mr-6"
                    />
                    <Link
                      href="https://twitter.com/kuraykaraaslan"
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      <span>X</span>
                    </Link>
                  </div>
                  <div className="flex items-center">
                    <FontAwesomeIcon
                      icon={faFacebook}
                      className="w-5 h-5 mr-2 sm:mr-6"
                    />
                    <Link
                      href="https://www.facebook.com/kuraykaraaslan"
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      <span>Facebook</span>
                    </Link>
                  </div>
                  <div className="flex items-center">
                    <FontAwesomeIcon
                      icon={faInstagram}
                      className="w-5 h-5 mr-2 sm:mr-6"
                    />
                    <Link
                      href="https://www.instagram.com/kuraykaraaslan"
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      <span>Instagram</span>
                    </Link>
                  </div>
                </div>
              </div>
              <div className="flex flex-col py-6 space-y-6 md:py-0 md:px-6">
                <h1 className="text-4xl font-bold">
                  {t("contact.send_a_message")}
                </h1>
                <Form token={token} />
              </div>
            </div>
          </div>
        </div>
      </section>
    </>
  );
};

export default Contact;


=== ./components/frontend/Hero/Contact/Partials/Form.tsx ===
'use client';
import React, { useEffect, useState } from "react";
import axios from "axios";
import './styles/phoneInput.css';
import PhoneInput, { isValidPhoneNumber } from 'react-phone-number-input';

//Fontawesome
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faHourglass, faMessage } from "@fortawesome/free-solid-svg-icons";
import i18n from "@/libs/localize/localize";


const DISCORD_WEBHOOK_URL = process.env.DISCORD_WEBHOOK_URL;

interface CountryCode extends String {
  name: string;
  dialCode: string;
  countryCode: string;
}



// @ts-ignore
const ContactForm = (props: { className?: string; token: string }) => {

  const { t } = i18n;
  //React states
  const [token, setToken] = useState<string>("");
  const [name, setName] = useState<string>("");
  const [email, setEmail] = useState<string>("");
  const [phone, setPhone] = useState<any>("");
  const [message, setMessage] = useState<string>("");

  //Validation states

  const [isEmailValid, setIsEmailValid] = useState<boolean>(true);
  const [isPhoneValid, setIsPhoneValid] = useState<boolean>(true);
  const [isNameValid, setIsNameValid] = useState<boolean>(true);
  const [isMessageValid, setIsMessageValid] = useState<boolean>(true);

  //Get country code
  const [geoInfo, setGeoInfo] = useState<any>([]);
  const [defaultCountry, setDefaultCountry] = useState<any>(undefined);

  //Timer 
  const [isSending, setIsSending] = useState<boolean>(false);

  function getCountry() {
    axios.get('https://ipapi.co/json/').then((response) => {
      let data = response.data;
      setGeoInfo(data);
      setDefaultCountry(data.country);

    }).catch((error) => {
    });
  }

  useEffect(() => {
    if (geoInfo.length > 0) {
      return;
    }
    getCountry();
  }, []);


  const claases = props.className;

  const onEmailChange = (e: any) => {
    setEmail(e.target.value);
    const regex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    setIsEmailValid(regex.test(e.target.value));
  }

  const onPhoneChange = (value: any) => {
    setPhone(value);
    setIsPhoneValid(isValidPhoneNumber(value || ""));
  };


  const onNameChange = (e: any) => {
    setName(e.target.value);
    const regex = /^[a-zA-Z\sçÇğĞıİöÖşŞüÜ]{3,50}$/; // Modify the regex pattern to include Turkish characters
    setIsNameValid(regex.test(e.target.value));
  }

  const onMessageChange = (e: any) => {
    setMessage(e.target.value);
    // minimum 10 characters , maximum 500 characters, no sql injection
    const regex = /^[a-zA-Z0-9\s\WçÇğĞıİöÖşŞüÜ]{10,500}$/; // Modify the regex pattern to include Turkish characters

    setIsMessageValid(regex.test(e.target.value));

  }

  async function formSubmit() {
    const date = new Date();

    // Boşluk kontrolü
    const isNameOk = /^[a-zA-Z\sçÇğĞıİöÖşŞüÜ]{3,50}$/.test(name);
    const isEmailOk = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(email);
    const isPhoneOk = isValidPhoneNumber(phone || "");
    const isMessageOk = /^[a-zA-Z0-9\s\WçÇğĞıİöÖşŞüÜ]{10,500}$/.test(message);

    setIsNameValid(isNameOk);
    setIsEmailValid(isEmailOk);
    setIsPhoneValid(isPhoneOk);
    setIsMessageValid(isMessageOk);

    if (!token) {
      alert(t("contact.can_not_verify_that_you_are_not_a_robot"));
      return;
    }

    if (!isNameOk || !isEmailOk || !isPhoneOk || !isMessageOk) {
      alert(t("contact.form.please_fill_in_all_fields"));
      return;
    }

    setIsSending(true);

    const data = {
      name,
      email,
      phone,
      message,
      date,
    };

    try {
      await axios.post("/api/contact/form", data, {
        headers: {
          "Content-Type": "application/json"
        }
      });

      setIsSending(false);
      alert(t("contact.form.success"));
    } catch (error) {
      setIsSending(false);
      alert(t("contact.form.error"));
    }
  }



  useEffect(() => {
    const token = props.token;
    setToken(token as string);
  }
    , []);


  return (
    <div className={claases}>
      <div className="mt-2">
        <label htmlFor="name" className="block mb-2 text-sm font-medium ">
          {t("contact.form.name")}
        </label>
        <input
          type="text"
          id="name"
          className={"block p-3 w-full text-sm rounded-lg border border-1 border-gray-500 bg-gray-200 text-black " + (isNameValid ? "" : "text-red-500")}
          placeholder={t("contact.form.enter_your_name")}
          required
          onChange={onNameChange}
        />
      </div>
      <div className="mt-2">
        <label htmlFor="email" className="block mb-2 text-sm font-medium">
          {t("contact.form.email")}
        </label>
        <input
          type="email"
          id="email"
          className={"block p-3 w-full text-sm rounded-lg border border-1 bg-gray-200 text-black " + (isEmailValid ? "" : "text-red-500")}
          placeholder={t("contact.form.enter_your_email")}
          required
          onChange={onEmailChange}
        />
      </div>
      <div className="mt-2">
        <label htmlFor="phone" className="block mb-2 text-sm font-medium">
          {t("contact.form.phone")}
        </label>
        <PhoneInput
          international
          className={"block pl-3 w-full text-sm rounded-lg border border-1 border-gray-500 bg-gray-200 text-black " + (isPhoneValid ? "" : "text-red-500")}
          placeholder={t("contact.form.enter_your_phone")}
          required
          // @ts-ignore
          defaultCountry={defaultCountry ? defaultCountry as string : "TR"}
          onChange={onPhoneChange}
        />
      </div>
      <div className="mt-2">
        <label htmlFor="message" className="block mb-2 text-sm font-medium">
          {t("contact.form.message")}
        </label>
        {/* @ts-ignore */}
        <textarea
          id="message"
          className={"block p-2.5 w-full text-sm rounded-lg border border-1 border-gray-500 min-h-[150px] bg-gray-200 resize-none text-black " + (isMessageValid ? "" : "text-red-500")}
          placeholder={t("contact.form.enter_your_message")}
          required
          onChange={onMessageChange}
        ></textarea>
      </div>
      {isSending ?
        <button
          type="submit"
          disabled
          className="mt-2 py-3 px-5 text-sm font-medium bg-base-300 rounded-lg hover:text-white focus:outline-none focus:bg-primary-600 border border-1 border-gray-500 light:placeholder-black"
        >
          <FontAwesomeIcon icon={faHourglass} spin className="w-3 h-3 mr-2" />
          {t("contact.form.loading")}
        </button>
        : <button
          type="submit"
          className="mt-2 py-3 px-5 text-sm font-medium bg-base-300 rounded-lg hover:text-white focus:outline-none focus:bg-primary-600 border border-1 border-gray-500 light:placeholder-black"
          onClick={formSubmit}
        >
          <FontAwesomeIcon icon={faMessage} className="w-3 h-3 mr-2" />
          {t("contact.form.send")}
        </button>
      }
    </div>
  );
};

export default ContactForm;


=== ./components/frontend/Hero/Testimonials/index.tsx ===
import Testimonial from "@/types/Testimonial";
import SingleTestimonial from "./Partials/SingleTestimonial";

const Testimonials = () => {

  const testimonials = [
    {
      id: 1,
      name: "Michael Harris",
      title: "Founder at Bright Ventures",
      review: "We couldn't have asked for a better experience. The complex API integrations and custom features were delivered with precision. The professionalism and commitment to quality made a huge impact on our business.",
    },
    {
      id: 2,
      name: "Sarah Miller",
      title: "CTO at NextGen Solutions",
      review: "A true expert in software engineering who transformed our vision into reality. The technical expertise and understanding of our complex requirements made a huge difference in the success of our project.",
    },

    {
      id: 3,
      name: "Ahmet Yılmaz",
      title: "CTO at Akıllı Sistemler A.Ş.",
      review: "The software development process was seamless, and the e-commerce platform delivered exceeded our expectations. The attention to detail and ability to meet deadlines were impressive. Highly recommend for any technical project.",
    },
    {
      id: 4,
      name: "James Roberts",
      title: "Product Manager at Stellar Apps",
      review: "Kuray provided invaluable assistance in scaling our mobile app. His knowledge in React Native and backend development allowed us to launch ahead of schedule. His professionalism and problem-solving skills set him apart.",
    }
  ] as Testimonial[];

  return (
    <section className="bg-base-300 md:px-24">
      <div className="container px-6 py-4 mx-auto mx-4 pb-0 md:pb-20">
        <div className="grid items-center gap-4 xl:grid-cols-5">
          <div className="max-w-2xl mx-auto my-8 space-y-4 text-center xl:col-span-2 xl:text-left">
            <h2 className="text-4xl font-bold">What People Say</h2>
            <p className="">
            I've worked with some amazing people and companies. Here's what they have to say about me.
            </p>
          </div>
          <div className="p-6 xl:col-span-3 pt-0">
            <div className="grid gap-4 md:grid-cols-2">
              <div className="grid content-center gap-4">
                {testimonials.map((testimonial) => {
                  if (testimonial.id <= 2) {
                    return <SingleTestimonial key={testimonial.id} testimonial={testimonial} />;
                  }
                })}
              </div>
              <div className="grid content-center gap-4">
                {testimonials.map((testimonial) => {
                  if (testimonial.id > 2) {
                    return <SingleTestimonial key={testimonial.id} testimonial={testimonial} />;
                  }
                })}
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  );
};

export default Testimonials;


=== ./components/frontend/Hero/Testimonials/Partials/SingleTestimonial.tsx ===
import Testimonial from "@/types/Testimonial";

const SingleTestimonial = ({ testimonial }: { testimonial: Testimonial }) => {
    return (
      <div className="p-6 rounded shadow-md bg-base-100">
        <p>{testimonial.review}</p>
        <div className="flex items-center mt-4 space-x-4">
          <div className="w-12 h-12 bg-center bg-cover rounded-full bg-base-500">
            <div className="flex items-center justify-center w-full h-full text-2xl font-bold rounded-full">
              {testimonial.name[0]}
            </div>
          </div>
          <div>
            <p className="text-lg font-semibold">{testimonial.name}</p>
            <p className="text-sm">{testimonial.title}</p>
          </div>
        </div>
      </div>
    );
  }

export default SingleTestimonial;

  

=== ./components/frontend/Hero/Services/index.tsx ===
"use client";
import React from "react";
import {
  faApple,
  faAndroid,
  faReact,
  faPhp,
  faJava
} from "@fortawesome/free-brands-svg-icons";
import {
  faDesktop,
  faGlobe,
  faWind,
} from "@fortawesome/free-solid-svg-icons";

import SingleService, { Service } from "./Partials/SingleService";

const Services = () => {

  const [expanded, setExpanded] = React.useState(true);
  const container = React.useRef(null);


  const projects: Service[] = [
    {
      id: "1",
      image: "/assets/img/services/phone.jpg",
      title: "Mobile App Development",
      description:
        "I develop mobile applications for both Android and iOS platforms. i use the latest technologies and tools to deliver high-quality applications.",
      urls: [
      ],
      tags: [
        { name: "Android", color: "bg-green-200", icon: faAndroid },
        { name: "Apple", color: "bg-blue-200", icon: faApple },
        { name: "React Native", color: "bg-blue-200", icon: faReact },
      ],
    },
    {
      id: "2",
      image: "/assets/img/services/web.jpg",
      title: "Web Development",
      description:
        "I can help you build a website or web app using React, Next.js that looks great on all devices.",        
      urls: [
      ],
      tags: [
        { name: "React", color: "bg-blue-200", icon: faReact },
        { name: "Web", color: "bg-yellow-200", icon: faGlobe },
        { name: "Desktop", color: "bg-yellow-200", icon: faDesktop },
      ],
    },
    {
      id: "3",
      image: "/assets/img/services/admin.jpg",
      title: "Backend Development",
      description:
        "Have a project that requires a backend? I can help you build a scalable and secure backend using Node.js, Express, and Postgresql.",
      urls: [],
      tags : [
        { name: "Node.js", color: "bg-green-200", icon: faWind },
        { name: "PHP", color: "bg-purple-200", icon: faPhp },
        { name: "Java", color: "bg-red-200", icon: faJava }
      ]
    },
    {
      id: "4",
      image: "/assets/img/services/other2.jpg",
      title: "Something Else",
      bgColor: "bg-base-200",
      description:
        "I  can help you with your custom software development needs. Contact us to discuss your project. like setting up a CI/CD pipeline, writing tests, or deploying your app.",
      urls: [],
      tags: []
    }
  ];

  return (
    <>
      <section className="bg-base-100 pt-16" id="projects">
        <div
          className="px-4 mx-auto max-w-screen-xl lg:pb-16 lg:px-6 duration-1000"
          ref={container}
        >
          <div className="mx-auto max-w-screen-sm text-center lg:mb-16 mb-8 -mt-8 lg-mt-0">
            <h2 className="mb-4 text-3xl lg:text-4xl tracking-tight font-extrabold">
            My Services
            </h2>
            <p className="font-light sm:text-xl">i offer a wide range of services to help you build your dream project.</p>
          </div>
          <div className="grid gap-8 lg:grid-cols-2">
            {projects.map((service: Service) => (
              <SingleService key={service.id} service={service} />
            ))}
          </div>
        </div>

        <div
          className="flex carousel-indicators gap-2 bg-transparent select-none"
          style={{
            zIndex: 50,
            position: "relative",
            left: "0",
            right: "0",
            margin: "auto",
            height: "0px",
            width: "100%",
            bottom: "20",
            display: "flex",
            justifyContent: "center",
          }}
        >
        </div>
      </section>
    </>
  );
};

export default Services;

=== ./components/frontend/Hero/Services/Partials/SingleService.tsx ===
// SingleProject.tsx
import React from "react";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { IconDefinition, faGlobe } from "@fortawesome/free-solid-svg-icons";
import { faGithub } from "@fortawesome/free-brands-svg-icons";
import Link from "next/link";
import Image from 'next/image';

export type Url = {
  type?: "GitHub" | "Demo" | "Other";
  title?: string;
  icon?: IconDefinition;
  url: string;
};

export type Tag = {
  name: string;
  color: string;
  icon: IconDefinition;
};

export type Service = {
  id: string;
  image: string;
  title: string;
  description: string;
  urls: Url[];
  tags: Tag[];
  bgColor?: string;
  borderColor?: string;
  textColor?: string;
};

type SingleProjectProps = {
  service: Service;
};

const SingleProject: React.FC<SingleProjectProps> = ({ service }) => {

  if (!service) {
    return null;
  }

  return (
    <article id="services"
      className={`rounded-lg select-none border shadow-md min-h-80 ${service.bgColor ? service.bgColor : "bg-base-200"} ${service.borderColor ? service.borderColor : "border-base-200"} ${service.textColor ? service.textColor : "text-base-900"}`}
    >
      <Image src={service.image} alt={service.title} className="w-full h-48 object-cover rounded-t-lg" width={1000} height={1000} />
      <div className="flex flex-col mt-5 p-6">
        <div className="mb-2 flex items-center text-black">
          {service.tags.map((tag) => (
            <span
              key={tag.name}
              className={`text-xs font-medium me-2 px-2.5 pt-0.5 pb-1 rounded flex items-center ${tag.color}`}
            >
              <FontAwesomeIcon
                icon={tag.icon}
                style={{
                  width: "1rem",
                  height: "1rem",
                  marginRight: "0.25rem",
                  paddingTop: "0.25rem",
                }}
              />
              <span className="text-sm hidden lg:block">{tag.name}</span>
            </span>
          ))}
        </div>
        <h2 className="mb-2 text-2xl font-bold tracking-tight">
          <Link href="#" style={{ pointerEvents: "none" }}
          >{service.title}</Link>
        </h2>
        <p className="mb-5 font-light">{service.description}</p>
        <div className="flex justify-between items-center">
          <div className="flex items-center space-x-4">
            {service.urls.map((url) => (
              <Link
                key={url.url}
                href={url.url}
                className="inline-flex items-center font-medium hover:underline"
              >
                <FontAwesomeIcon
                  icon={
                    url.icon
                      ? url.icon
                      : url.url.startsWith("https://github.com")
                        ? faGithub
                        : faGlobe
                  }
                  style={{
                    width: "1rem",
                    height: "1rem",
                    marginRight: "0.25rem",
                    paddingTop: "0.25rem",
                  }}
                />
                {url.title
                  ? url.title
                  : url.type === "GitHub"
                    ? "GitHub"
                    : "Demo"}
              </Link>
            ))}
          </div>
        </div>
      </div>
    </article>
  );
};

export default SingleProject;


=== ./components/frontend/Hero/Platforms/index.tsx ===
'use client';
import React from 'react';
import SinglePlatform from './Partials/SinglePlatform';

const Platforms = (props: any) => {



    const  platforms = [
        {
            name: "Fiveer",
            icon: "/assets/svg/fiverr.svg",
            url: "https://www.fiverr.com/kuraykaraaslan",
            bgColor: "bg-white",
        },
        {
            name: "Upwork",
            icon: "/assets/svg/upwork.svg",
            url: "https://www.upwork.com/freelancers/~01694c65c4ad50b809",
            bgColor: "bg-white",
        },
        {
            name: "bionluk",
            icon: "/assets/svg/bionluk.svg",
            url: "https://bionluk.com/uye/kuraykaraaslan",
            bgColor: "bg-white",
            zoom: 2,
        },
        {
            name: "armut",
            icon: "/assets/img/armut.png",
            url: "https://armut.com",
            bgColor: "bg-white",
        }
    ];


    return (
        <section className="py-12 bg-base-200 ">
            <div className="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
                <div className="mb-20 text-center">
                    <span className="text-center font-medium mb-4 block">Active on different platforms</span>
                    <h1 className="text-4xl text-center font-bold">I'm available on the following platforms. You can hire me on any of these platforms.</h1>
                </div>
                <div className="grid grid-cols-1 gap-8 md:grid-cols-2 xl:grid-cols-4">
                    {platforms.map((platform) => (
                        <SinglePlatform key={platform.name} {...platform} />
                    ))}
                    
                </div>
            </div>
        </section>

    );
};

export default Platforms;

=== ./components/frontend/Hero/Platforms/Partials/SinglePlatform.tsx ===
import React from 'react';
import Platform from '@/types/Platform';

const SinglePlatform = ({ name, icon, url, bgColor, borderColor, zoom }: Platform) => {

    return (
        <a href={url} target="_blank" rel="noreferrer p-4" 
            className={"flex justify-center items-center border border-solid duration-300	hover:scale-105 border-gray-200 shadow-sm h-24 rounded-2xl " + (bgColor ? bgColor : "bg-primary-100") + " " + (borderColor ? borderColor : "border-gray-200")}>
            <Image src={icon} alt={name} className={"h-" + (zoom ? 12 * zoom : 12) + " w-auto"} />
        </a>
    );
};

export default SinglePlatform;

=== ./components/frontend/Hero/Timeline/index.tsx ===
'use client';
import React from 'react';
import {
  faAnglesDown,
  faAnglesUp,
} from "@fortawesome/free-solid-svg-icons";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";

import TimelineItems from './Partials/TimelineItems';
import BackgroundImage from './Partials/BackgroundImage';
import { useTranslation } from 'react-i18next';

const Timeline = () => {

  const [expanded, setExpanded] = React.useState(false);
  const container = React.useRef(null);

  const { t } = useTranslation();


  const handleClick = () => {
    // get container current height
    const panel = container?.current as unknown as HTMLElement;

    if (panel === null) return;

    //make height is auto
    panel.style.height = expanded ? "560px" : `${panel.scrollHeight + 80}px`;

    //toggle the state
    setExpanded(!expanded);
  };

  return (
    <>
      <section className="relative bg-base-100 pt-16" id="timeline">
        <BackgroundImage />
        <div
          className="px-4 mx-auto max-w-screen-xl lg:pb-16 lg:px-6 duration-1000"
          style={{ height: "560px", overflow: "clip" }}
          ref={container}
        >
          <div className="mx-auto max-w-screen-sm text-center lg:mb-8 -mt-8 lg:mt-0 ">
            <h2 className="mb-4 text-3xl lg:text-4xl tracking-tight font-extrabold">
              {t("timeline.title")}
            </h2>
            <p className="font-light sm:text-xl">
              {t("timeline.description")}
            </p>
          </div>
          <div className="grid gap-8 lg:grid-cols-1">
            <TimelineItems />

          </div>

        </div>
        <div
          className="flex carousel-indicators gap-2 bg-transparent select-none"
          style={{
            zIndex: 8,
            position: "relative",
            left: "0",
            right: "0",
            margin: "auto",
            height: "0px",
            width: "100%",
            bottom: "20",
            display: "flex",
            justifyContent: "center",
          }}
        >
          <div
            className="flex carousel-indicators gap-2 bg-gradient-to-b from-base-200/20 to-base-300"
            style={{
              zIndex: 8,
              position: "relative",
              left: "0",
              right: "0",
              margin: "auto",
              height: "80px",
              width: "100%",
              display: "flex",
              justifyContent: "center",
              transform: "translateY(-80px)",
            }}
          >
            {!expanded ? (
              <button
                className="flex flex-col items-center gap-2 animate-bounce"
                style={{ height: "80px", width: "130px" }}
                onClick={handleClick}
              >
                <FontAwesomeIcon
                  icon={faAnglesDown}
                  style={{
                    width: "2.0rem",
                    height: "2.0rem",
                  }}
                />{" "}
                <span>{expanded ? "Show Less" : "Show More"}</span>
              </button>
            ) : (
              <button
                className="flex flex-col items-center gap-2"
                style={{ height: "80px", width: "130px" }}
                onClick={handleClick}
              >
                <FontAwesomeIcon
                  icon={faAnglesUp}
                  style={{ width: "2.0rem", height: "2.0rem" }}
                />{" "}
                <span>{expanded ? "Show Less" : "Show More"}</span>
              </button>
            )}
          </div>
        </div>
      </section>
    </>
  );
};

export default Timeline;


=== ./components/frontend/Hero/Timeline/Partials/TimelineItems.tsx ===
import { faBriefcase, faCheck, faUniversity } from '@fortawesome/free-solid-svg-icons';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import React from 'react';

const TimelineItems: React.FC = () => {
    return (
        <ul className="timeline timeline-snap-icon max-md:timeline-compact timeline-vertical pt-2">
            <li>
                <div className="timeline-middle bg-base-300 p-2 rounded-full">
                    <FontAwesomeIcon icon={faBriefcase} className="h-5 w-5" />
                </div>
                <div className="timeline-start mb-10 md:text-end mr-3 pl-3">
                    <time className="font-mono italic">2024 Feb - Present</time>
                    <div className="text-lg font-black">Software Developer <span className="text-sm italic font-normal">at</span> Roltek Technology</div>
                    <span className="text-sm max-w-2xl">
                        • Communication between IoT Devices and Servers using the MQTT, Websocket, SNMP, and REST. <br />
                        • Developing serverside application with Java Spring, deploying and maintenance. <br />
                        • Developing clientside application with Typescript React, deploying and maintenance. <br />
                        • Network management and monitoring. <br />
                    </span>
                </div>
                <hr />
            </li>
            <li>
                <hr />
                <div className="timeline-middle bg-base-300 p-2 rounded-full">
                    <FontAwesomeIcon icon={faBriefcase} className="h-5 w-5" />
                </div>
                <div className="timeline-end mb-10 ml-3">
                    <time className="font-mono italic">2021 Dec - 2023 Sep</time>
                    <div className="text-lg font-black">Structural Engineer <span className="text-sm italic font-normal">at</span> Kuray Yapı Construction</div>
                    <span className="text-sm">
                        • Developing turnkey construction projects. <br />
                        • Building Information Modeling (BIM) projects. <br />
                        • Architectural, Structural floor plans and details. <br />
                        • Interior architectural projects and applying them to the project. <br />
                        • Construction management and planning of the project. <br />
                    </span>

                </div>
                <hr />
            </li>
            <li>
                <hr />
                <div className="timeline-middle bg-base-300 p-2 rounded-full">
                   <FontAwesomeIcon icon={faBriefcase} className="h-5 w-5" />
                </div>
                <div className="timeline-start mb-10 md:text-end pl-3">
                <time className="font-mono italic">2020 Dec - 2021 Dec</time>
                    <div className="text-lg font-black">BIM Specialist <span className="text-sm italic font-normal">at</span> CADBIM</div>
                    <span className="text-sm">
                        • Building Information Modeling (BIM) consultancy services. <br />
                        • Autodesk AutoCAD, Revit, Robot Structural Analysis Professional, Advance Steel. <br />
                        • Application development with Autodesk API using C#, PHP Rest API. <br />
                    </span>
                </div>
                <hr />
            </li>
            <li>
                <hr />
                <div className="timeline-middle bg-base-300 p-2 rounded-full">
                    <FontAwesomeIcon icon={faUniversity} className="h-5 w-5" />
                </div>
                <div className="timeline-end mb-10 ml-3">
                    <time className="font-mono italic">2015 Sep - 2021 Feb</time>
                    <div className="text-lg font-black">Civil Engineering <span className="text-sm italic font-normal">at</span> Dokuz Eylül University</div>
                </div>
            </li>
        </ul>
    );
};

export default TimelineItems;

=== ./components/frontend/Hero/Timeline/Partials/BackgroundImage.tsx ===
"use client";
import React, {
  useState,
  useEffect,
  useRef,
} from "react";
import Image from "next/image";

function BackgroundImage() {
  return (
    <div className="absolute top-0 left-0 z-0 w-full h-full bg-black opacity-20">
      <Image src="/assets/img/heros/view1.webp" layout="fill" objectFit="cover" alt="Hero Background" />
    </div>
  );
}

export default BackgroundImage;

=== ./components/frontend/Hero/HireMe/index.tsx ===
'use client';
import React, { useState, useEffect } from 'react';
import dynamic from 'next/dynamic';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faPlayCircle, faCircleNodes } from '@fortawesome/free-solid-svg-icons';
import Link from 'next/link';
import WorldMap from "react-svg-worldmap";

const HireMeVideo = dynamic(
  () => import("./Partials/HireMeVideo"),
  { ssr: false },
);

const HireMe = () => {

    const [dotColor, setDotColor] = useState("#ffffff");


  useEffect(() => {

    //detect theme change
    let html_theme = document.documentElement.getAttribute("data-theme");

    if (html_theme === "dark") {
      setDotColor("#ffffff");
    } else if (html_theme === "light") {
      setDotColor("#000000");
    } else {
      setDotColor("#ffffff");
    }
  }, []);

  const mapProps = {
    data: [],
    size: 300,
    backgroundColor: "transparent",
    strokeColor: "#fff",
    color: "white",
    styleFunction: (context: any) => {
      return {
        fill: "bg-primary",
        stroke: context.color,
        strokeWidth: 0.5
      };
    },
    tooltipTextFunction: (context: any) => {
      return `${context.countryName}: XXX ${context.countryValue}`;
    },
  };


  return (
    <>
      <div className="relative bg-base-200 min-h-screen">
        <video muted loop autoPlay className="absolute inset-0 z-0 object-cover w-full h-screen opacity-25">
          <source src="/assets/videos/freelance-welcome.mp4" type="video/mp4" />
        </video>
        <div
          className="hero min-h-screen select-none"
          id="#home"
          style={{
            zIndex: 8,
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            position: "relative",
          }}
        >
          <div className="hero-content">
            <div className="flex-1 max-w-2xl">
              <div className="max-w-lg mr-4">
                <h1 className="text-5xl font-bold">Seamless Freelance Experience</h1>
                <p className="py-6">
                Have a project in mind? Let's work together to make it a reality.
                </p>
                {/* @ts-ignore */}
                <HireMeVideo />
                <Link className="btn btn-primary" href="/freelance#services">
                  <FontAwesomeIcon icon={faCircleNodes} className="mr-2 text-xl w-6 h-6" />
                  My Services
                </Link>
              </div>
            </div>
            <div className="hidden lg:block max-w-md p-10 bg-primary">
              <WorldMap {...mapProps} />
            </div>
          </div>
        </div>
      </div>
    </>
  );
};

export default HireMe;

=== ./components/frontend/Hero/HireMe/Partials/HireMeVideo.tsx ===
'use client';
import React, { useEffect, createRef } from "react";
import ReactPlayer from 'react-player';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faPlayCircle } from '@fortawesome/free-solid-svg-icons';


const HireMeVideo: React.FC = () => {

    const [playing, setPlaying] = React.useState(false);
    const player = createRef<ReactPlayer>();

    const handleOpenModal = () => {
        const modal = document.getElementById("my_modal");

        if (!modal) {
            return;
        }

        // @ts-ignore
        document.getElementById("my_modal")?.showModal();
        // wait for the modal to open
        setTimeout(() => {
            player.current?.seekTo(0);
            setPlaying(true);
        }, 1000);
    }

    const handleCloseModal = () => {
        const modal = document.getElementById("my_modal");

        if (!modal) {
            return;
        }

        player.current?.seekTo(0);
        setPlaying(false);
        // @ts-ignore
        document.getElementById("my_modal")?.close();
        setPlaying(false);
    }


    return (
        <>
            <button className="btn btn-ghost mr-2" onClick={handleOpenModal}>
                <FontAwesomeIcon icon={faPlayCircle} className="mr-2 text-xl w-6 h-6" />
                Watch Video
            </button>
            <dialog id="my_modal" className="modal modal-middle" onClick={handleCloseModal}>
                <div className="modal-box p-0">
                    <ReactPlayer url="https://www.youtube.com/watch?v=eJO5HU_7_1w?modestbranding=1&rel=0&showinfo=0&autoplay=1" controls={true} width="100%" playing={playing} ref={player} />
                </div>
            </dialog>
        </>
    );
};

export default HireMeVideo;

=== ./components/frontend/Hero/Toolbox/index.tsx ===
"use client";
import {
  faHtml5,
  faPython,
  faPhp,
  faJava,
  faLinux,
  faFigma,
  faCss3,
  faSquareJs,
  faNodeJs,
  faReact,
} from "@fortawesome/free-brands-svg-icons";
import {
  faArchway,
  faCode,
  faCodeBranch,
  faDatabase,
  faLightbulb,
  faUsers,
  IconDefinition,
  faServer,
  faKey,
  faCodeMerge,
  faProjectDiagram,
  faRocket,
  faStream,
  faDrum,
  faMoneyBill,
  faCogs,
  faBugSlash,
  faTasks,
  faCircleCheck,
  faCircleXmark,
  faCloud,
  faVial,
} from "@fortawesome/free-solid-svg-icons";
import React from "react";

import SingleTool from "./Partials/SingleTool";
import SingleSkill from "./Partials/SingleSkill";
import Tool from "@/types/Tool";
import Skill from "@/types/Skill";
import { useTranslation } from "react-i18next";

const Toolbox = () => {


  const customTSIcon: IconDefinition = {
    prefix: 'fab',
    //@ts-ignore
    iconName: 'typescript',
    icon: [
      32,
      32,
      [],
      "f0c8",
      "M0 16v16h32v-32h-32zM25.786 14.724c0.813 0.203 1.432 0.568 2.005 1.156 0.292 0.312 0.729 0.885 0.766 1.026 0.010 0.042-1.38 0.974-2.224 1.495-0.031 0.021-0.156-0.109-0.292-0.313-0.411-0.599-0.844-0.859-1.505-0.906-0.969-0.063-1.594 0.443-1.589 1.292-0.005 0.208 0.042 0.417 0.135 0.599 0.214 0.443 0.615 0.708 1.854 1.245 2.292 0.984 3.271 1.635 3.88 2.557 0.682 1.031 0.833 2.677 0.375 3.906-0.51 1.328-1.771 2.234-3.542 2.531-0.547 0.099-1.849 0.083-2.438-0.026-1.286-0.229-2.505-0.865-3.255-1.698-0.297-0.323-0.87-1.172-0.833-1.229 0.016-0.021 0.146-0.104 0.292-0.188s0.682-0.396 1.188-0.688l0.922-0.536 0.193 0.286c0.271 0.411 0.859 0.974 1.214 1.161 1.021 0.542 2.422 0.464 3.115-0.156 0.281-0.234 0.438-0.594 0.417-0.958 0-0.37-0.047-0.536-0.24-0.813-0.25-0.354-0.755-0.656-2.198-1.281-1.651-0.714-2.365-1.151-3.010-1.854-0.406-0.464-0.708-1.010-0.88-1.599-0.12-0.453-0.151-1.589-0.057-2.042 0.339-1.599 1.547-2.708 3.281-3.036 0.563-0.109 1.875-0.068 2.427 0.068zM18.276 16.063l0.010 1.307h-4.167v11.839h-2.948v-11.839h-4.161v-1.281c0-0.714 0.016-1.307 0.036-1.323 0.016-0.021 2.547-0.031 5.62-0.026l5.594 0.016z"

    ],
  };

  const customRedisIcon: IconDefinition = {
    prefix: 'fab',
    //@ts-ignore
    iconName: 'redis',
    icon: [
      256, // width (viewBox genişliği)
      256, // height (viewBox yüksekliği, -18'lik offset yok sayıldı)
      [],
      "custom-drum-icon", // key (özelleştirilebilir bir identifier)
      "M245.97 168.943c-13.662 7.121-84.434 36.22-99.501 44.075-15.067 7.856-23.437 7.78-35.34 2.09-11.902-5.69-87.216-36.112-100.783-42.597C3.566 169.271 0 166.535 0 163.951v-25.876s98.05-21.345 113.879-27.024c15.828-5.679 21.32-5.884 34.79-.95 13.472 4.936 94.018 19.468 107.331 24.344l-.006 25.51c.002 2.558-3.07 5.364-10.024 8.988zM245.965 143.22c-13.661 7.118-84.431 36.218-99.498 44.072-15.066 7.857-23.436 7.78-35.338 2.09-11.903-5.686-87.214-36.113-100.78-42.594-13.566-6.485-13.85-10.948-.524-16.166 13.326-5.22 88.224-34.605 104.055-40.284 15.828-5.677 21.319-5.884 34.789-.948 13.471 4.934 83.819 32.935 97.13 37.81 13.316 4.881 13.827 8.9.166 16.02zM245.97 127.074c-13.662 7.122-84.434 36.22-99.501 44.078-15.067 7.853-23.437 7.777-35.34 2.087-11.903-5.687-87.216-36.112-100.783-42.597C3.566 127.402 0 124.67 0 122.085V96.206s98.05-21.344 113.879-27.023c15.828-5.679 21.32-5.885 34.79-.95 13.473 4.935 94.019 19.464 107.331 24.341l-.006 25.513c.002 2.557-3.07 5.363-10.024 8.987zM245.965 101.351c-13.661 7.12-84.431 36.218-99.498 44.075-15.066 7.854-23.436 7.777-35.338 2.087-11.903-5.686-87.214-36.112-100.78-42.594-13.566-6.483-13.85-10.947-.524-16.167C23.151 83.535 98.05 54.148 113.88 48.47c15.828-5.678 21.319-5.884 34.789-.949 13.471 4.934 83.819 32.933 97.13 37.81 13.316 4.88 13.827 8.9.166 16.02zM245.97 83.653c-13.662 7.12-84.434 36.22-99.501 44.078-15.067 7.854-23.437 7.777-35.34 2.087-11.903-5.687-87.216-36.113-100.783-42.595C3.566 83.98 0 81.247 0 78.665v-25.88s98.05-21.343 113.879-27.021c15.828-5.68 21.32-5.884 34.79-.95C162.142 29.749 242.688 44.278 256 49.155l-.006 25.512c.002 2.555-3.07 5.361-10.024 8.986zM245.965 57.93c-13.661 7.12-84.431 36.22-99.498 44.074-15.066 7.854-23.436 7.777-35.338 2.09C99.227 98.404 23.915 67.98 10.35 61.497-3.217 55.015-3.5 50.55 9.825 45.331 23.151 40.113 98.05 10.73 113.88 5.05c15.828-5.679 21.319-5.883 34.789-.948 13.471 4.935 83.819 32.934 97.13 37.811 13.316 4.876 13.827 8.897.166 16.017zM159.283 32.757l-22.01 2.285-4.927 11.856-7.958-13.23-25.415-2.284 18.964-6.839-5.69-10.498 17.755 6.944 16.738-5.48-4.524 10.855 17.067 6.391zM131.032 90.275L89.955 73.238l58.86-9.035-17.783 26.072zM74.082 39.347c17.375 0 31.46 5.46 31.46 12.194 0 6.736-14.085 12.195-31.46 12.195s-31.46-5.46-31.46-12.195c0-6.734 14.085-12.194 31.46-12.194zM185.295 35.998l34.836 13.766-34.806 13.753-.03-27.52zM146.755 51.243l38.54-15.245.03 27.519-3.779 1.478-34.791-13.752z"
    ]
  };

  const { t } = useTranslation();

  const backendTools = [
    {
      icon: faJava,
      hoverBgColor: "bg-red-500",
      title: "Java",
      description: "spring & swing",
      hoverTextColor: "text-black"
    },
    {
      icon: faNodeJs,
      hoverBgColor: "bg-green-500",
      title: "Node.js",
      description: "express & next",
      hoverTextColor: "text-black",
    },
    {
      icon: faPhp,
      hoverBgColor: "bg-purple-500",
      title: "PHP",
      description: "laravel",
      hoverTextColor: "text-black",
    },
    {
      icon: faLinux,
      hoverBgColor: "bg-yellow-500",
      title: "Linux",
      description: "server, bash",
      hoverTextColor: "text-black",
    },
  ] as Tool[];

  const frontendTools = [
    {
      icon: faReact,
      hoverBgColor: "bg-cyan-500",
      title: "React",
      description: "react & native & next",
      hoverTextColor: "text-black",
    },
    {
      icon: faCss3,
      hoverBgColor: "bg-blue-500",
      title: "CSS",
      description: "tailwind & scss",
      hoverTextColor: "text-black",
    },
    {
      icon: faHtml5,
      hoverBgColor: "bg-orange-500",
      title: "HTML",
      description: "semantic",
      hoverTextColor: "text-black",
    },
    {
      icon: faFigma,
      hoverBgColor: "bg-rose-500",
      title: "Figma",
      description: "design",
      hoverTextColor: "text-black",
    },
  ] as Tool[];

  const skillGroupColors = {
    fundamentals: {
      bgColor: "bg-cyan-700",
      textColor: "text-white",
    },
    backend: {
      bgColor: "bg-violet-700",
      textColor: "text-white",
    },
    advanced: {
      bgColor: "bg-emerald-700",
      textColor: "text-white",
    },
  };

  const professionalSkills: Skill[] = [
    {
      icon: faCode,
      title: "Clean Code",
      ...skillGroupColors.fundamentals,
    },
    {
      icon: faKey,
      title: "Authentication & Security",
      ...skillGroupColors.fundamentals,
    },
    {
      icon: faCogs,
      title: "REST API Design",
      ...skillGroupColors.backend,
    },
    {
      icon: faDatabase,
      title: "SQL & Data Modeling",
      ...skillGroupColors.backend,
    },
    {
      icon: faProjectDiagram,
      title: "Multi-Tenant SaaS",
      ...skillGroupColors.backend,
    },
    {
      icon: customRedisIcon,
      title: "Caching with Redis",
      ...skillGroupColors.backend,
    },
    {
      icon: faMoneyBill,
      title: "Payment Systems",
      ...skillGroupColors.backend,
    },
    {
      icon: faVial,
      title: "Testing & CI/CD",
      ...skillGroupColors.advanced,
    },
    {
      icon: faRocket,
      title: "Performance Optimization",
      ...skillGroupColors.advanced,
    },
    {
      icon: faCloud,
      title: "Cloud Infrastructure (AWS)",
      ...skillGroupColors.advanced,
    },
    {
      icon: faStream,
      title: "Event-Driven Architecture",
      ...skillGroupColors.advanced,
    },
    {
      icon: faArchway,
      title: "Domain-Driven Design",
      ...skillGroupColors.advanced,
    }
  ];



  return (
    <>
      <section className="hero bg-base-300 py-8 px-4 md:px-20 px-4 items-center justify-center align-middle min-h-screen">
        <div className="">
          <div className="grid grid-cols-2 md:grid-cols-6 gap-4 ">
            <div className="col-span-2 md:col-span-1 md:col-start-3 overflow-hidden">
              <h1 className="text-4xl lg:text-3xl font-bold mt-6 text-center md:text-right">
                {t("toolbox.title")}
              </h1>
            </div>
            <div className="col-span-1 md:col-start-4 invisible md:visible hidden md:block">
              <p className="mt-6 pr-4">
                {t("toolbox.description")}
              </p>
            </div>
          </div>

          <div className="grid grid-row-auto justify-items-center grid-row-1 md:grid-row-2 md:space-y-8 py-8 md:py-16">
            <div className="flex flex-col lg:flex-row-reverse md:mx-12 mx-auto">
              <div className="flex-1 pl-4 select-none hidden lg:block">
                <h1 className="text-3xl font-bold  relative overflow-hidden animate-shake pb-4">
                  Frontend
                </h1>
              </div>
              <div className="group flex-none grid grid-cols-2 md:grid-cols-4 gap-4 md:gap-8">
                {frontendTools.map((tool, index) => (
                  <SingleTool key={index} {...tool} />
                ))}
              </div>
            </div>
            <div className="group flex flex-col lg:flex-row md:mx-12 mx-auto pt-4">
              <div className="flex-0 lg:pl-0 select-none hidden lg:block pr-4">
                <h1 className="text-3xl font-bold  relative overflow-hidden animate-shake pb-4">
                  Backend
                </h1>
              </div>
              <div className="flex-none grid grid-cols-2 md:grid-cols-4 gap-4 md:gap-8">
                {backendTools.map((tool, index) => (
                  <SingleTool key={index} {...tool} />
                ))}
              </div>
            </div>
            <div className="w-50 h-50 group border-gray-500 border-t w-40 mt-8"></div>

            <div className="group flex-none grid grid-cols-3 md:grid-cols-6 gap-2 md:gap-8 mt-4">
              {professionalSkills.map((skill, index) => {
                // if key is bigger than 14 then hide on mobile
                if (index > 14) {
                  skill.className = skill.className + " hidden md:inline";
                }
                return (
                  <SingleSkill
                    key={index}
                    {...skill}
                  />
                );
              })}
            </div>
          </div>
        </div>
      </section>
    </>
  );
};

export default Toolbox;


=== ./components/frontend/Hero/Toolbox/Partials/SingleSkill.tsx ===
import React from "react";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import Skill from "@/types/Skill";

const SingleSkill: React.FC<Skill> = ({ icon, bgColor, title, textColor }) => {

  const isTextLong = title.length > 10;
  const textSize = isTextLong ? "text-sm" : "text-lg";
  
  return (
    <div className="w-28 h-20 group">
      <div
        className={`relative card w-28 h-20 from-base-100 to-base-300 bg-gradient-to-b shadow-lg relative select-none transition duration-500 transform group-hover:rotate-y-180 shadow-lg`}
      >
        <div className="flex flex-row items-center justify-center group-hover:rotate-y-180 h-full relative fixed w-28 h-20 top-0 left-0 absolute rounded-box">
          <figure className={`w-20 h-20 group-hover:hidden`}>
            <FontAwesomeIcon
              icon={icon}
              className="text-2xl flex group-hover:hidden"
            />
          </figure>
          <div className={"flex flex-col items-center justify-center hidden text-black group-hover:flex rotate-y-180 group-hover:rotate-y-0 w-28 h-20 top-0 left-0 absolute rounded-box " + (bgColor ? bgColor : "") + " " + (textColor ? textColor : "")}>
            <div className={"card-body items-center text-center duration-1000 ease-in-out transform "}>
              <h2 className={"card-title " + textSize + " " + (textColor ? textColor : "")}>

                {title}
              </h2>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default SingleSkill;


=== ./components/frontend/Hero/Toolbox/Partials/SingleTool.tsx ===
import React from "react";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { IconProp } from "@fortawesome/fontawesome-svg-core";
import Tool from "@/types/Tool";


const SingleTool: React.FC<Tool> = ({
  icon,
  title,
  description,
  hoverBgColor,
  hoverTextColor,
}) => {
  return (
    <div className="w-40 h-40 group">
      <div
        className={"relative card w-40 h-40 from-base-100 to-base-300 bg-gradient-to-b shadow-lg relative select-none transition duration-500 transform group-hover:rotate-y-180 px-2 py-2 shadow-lg "}
      >
        <div className="flex flex-col items-center justify-center group-hover:hidden">
          <figure className="px-10 pt-5 -mb-3">
            <FontAwesomeIcon icon={icon} className="text-8xl" />
          </figure>
        </div>
        <div className={"flex flex-col items-center justify-center hidden group-hover:flex rotate-y-180 w-40 h-40 top-0 left-0 absolute rounded-box " + (hoverBgColor ? hoverBgColor : "") + " " + (hoverTextColor ? hoverTextColor : "")}> 
          <figure className="px-10 pt-5 -mb-4">
            <FontAwesomeIcon
              icon={icon}
              className="text-4xl transition duration-500 hover:animate-spin"
            />
          </figure>
          <div className={"card-body items-center text-center duration-1000 ease-in-out "}>
            <h2 className="card-title">{title}</h2>
            <span className="text-xs">{description}</span>
          </div>
        </div>
      </div>
    </div>
  );
};

export default SingleTool;


=== ./components/frontend/Hero/Welcome/index.tsx ===
'use client'
import React, { Suspense } from "react";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faArrowRight, faLink } from "@fortawesome/free-solid-svg-icons";
import Link from "next/link";
import dynamic from "next/dynamic";
import MyImage from "./Partials/MyImageVideo";
import { Trans } from 'react-i18next';
import { useTranslation } from "react-i18next";


const TypingEffect = dynamic(
  () => import("./Partials/TypingEffect"),
  { ssr: false },
);
const BackgroundImage = dynamic(
  () => import("./Partials/BackgroundImage"),
  { ssr: false },
);

const Welcome = () => {

  const { t, i18n } = useTranslation(); // <- burada i18n de geliyor, t de geliyor

  return (
    <div className="relative bg-base-200"
      style={{
        height: "100dvh",
      }}
      id="home"
    >
      <BackgroundImage />
      <div
        className="hero min-h-screen select-none group"
        style={{
          zIndex: 2,
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          position: "relative",
        }}
      >
        <div className="hero-content">
          <div className="flex-1 max-w-2xl md:mr-4">
            <h1 className="font-bold relative overflow-hidden animate-shake text-4xl leading-normal h-24 md:h-16">
              <TypingEffect />
            </h1>
            <h2 className="py-3 pb-6 leading-7 text-shadow-sm">
              <p>
                <Trans
                  i18nKey="welcome.description"
                  lang={i18n.language}
                  components={{
                    bold: <span className="font-bold" />
                  }}
                />
              </p>
            </h2>

            <Link href="#contact" className="btn btn-primary hidden lg:inline-flex">
              <FontAwesomeIcon
                icon={faArrowRight}
                className="mt-1"
                style={{ width: "1rem" }}
              />
              {t("welcome.contact_me")}
            </Link>

            <Link href="https://drive.google.com/file/d/17Ya5AC2nvcvccN-bS2pFsKFIm5v8dcWN/view?usp=drive_link" target="_blank">
              <p className="btn btn-ghost ml-2 lowercase">
                <FontAwesomeIcon
                  icon={faLink}
                  className="mt-1"
                  style={{ width: "1rem" }}
                />
                {t("welcome.resume")}
              </p>
            </Link>
          </div>

          <MyImage />
        </div>
      </div>
    </div>
  );
};

export default Welcome;


=== ./components/frontend/Hero/Welcome/Partials/TypingEffect.tsx ===
'use client';
import i18n from "@/libs/localize/localize";
import React, { useState, useEffect } from "react";

const TypingEffect = () => {

  const { t } = i18n;

  const texts = [
    t("welcome.typingEffect.text1"),
    t("welcome.typingEffect.text2"),
    t("welcome.typingEffect.text3"),
    t("welcome.typingEffect.text4"),
    t("welcome.typingEffect.text5"),
    t("welcome.typingEffect.text6")
  ];

  const [textsIndex, setTextsIndex] = useState(0);
  const [letterIndex, setLetterIndex] = useState(0);
  const [isDeleting, setIsDeleting] = useState(false);
  const [renderedText, setRenderedText] = useState("");
  const [pause, setPause] = useState(false);


  useEffect(() => {
    const timeout = setTimeout(() => {

        if (letterIndex >= texts[textsIndex].length) {
          setIsDeleting(true);
        }

        if (letterIndex === 0) {
          setIsDeleting(false);
          if (isDeleting) {
            setTextsIndex((textsIndex + 1) % texts.length);
          }
        }

        if (letterIndex < 0) {
          setLetterIndex(0);
        }

        if (letterIndex > texts[textsIndex].length) {
          setLetterIndex(texts[textsIndex].length);
        }

        if (isDeleting && !pause) {
          const count = -1;
          setLetterIndex(letterIndex + count);
        } else if (!pause) {
          const count = 1;
          setLetterIndex(letterIndex + count);
        }

        /*
        const count = isDeleting ? -1 : 1;
        setLetterIndex(letterIndex + count);
        */
    
    }, 50);

    setRenderedText(texts[textsIndex].substring(0, letterIndex));

    return () => clearTimeout(timeout);
  }, [letterIndex, isDeleting, pause]);

  return (
    <span className="text-3xl font-bold text-shadow-sm">
      {t("welcome.typingEffect.prefix")}&nbsp;
      <span className="text-primary text-shadow-sm" onMouseEnter={() => setPause(true)} onMouseLeave={() => setPause(false)}>{renderedText === "" ? " " : renderedText}</span>
      &nbsp;
      {t("welcome.typingEffect.suffix")}
    </span>
  )
};

export default TypingEffect;


=== ./components/frontend/Hero/Welcome/Partials/BackgroundImage.tsx ===
"use client";
import React, {
  useState,
  useEffect,
  useRef,
} from "react";
import Image from "next/image";

function BackgroundImage() {
  return (
    <div className="absolute top-0 left-0 z-0 w-full h-full bg-black opacity-30 xl:opacity-20">
      <Image src="/assets/img/heros/welcome4.webp" layout="fill" objectFit="cover" alt="Hero Background" />
    </div>
  );
}

export default BackgroundImage;

=== ./components/frontend/Hero/Welcome/Partials/MyImageVideo.tsx ===
import dynamic from "next/dynamic";
const MyImageVideoDialog = dynamic(() => import("./MyImageVideoDialog"), { ssr: false });
import Image from 'next/image';

const MyImage = () => {

  return (
    <>
      <div className="relative flex-none hidden sm:block group">
        <div className="shadow-2xl max-w-24 sm:max-w-48 md:max-w-64 transition duration-500 transform bg-primary">
          <Image
            width="1000"
            height="1000"
            src="/assets/img/kuraykaraaslan.jpg"
            alt="kuray karaaslan"
            className="transition duration-500 transform shadow-2xl max-w-24 sm:max-w-48 md:max-w-64 transition duration-500 transform bg-primary"
          />
        </div>
        <div className="absolute top-0 shadow-2xl max-w-24 sm:max-w-48 md:max-w-64 transition duration-500 transform bg-transparent w-full h-full opacity-0 group-hover:opacity-100">
          <MyImageVideoDialog />
        </div>
      </div>
    </>
  );
};

export default MyImage;


=== ./components/frontend/Hero/Welcome/Partials/MyImage.tsx ===
import Image from 'next/image';

const MyImage = () => {

  return (
    <div className="relative flex-none hidden sm:block group">
      <div className="shadow-2xl max-w-24 sm:max-w-48 md:max-w-64 transition duration-500 transform group-hover:rotate-y-180 bg-primary">
        <Image
          width="0"
          height="0"
          src="/assets/img/kuraykaraaslan.jpg"

          alt="kuray karaaslan"
          className="transition duration-500 transform"
        />
      </div>
      <div className="absolute top-0 shadow-2xl max-w-24 sm:max-w-48 md:max-w-64 transition duration-500 transform rotate-y-180 group-hover:rotate-y-0 bg-primary w-full h-full opacity-0 group-hover:opacity-100">
        <div className="relative w-full h-full flex flex-col">
          <div className="fixed flex flex-col uppercase left-2 top-2">
            <span className="text-2xl font-bold text-black ml-[0.4rem]">
              A
            </span>
            <Image
              src="/assets/svg/spades.svg"
              alt="kuray karaaslan"
              className="h-8 w-8 transition"
            />
          </div>
          <div className="fixed flex flex-col uppercase mt-2 ml-2 right-2 bottom-2 transform rotate-180">
            <span className="text-2xl font-bold text-black ml-[0.4rem]">
              A
            </span>
            <Image
              src="/assets/svg/spades.svg"
              className="h-8 w-8 transition"
            />
          </div>

          <div className="relative flex flex-col items-center justify-center w-full h-full">
            <Image
              src="/assets/svg/spades.svg"
              className="h-16 w-16 transition"
            />
          </div>
        </div>

      </div>
    </div>
  );
};

export default MyImage;


=== ./components/frontend/Hero/Welcome/Partials/MyImageVideoDialog.tsx ===
'use client';
import { faPlayCircle } from "@fortawesome/free-solid-svg-icons";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import React, { createRef } from "react";
import ReactPlayer from "react-player";

const MyImage = () => {

  const [comingSoon, setComingSoon] = React.useState(false);

  const [playing, setPlaying] = React.useState(false);
  const player = createRef<ReactPlayer>();

  const handleOpenModal = () => {
    const modal = document.getElementById("my_video");

    if (!modal) {
      return;
    }

    // @ts-ignore
    document.getElementById("my_video")?.showModal();

    // wait for the modal to open
    setTimeout(() => {
      player.current?.seekTo(0);
      setPlaying(true);
    }, 1000);

  }

  const handleCloseModal = () => {
    const modal = document.getElementById("my_video");

    if (!modal) {
      return;
    }

    player.current?.seekTo(0);
    setPlaying(false);
    // @ts-ignore
    document.getElementById("my_video")?.close();
    setPlaying(false);
  }


  return (
    <>
      <div className="relative w-full h-full flex flex-col" onClick={handleOpenModal}>
        <FontAwesomeIcon icon={faPlayCircle} className="text-white w-16 h-16 m-auto" />
      </div>
      <dialog id="my_video" className="modal modal-middle" onClick={handleCloseModal}>
        <div className="modal-box p-0">
          {!comingSoon ?
          <ReactPlayer url="https://www.youtube.com/watch?v=oJN50oOlW-c?modestbranding=1&rel=0&showinfo=0&autoplay=1" controls={true} width="100%" playing={playing} ref={player} />
          : 
          <div className="w-full h-[200px] flex flex-col">
            <div className="m-auto">
              A video is coming soon! Stay tuned!
            </div>
          </div>
          }
        </div>
      </dialog>
    </>
  );
};

export default MyImage;


=== ./components/frontend/CategoryBullets/index.tsx ===
'use client';
import { useEffect, useState } from 'react';
import axiosInstance from '@/libs/axios';
import { Category } from '@prisma/client';
import Link from 'next/link';

export default function CategoryBullets() {

    const [categories, setCategories] = useState<Category[]>([]);
    const [page, setPage] = useState(0);
    const [pageSize, setPageSize] = useState(100);

    useEffect(() => {
        axiosInstance.get(`/api/categories?page=${page + 1}`)
            .then(response => {
                setCategories(response.data.categories);
            });

    }, [page]); // Make sure to include all dependencies that affect the API call

    return (
        <section className="bg-base-300 py-12" id="categories">
            <div
                className="px-4 mx-auto max-w-screen-xl duration-1000"
            >
                <div className="mx-auto text-center">
                    <h2 className="mb-8 hidden sm:block text-3xl lg:text-4xl tracking-tight font-extrabold">
                        Categories
                    </h2>
                </div>
                <div className="flex flex-wrap justify-center">
                    {categories.map((category) => (
                        <Link
                            key={category.categoryId}
                            href={"/blog/" + category.slug}
                            className="m-2 px-4 py-2 bg-primary text-white rounded-md"
                        >
                            {category.title}
                        </Link>
                    ))}
                </div>
            </div>

            
        </section>
    );
};


=== ./components/frontend/TerminalButton/index.tsx ===
'use client';
import React, { useEffect, useState } from "react";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faArrowUp, faTerminal } from "@fortawesome/free-solid-svg-icons";
import { faWhatsapp } from "@fortawesome/free-brands-svg-icons";
import { useRouter } from "next/navigation";

const TerminalButton = () => {

    const router = useRouter();

    useEffect(() => {
        const scrollToTopBtn = document.getElementById(
            "terminalButton",
        ) as HTMLElement;
        const main = document.getElementById("main");

        //make the button appear slowly when the user scrolls down 20px from the top to 500ms

        window?.addEventListener("scroll", () => {

            var totalWindowHeight = document.body.scrollHeight - window?.innerHeight;
            var aligned = window?.scrollY * 0.1 - 100; // Moved 20px up by subtracting 20 more
            if (aligned > 20) {
                aligned = 20;
            }
            scrollToTopBtn.style.right = aligned + "px";
            if (
                document.body.scrollTop > 20 ||
                document.documentElement.scrollTop > 20
            ) {
                scrollToTopBtn.style.display = "flex";
            } else {
                scrollToTopBtn.style.display = "none";
            }

            //if it is end of the page, for footer raise it up to 150px
            if (
                window?.innerHeight + window?.scrollY >=
                document.body.offsetHeight - 70
            ) {
                const diff =
                    window?.innerHeight + window?.scrollY - document.body.offsetHeight + 70;
                scrollToTopBtn.style.bottom = diff + 170 + "px";
            } else {
                scrollToTopBtn.style.bottom = "170px";
            }
        });
    });

            
    return (
        <div
            className="fixed transition duration-1000 ease-in-out bg-black text-white cursor-pointer shadow-lg rounded-full"
            style={{ zIndex: 103, right: "-80px", bottom: "150px" }}
            id="terminalButton"
            onClick={() => router.push("/easter/terminal")}
        >
            <div className="relative transition duration-1000 ease-in-out bg-black cursor-pointer p-4 rounded-full group">
                <FontAwesomeIcon
                    icon={faTerminal}
                    className="text-l text-white w-8 h-8 md:w-6 md:h-6"
                />
            </div>
        </div>

    );
}

export default TerminalButton;

=== ./components/frontend/Sidebar/index.tsx ===
'use client';
import React, { createRef } from 'react';
import styles from './Sidebar.module.css';
import Menu from '../Menu';


const Sidebar = () => {
  
  return (
    <div className="drawer-side"
      style={{ zIndex: 8 }}>
      <label htmlFor="my-drawer" aria-label="close sidebar" className="drawer-overlay"></label>
      <ul className="menu bg-base-200 w-80 pt-20 h-full">
        {/* Sidebar content here */}
        <Menu isSidebar={true} />
      </ul>
    </div>
  );
};

export default Sidebar;

=== ./components/frontend/AuthorHeader/index.tsx ===
// AuthorHeader.tsx
import React from "react";
import { SafeUser } from "@/types/UserTypes";

const NEXT_PUBLIC_APPLICATION_HOST = process.env.APPLICATION_HOST;

export default function AuthorHeader(author: Partial<SafeUser>) {
  const coverImage = author.headerImage
    ? author.headerImage
    : "/assets/img/heros/welcome4.webp";
  const profilePicture = author.profilePicture
    ? author.profilePicture
    : "/assets/img/emptyuser.png";

  return (
    <div className="relative max-w-none text-left mx-auto prose mb-8">
      {/* Cover */}
      <div className="relative h-48">
        <img
          src={coverImage}
          alt="Cover"
          className="w-full h-full object-cover "
        />

        {/* Profil resmi + yazı */}
        <div className="absolute -bottom-12 left-6 flex flex-col md:flex-row md:items-center md:space-x-4 space-y-2 md:space-y-0">
          <img
            src={profilePicture}
            alt={author.name || "Author"}
            className="w-24 h-24 md:w-28 md:h-28 rounded-full border-4 border-white shadow-md object-cover bg-base-100 drop-shadow"
          />
          <div>
            <h2 className="text-lg md:text-2xl font-bold drop-shadow text-base-200">
              {author.name}
            </h2>
          </div>
        </div>
      </div>
    </div>
  );
}


=== ./components/frontend/PostHeader/index.tsx ===
import React from 'react'
import Link from 'next/link'
import { PostWithData } from '@/types/BlogTypes'
import PostLike from './partials/PostLike'

const PostHeader = (post: PostWithData) => {
  const readTime = Math.ceil(post.content.split(' ').length / 200)

  return (
    <div className='max-w-none justify-center text-left mx-auto prose mb-8'>
      <div className='flex items-center'>
        <h1 className='text-3xl font-bold text-left mt-4 mb-4 mr-4'>{post.title}</h1>
        <PostLike postId={post.postId} />
      </div>
      <div className='text-sm flex items-center space-x-2'>
        <span>
          {post.createdAt
            ? new Date(post.createdAt).toLocaleDateString()
            : 'No Date'}
        </span>
        <Link href={'/blog/' + post.category.slug} className='text-primary'>
          {post.category.title}
        </Link>
        <span className='text-primary hidden md:inline'>•</span>
        <span className='hidden md:inline'>{post.views} views</span>
        <span className='text-primary'>•</span>
        <span>{readTime} min read</span>
        <span className='text-primary hidden md:inline'>•</span>
        <span className='hidden md:inline'>
          by{' '}
          <Link href={'/blog/user/' + post.authorId} className='text-primary'>
            {post.author.name}
          </Link>
        </span>
      </div>
    </div>
  )
}

export default PostHeader


=== ./components/frontend/PostHeader/partials/PostLike.tsx ===
'use client'
import { useState } from 'react'
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome'
import { faHeart as faHeartSolid } from '@fortawesome/free-solid-svg-icons'
import { faHeart as faHeartRegular } from '@fortawesome/free-regular-svg-icons'
import axiosInstance from '@/libs/axios'

export default function LikeButton ({ postId }: { postId: string }) {
  const [isLiked, setIsLiked] = useState(false)

  const toggleLike = async () => {
    setIsLiked(!isLiked)
    // Burada API çağrısı yapılabilir
    try {
      if (isLiked) {
        // Eğer zaten beğenildiyse, beğeniyi kaldır
        await axiosInstance
          .delete(`/api/posts/${postId}/like`)
          .then(response => {
            console.log('Like removed:', response.data)
          })
          .catch(error => {
            console.error('Error removing like:', error)
            setIsLiked(true) // Hata durumunda beğeni durumunu geri al
          })
      } else {
        // Eğer beğenilmediyse, beğeni ekle
        await axiosInstance
          .post(`/api/posts/${postId}/like`)
          .then(response => {
            console.log('Like added:', response.data)
          })
          .catch(error => {
            console.error('Error adding like:', error)
            setIsLiked(false) // Hata durumunda beğeni durumunu geri al
          })
      }
    } catch (error) {
      console.error('Like toggle error:', error)
      setIsLiked(!isLiked) // Hata durumunda eski duruma geri dön
    }
  }

  // Beğeni durumu değiştiğinde, API'den güncel beğeni durumunu çekmek isteyebilirsiniz

  return (
    <button onClick={toggleLike} className='flex items-center'>
      <FontAwesomeIcon
        icon={isLiked ? faHeartSolid : faHeartRegular}
        className={`text-2xl ${isLiked ? 'text-red-500' : 'text-gray-400'}`}
      />
    </button>
  )
}


=== ./components/frontend/RelatedArticles/index.tsx ===
'use client';
import React from 'react';

import SingleArticle from './Partials/SingleArticle';
import { PostWithData } from '@/types/BlogTypes';

import { useParams } from 'next/navigation';

const RelatedArticles = ({ categoryId }: { categoryId: string }) => {

    if (!categoryId) {
        return null;
    }

    const params = useParams();

    const articles: PostWithData[] = [
        {
            postId: "1",
            title: "Article 1",
            createdAt: new Date(),
            category: {
                categoryId: "1",
                slug: "category-1",
                title: "Category 1",
                description: null,
                keywords: [],
                image: null,
                createdAt: new Date()
            },
            content: '',
            authorId: '',
            description: null,
            slug: '',
            keywords: [],
            categoryId: '',
            image: null,
            status: '',
            views: 0,
            author: {
                userId: "1",
                name: "Author 1",
                profilePicture: null
            },
        }
    ];


    return (
        <section className="bg-base-100 " id="blog">
            <div
                className="mx-auto lg:pb-16 lg:px-6 duration-1000"
            >
                <div className="mx-auto text-start lg:mb-8 -mt-8 lg:mt-0 ">
                    <h4 className="mb-8 hidden sm:block text-3xl lg:text-4xl tracking-tight font-extrabold">
                        Related Articles
                    </h4>

                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                        {articles.map((article, index) => {
                            return <SingleArticle key={index} {...article} />
                        })}
                    </div>
                </div>
            </div>
        </section>
    );
};

export default RelatedArticles;

=== ./components/frontend/RelatedArticles/Partials/SingleArticle.tsx ===
'use client';
import React, { useEffect, useState } from 'react';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faCalendar, faCaretRight } from '@fortawesome/free-solid-svg-icons';
import Link from 'next/link';
import { PostWithData } from '@/types/BlogTypes';
import Image from 'next/image';


const SingleArticle = (props: PostWithData) => {

    const [dateText, setDateText] = useState("");
    const [image, setImage] = useState("");

    useEffect(() => {
        if (!props.createdAt) {
            return;
        }

        try {

            const today = new Date();
            if (props.createdAt.toDateString() === today.toDateString()) {
                setDateText("Today");
                return;
            }
            const diff = today.getTime() - new Date(props.createdAt).getTime();
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 7) {
                setDateText(props.createdAt.toDateString());
                return;
            } else if (days > 1) {
                setDateText(`${days} days ago`);
                return;
            } else if (days === 1) {
                setDateText("Yesterday");
                return;
            } else if (hours > 1) {
                setDateText(`${hours} hours ago`);
                return;
            } else if (hours === 1) {
                setDateText("An hour ago");
                return;
            } else if (minutes > 1) {
                setDateText(`${minutes} minutes ago`);
                return;
            } else if (minutes === 1) {
                setDateText("A minute ago");
                return;
            }
            setDateText("Just now");
        } catch (error) {
            console.error(error);
            setDateText("Just now");
        }
    }

        , [props.createdAt]);


    useEffect(() => {
        setImage(props.image! || props.category.image! || "");
    }, [props.image]);


    return (
        <div className={"from-base-100 to-base-300 bg-gradient-to-b grid grid-row-2 grid-cols-12 gap-4 shadow-md rounded-lg  bg-base-200 max-w-sm"}>
            <Link className="col-span-12 justify-center flex border-b-2 border-base-300 rounded-t-lg select-none h-60"
                href={"/blog/" + props.category.slug + "/" + props.slug}>
                {image ? <Image src={image}
                    width={1920} height={1080}
                    
                    alt="feed image" className="w-full object-cover rounded-t-lg" /> :
                    <div className="relative w-full h-60 bg-primary rounded-t-lg flex justify-center items-center bg-opacity-10">
                        {/*<Image src="/assets/img/blog-empty.png" alt="feed image" className="absolute h-full left-8 top-0 object-cover rounded-t-lg" />*/}
                    </div>}
            </Link>
            <div className="col-span-12 justify-center px-4">
                <Link className="text-primary" href={"/blog/" + props.category.slug + "/" + props.slug}>
                    <h3 className="text-xl font-bold">{props.title || "Title"}</h3>
                </Link>
                <p className="text-base mt-2">{props.description?.substring(0, 200) || "lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."}</p>
            </div>
            <div className="col-span-12 justify-between flex  px-4 pb-4">
                <div className="flex items-center">
                    <FontAwesomeIcon icon={faCalendar} className="w-4"
                    />
                    <p className="text-sm ml-2">{props.createdAt ? new Date(props.createdAt).toDateString() : dateText}</p>
                </div>
                <div className="flex items-center gap-1">
                    <Link href={"/blog/" + props.category.slug + "/" + props.slug}
                        className="text-primary">Read More
                    <FontAwesomeIcon icon={faCaretRight} className="text-primary mt-1" style={{ height: '1rem', width: '1rem' }} />
                    </Link>
                </div>
            </div>
        </div>
    );
};

export default SingleArticle;

=== ./components/frontend/SingleProject/index.tsx ===
//default article

import React from "react";
import { Project } from "@prisma/client";
import Image from "next/image";

export default function SingleProject(post: Partial<Project>) {

    const image = post.image || "/default-article.jpg";

    return (
        <div className="max-w-none justify-center text-left mx-auto px-4 lg:px-8 prose mb-8 pt-8">
            <div dangerouslySetInnerHTML={{ __html: post.content as string }}></div>
        </div>
    );
}

=== ./components/frontend/Comments/index.tsx ===
'use client';
import React , { useState , useEffect } from 'react';
import SingleComment from './Partials/SingleComment';
import { Comment } from '@prisma/client';
import crypto from 'crypto';
import AddComment from './Partials/AddComment';
import axiosInstance from '@/libs/axios';


const Comments = ({ postId }: { postId: string }) => {
    

    const [comments, setComments] = useState<Comment[]>([]);
    const [page, setPage] = useState(0);
    const [pageSize, setPageSize] = useState(10);

    const fetchComments = async () => {
        // Fetch comments for the post
        await axiosInstance.get(`/api/comments?postId=${postId}&page=${page +1}&pageSize=${pageSize}`).then((response) => {
            setComments(prevComments => [...prevComments, ...response.data.comments]);
        }).catch((error) => {
            console.error(error);
        });
    };


    useEffect(() => {

        fetchComments();
    }, [postId, page, pageSize]);


    return (
        <section className="antialiased">
            <div className="mx-auto">
                <div className="flex justify-between items-center mb-6">
                <h4 className="text-3xl font-bold text-left mt-4 mb-4">Comments ({comments.length})</h4>
                </div>
                <div className="mb-6">
                    <AddComment  postId={postId} />
                </div>

                {comments.map((comment) => {
                    const hash256email = crypto.createHash('md5').update(comment.email || '').digest('hex');
                    const gravatarUrl = `https://www.gravatar.com/avatar/${hash256email}`;
                    comment.email = null;
                    return <SingleComment key={comment.commentId} comment={comment} 
                    gravatarUrl={gravatarUrl} />
                })}
            </div>
        </section>
    );
};

export default Comments;

=== ./components/frontend/Comments/Partials/SingleComment.tsx ===
'use client';
import React, { useEffect } from 'react';
import { Comment } from '@prisma/client';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faEllipsis, faMessage } from '@fortawesome/free-solid-svg-icons';
import useGlobalStore from '@/libs/zustand';
import axiosInstance from '@/libs/axios';


const SingleComment = ({comment, gravatarUrl} : {comment: Comment, gravatarUrl: string}) => {

    const { session } = useGlobalStore();

    const user = session?.user;
    const isAdmin = user?.role === "ADMIN";

    const { content, createdAt, parentId, name, email } = comment;


    const handleReply = () => {
    }

    const handleDelete = async () => {
        await axiosInstance.delete(`/api/comments`, {
            data: {
                commentId: comment.commentId
            }
        }).then((response) => {
        }).catch((error) => {
            console.error(error);
        });
    }

    useEffect(() => {
        //role
    } , [session]);


    return (
        <>
            <div className={"p-6 text-base rounded-lg " + (parentId ? 'bg-base-200' : 'bg-base-300')}>
                <footer className="flex justify-between items-center mb-2">
                    <div className="flex items-center">
                        <p className="inline-flex items-center mr-3 text-sm font-semibold"><img
                            className="mr-2 w-6 h-6 rounded-full"
                            src={gravatarUrl} alt={name || 'Anonymous'} />{name || 'Anonymous'}</p>
                        <p className="text-sm">
                            {new Date(createdAt).toLocaleDateString()} {new Date(createdAt).toLocaleTimeString()}
                        </p>
                    </div>
                    {true &&
                    <details className="dropdown dropdown-end">
                        <summary className="btn btn-primary m-1"><FontAwesomeIcon icon={faEllipsis} className='w-4 h-4' /></summary>
                        <ul className="menu dropdown-content bg-base-100 rounded-box z-[1] w-52 p-2 shadow">
                            <li><button onClick={handleReply}>Reply</button></li>
                            <li><button onClick={handleDelete}>Delete</button></li>
                        </ul>
                    </details>
                    }
                </footer>
                <p className="pt-4 pb-4">
                    {content}
                </p>

                <div className="flex items-center mt-4 space-x-4 hidden">
                    <button type="button"
                        className="flex items-center text-sm font-medium">
                        <FontAwesomeIcon icon={faMessage} className='w-4 h-4' />
                        <span className="ml-1">Reply</span>
                    </button>
                </div>
            </div>
        </>
    );
};

export default SingleComment;

=== ./components/frontend/Comments/Partials/AddComment.tsx ===
'use client';
import axiosInstance from '@/libs/axios';
import React, { useState } from 'react';

const AddComment = ({ postId, parentId }: { postId: string, parentId?: string }) => {

    const [content, setContent] = useState('');
    const [name, setName] = useState('');
    const [email, setEmail] = useState('');


    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();

        // Validate
        if (!content || !name || !email) {
            alert('Please fill all fields');
            return;
        }

        // check if email is valid
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

        if (!emailRegex.test(email)) {
            alert('Please enter a valid email');
            return;
        }

        // Name should be at least 3 characters and max 50 characters
        if (name.length < 3 || name.length > 50) {
            alert('Name should be at least 3 characters and max 50 characters');
            return;
        }

        // Content should be at least 5 characters
        if (content.length < 5) {
            alert('Content should be at least 5 characters');
            return;
        }

        // Submit
        axiosInstance.post('/api/comments', {
            postId,
            name,
            email,
            content,
            parentId
        })
            .then(() => {
                alert('Comment posted successfully');
                setContent('');
                setName('');
                setEmail('');
            })
            .catch((error) => {
                console.error(error);
                alert('An error occurred');
            }
        );

    };

    return (
        <>
            <div className="mb-4">
                <div className="flex flex-col md:flex-row mb-4 md:space-x-4 space-y-4 md:space-y-0">
                    <input type="text" className="w-full text-sm bg-base-100  rounded-lg rounded-t-lg border border-primary h-12"
                        value={name} onChange={(e) => setName(e.target.value)}
                        placeholder="Name" required />
                    <input type="email" className="w-full text-sm bg-base-100  rounded-lg rounded-t-lg border border-primary h-12"
                        value={email} onChange={(e) => setEmail(e.target.value)}
                        placeholder="Email" required />
                </div>
                <textarea id="comment" rows={6}
                    value={content} onChange={(e) => setContent(e.target.value)}
                    className="w-full text-sm bg-base-100 rounded-lg rounded-t-lg border border-primary p-4"
                    placeholder="Write a comment..." required>
                </textarea>
            </div>
            <button type="submit"
                onClick={handleSubmit}
                className="btn btn-primary w-full md:w-auto h-12 md:h-12 text-sm font-medium text-center">
                Post comment
            </button>
        </>
    );
};

export default AddComment;

=== ./components/frontend/OtherPosts/index.tsx ===
'use client';
import { faCaretLeft, faCaretRight } from '@fortawesome/free-solid-svg-icons';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import React, { useState, ReactNode, useRef, useEffect, useCallback } from 'react';
import PostCard from './Partials/PostCard';
import axiosInstance from '@/libs/axios';
import { PostWithData } from '@/types/BlogTypes';

const NEXT_PUBLIC_APPLICATION_HOST = process.env.APPLICATION_HOST;

const OtherPosts = ({ currentPostId, categoryId }: { currentPostId?: String, categoryId?: String }) => {

    const [children, setChildren] = useState<ReactNode[]>([]);

    const sliderRef = useRef<HTMLDivElement>(null);

    const timer = useRef<NodeJS.Timeout>();

    const fetchPosts = useCallback(async () => {
        await axiosInstance.get(`/api/posts?categoryId=${categoryId}&pageSize=10`).then((res) => {
            const posts = res.data.posts;
            var postCards = posts.map((post: any) => {

              post.image = post.image || `${NEXT_PUBLIC_APPLICATION_HOST}/api/posts/${post.postId}/cover.jpeg`;

                return <PostCard key={post.postId} post={post} />;
            });

            if (postCards && postCards.length !== 0) {

                while (postCards.length < 10) {
                    postCards = postCards.concat(postCards);
                }
                //Add 3 times the same posts to the end of the array to make the slider infinite
                setChildren(postCards);
                return;


            }
            setChildren(postCards);
        }
        ).catch((error) => {
            console.error(error);
        });

    }, [categoryId]);;

    useEffect(() => {
        fetchPosts();
    }, [fetchPosts]);
    //create a timer to scroll the slider smoothly

    const handleRight = useCallback(() => {
        if (sliderRef.current) {
            const slider = sliderRef.current;
            const scrollAmount = slider.scrollLeft;
            if (!children || children.length === 0) {
                return;
            }
            const slideWidth = slider.scrollWidth / children?.length;
            const slideCount = Math.round(scrollAmount / slideWidth);
            const nextSlide = slideCount + 1;
            const nextScroll = nextSlide * slideWidth;
            slider.scrollTo({
                left: nextScroll,
                behavior: 'smooth'
            });
        }
    }, [children]);

    const handleLeft = useCallback(() => {
        if (sliderRef.current) {
            const slider = sliderRef.current;
            const scrollAmount = slider.scrollLeft;
            if (!children || children.length === 0) {
                return;
            }
            const slideWidth = slider.scrollWidth / children?.length;
            const slideCount = Math.round(scrollAmount / slideWidth);
            const nextSlide = slideCount - 1;
            const nextScroll = nextSlide * slideWidth;
            slider.scrollTo({
                left: nextScroll,
                behavior: 'smooth'
            });
        }
    }, [children]);


    if (!children || children.length === 0) {
        return null;
    }

    return (
        <div className="container mb-8">
            <div className='flex justify-between items-center'>
                <h2 className="text-3xl font-bold text-left mt-4 mb-4">Related Posts</h2>
                <div className='flex items-center transition-all duration-300 ease-in-out scroll-smooth	' style={{ width: 'fit-content' }}>
                    <button className='mr-2' onClick={handleLeft}>
                        <FontAwesomeIcon icon={faCaretLeft} style={{ height: '1rem', width: '1rem' }} /></button>
                    <button onClick={handleRight}><FontAwesomeIcon icon={faCaretRight} style={{ height: '1rem', width: '1rem' }} /></button>
                </div>
            </div>
            <div className="max-h-[400px] w-full grid grid-flow-col gap-0 overflow-hidden"
                ref={sliderRef}>
                {children?.map((child, index) => (
                    <div id={`slide${index + 1}`} className="carousel-item relative mr-4 max-w-[300px]" key={index}>
                        {child}
                    </div>
                ))}
            </div>
        </div>
    );
}

export default OtherPosts;


=== ./components/frontend/OtherPosts/Partials/PostCard.tsx ===
'use client';
import React, { useEffect, useState } from 'react';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faCalendar } from '@fortawesome/free-solid-svg-icons';
import Link from 'next/link';
import { PostWithData } from '@/types/BlogTypes';
import Image from 'next/image';

const NEXT_PUBLIC_APPLICATION_HOST = process.env.APPLICATION_HOST;

const PostCard = ({post}: { post: PostWithData }) => {

    const { title, slug, createdAt, category, image } = post;

    const [dateText, setDateText] = useState("");

    useEffect(() => {
        if (!createdAt) {
            return;
        
        }

        if (isNaN(new Date(createdAt).getTime())) {
            setDateText("N/a");
            return;
        }

        try {

            const now = new Date();
            const diff = now.getTime() - new Date(createdAt).getTime();

            const diffSeconds = diff / 1000;
            const diffMinutes = diffSeconds / 60;
            const diffHours = diffMinutes / 60;
            const diffDays = diffHours / 24;

            console.log(typeof createdAt, createdAt, new Date(createdAt).toDateString(), diffDays);

            if (diffDays > 365) {
                setDateText(createdAt ? new Date(createdAt).toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' }) : "N/A");
            } else if (diffDays > 7 && diffDays <= 365) {
                setDateText(createdAt ? new Date(createdAt).toLocaleDateString(undefined, { month: 'short', day: 'numeric' }) : "N/A");
            } else if (diffDays > 1) {
                setDateText(`${Math.floor(diffDays)} days ago`);
            } else if (diffDays === 1) {
                setDateText("Yesterday");
            } else if (diffHours > 1) {
                setDateText(`${Math.floor(diffHours)} hours ago`);
            } else if (diffHours === 1) {
                setDateText("An hour ago");
            } else if (diffMinutes > 1) {
                setDateText(`${Math.floor(diffMinutes)} minutes ago`);
            } else if (diffMinutes === 1) {
                setDateText("A minute ago");
            } else {
                setDateText("Just now");
            }
       
        } catch (error) {
            console.error(error);
            setDateText("N/A");
        }
    }, [createdAt]);


    return (
        <div className={"bg-base-300 shadow-md rounded-lg min-w-[296px]"}>
            <Link
                href={"/blog/" + category.slug + "/" + slug}
                className="block h-32 border-b-2 border-base-300 overflow-hidden rounded-t-lg"
            >
            <img
                        src={image!}
                        width={1920}
                        height={1080}
                        alt="feed image"
                        className="w-full h-full object-cover"
                    />

            </Link>
            <div className="p-4">
                <Link href={"/blog/" + category.slug + "/" + slug}>
                    <h3 className="text-lg font-semibold text-primary hover:underline">
                        {title || "Title"}
                    </h3>
                </Link>
                <div className="mt-2 hidden lg:flex items-center text-sm gap-2">
                    <FontAwesomeIcon icon={faCalendar} className="w-4" />
                    <span>{dateText}</span>
                    <span className="text-primary">•</span>
                    <span className="text-primary">{post.views} views</span>
                </div>
            </div>
        </div>
    );
};

export default PostCard;


=== ./components/frontend/Menu/index.tsx ===
'use client';
import React from 'react';
import { useRouter, usePathname } from 'next/navigation';
import { useGlobalStore } from '@/libs/zustand';
import i18n from "@/libs/localize/localize";
import {  IconDefinition } from '@fortawesome/free-solid-svg-icons';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import MenuItem from '@/types/UITypes';
import MenuItems from '../MenuItems';

const Menu = ({isSidebar = false}) => {

    const { t } = i18n;

    const router = useRouter();
    const pathname = usePathname();

    const { user } = useGlobalStore();
    const isAdmin = user?.userRole === 'ADMIN' || user?.userRole === 'SUPER_ADMIN';

    const getYpositionOfElementById = (id: string) => {
        const additionalOffset = 100;
        const element = document.getElementById(id);

        if (element) {
            return element.getBoundingClientRect().top + window?.scrollY - additionalOffset;
        }
        return null;
    }

    const scrollOrRedirect = (item: MenuItem) => {

        if (item.external) {
            window?.open(item.page, '_blank');
            return;
        }


        const { id, page } = item;
        if (!id) {
            router.push(page); // Use the 'page' field for navigation
            return;
        }
        const yPosition = getYpositionOfElementById(id);

        if (yPosition === null) {
            const currentPage = pathname;

            router.push(page); // Use the 'page' field for navigation
            // wait for the page to load and try again maks 2 seconds
            setTimeout(() => {
                const yPosition = getYpositionOfElementById(id);
                if (yPosition !== null) {
                    window?.scrollTo({ top: yPosition, behavior: 'smooth' });
                }

            }, 700);

            return;
        }

        window?.scrollTo({ top: yPosition, behavior: 'smooth' });

    }


    return (
        <>
            {MenuItems.map((item) => (
                <li key={item.id}
                    style={{ display: item.onlyAdmin && !isAdmin ? 'none' : 'block', 
                        
                    marginLeft: '1px', marginTop: '4px' }}
                    onClick={() => scrollOrRedirect(item)}

                    className={(item.textColour ? item.textColour : "text-base-content") + " " + (item.backgroundColour ? item.backgroundColour : " ") + " rounded-md"}>
                    <div className="flex items-center gap-2">
                        {item.icon && <FontAwesomeIcon icon={item.icon as IconDefinition} className="w-4 h-4" />}
                        <span className={(item.hideTextOnDesktop && !isSidebar ? 'hidden' : 'block')} >{t("navigation." + item.name)}</span>
                    </div>
                </li>
            ))}
        </>
    );
};

export default Menu;

=== ./components/easter/Terminal/index.tsx ===
// Terminal.tsx

'use client';
import React, { useState, useEffect, useCallback , useRef } from 'react';
import { useTerminal } from './Hooks/useTerminal';
import { CommandOutput , TerminalFolder } from './Partials/models';
import { commandMap } from './Partials/commands';

const userName = 'kuraykaraaslan';
const hostName = 'kuray-dev';
const prompt = `${userName}@${hostName}:~$`;

const Terminal: React.FC = () => {

    const mainRef = useRef<HTMLDivElement>(null);
    const inputRef = useRef<HTMLInputElement>(null);

    const { history, processCommand, currentPath, fileSystem, setHistory } = useTerminal();
    const [input, setInput] = useState('');
    
    const getCurrentDirectory = useCallback((): TerminalFolder => {
        let currentDir = fileSystem;
        for (const dirName of currentPath) {
            const dir = currentDir.folders.find(f => f.name === dirName);
            if (!dir) return currentDir;
            currentDir = dir;
        }
        return currentDir;
    }, [fileSystem, currentPath]);

    const getCommonPrefix = (strings: string[]): string => {
        if (strings.length === 0) return '';
        let prefix = strings[0];
        for (const str of strings) {
            while (str.indexOf(prefix) !== 0) {
                prefix = prefix.slice(0, -1);
                if (prefix === '') return '';
            }
        }
        return prefix;
    };

    const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
        console.log('handleKeyDown', e.key);
        const target = e.currentTarget as HTMLInputElement;
        const cursorPos = target.selectionStart || 0;
        const value = target.value;

        if (e.key === 'Enter') {
            const trimmedInput = input.trim();
            
            // Handle empty command
            if (trimmedInput === '') {
                // Add empty command to history with no output
                setHistory(prev => [
                    ...prev,
                    {
                        command: '',
                        output: { type: 'text', content: '' },
                        directoryPath: currentPath,
                    }
                ]);
                setInput('');
                return;
            }
    
            processCommand(trimmedInput);
            setInput('');
        
        } else if (e.key === 'Tab') {
            e.preventDefault();
            // Find current word boundaries
            let start = cursorPos;
            let end = cursorPos;
            while (start > 0 && !/\s/.test(value[start - 1])) start--;
            while (end < value.length && !/\s/.test(value[end])) end++;

            const currentWord = value.slice(start, end);
            const before = value.slice(0, start);
            const after = value.slice(end);

            // Determine completion context
            const isCommand = before.trim().split(/\s+/).length === 0;
            const currentDir = getCurrentDirectory();
            const candidates = isCommand
                ? Object.keys(commandMap)
                : [
                    ...currentDir.folders.map(f => f.name),
                    ...currentDir.files.map(f => f.name)
                ];

            const suggestions = candidates
                .filter(name => name.startsWith(currentWord))
                .sort();

            if (suggestions.length > 0) {
                const commonPrefix = getCommonPrefix(suggestions);
                const completion = commonPrefix.slice(currentWord.length);
                
                if (completion) {
                    const newValue = `${before}${currentWord}${completion}${after}`;
                    const newCursorPos = start + currentWord.length + completion.length;
                    setInput(newValue);
                    setTimeout(() => target.setSelectionRange(newCursorPos, newCursorPos), 0);
                }
            }
        }

        // up and down arrow keys
        if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (history.length > 0) {
                const lastCommand = history[history.length - 1].command;
                setInput(lastCommand);
                target.setSelectionRange(lastCommand.length, lastCommand.length);
            }
        }
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (history.length > 0) {
                const lastCommand = history[history.length - 1].command;
                setInput(lastCommand);
                target.setSelectionRange(lastCommand.length, lastCommand.length);
            }
        }
    };


    const renderOutput = (output: CommandOutput) => {
        switch (output.type) {
            case 'text':
                return <pre className="whitespace-pre-wrap font-mono">{output.content}</pre>;
            case 'list':
                return output.items.map((item, i) => (
                    <span key={i} className={item.type === 'folder' ? 'text-blue-500' : 'text-white'}>
                        {item.name}{' '}
                    </span>
                ));
            case 'error':
                return <span className="text-red-500">{output.message}</span>;
            default:
                return null;
        }
    };

    //relay keystrokes to input
    useEffect(() => {
        if (!mainRef.current) {
            return;
        }
        const handleKeyDown = (e: KeyboardEvent) => {
            if (e.key === 'Tab') {
                e.preventDefault();
                inputRef.current?.focus();
            }
        };
        const mainElement = mainRef.current;
        mainElement.addEventListener('keydown', handleKeyDown);

        return () => {
            mainElement.removeEventListener('keydown', handleKeyDown);
        };
    }, [history]);

    return (
        <div className="bg-black text-white p-4 min-h-screen font-mono w-full overflow-y-auto min-w-[600px]" ref={mainRef}>
            <div className="">
                {history.map((item, i) => {
                    const renderedOutput = renderOutput(item.output);

                    console.log('renderedOutput', renderedOutput);
                    //if it is empty, return null
                    //if it is a list, add a new line
                    return (
                        <div key={i} className="">
                            <div className="text-green-500 h-6">
                                <span className="">{prompt}</span>
                                <span className="text-blue-500 ml-1">{item.directoryPath.join('/') || '~'}</span>$
                                <span className="ml-2 text-white">{item.command}</span>
                            </div>
                            {renderedOutput && (
                                <div className="">{renderedOutput}</div>
                            )}
                        </div>
                    );
                }
                )}
            </div>
            <div className="flex items-center">
                <span className="text-green-500">{prompt}</span>
                <span className="text-blue-500 ml-1">{currentPath.join('/') || '~'}</span>$
                <input
                    type="text"
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    onKeyDown={handleKeyDown}
                    className="h-6 pl-2 bg-transparent text-white outline-none flex-1 focus:ring-0 focus:outline-none border-0"
                    autoFocus
                />
            </div>
        </div>
    );
};

export default Terminal;

=== ./components/easter/Terminal/Partials/filesystem.ts ===
import { TerminalFile, TerminalFolder } from "./models";

const filesystem: TerminalFolder = {
    name: '~',
    folders: [
        {
            name: 'resume',
            folders: [],
            files: [
                {
                    name: 'cv.txt',
                    content: `KURAY KARAASLAN\n\nFull Stack Developer | React, Node.js, Java`,
                    type: 'file'
                },
                {
                    name: 'cover-letter.md',
                    content: '# Cover Letter\n\nHello, I am Kuray Karaaslan, a full stack developer who transitioned from civil engineering to software development. I specialize in building modern SaaS applications with clean architecture and excellent user experience.',
                    type: 'file'
                }
            ]
        },
        {
            name: 'skills',
            folders: [],
            files: [
                {
                    name: 'languages.txt',
                    content: 'JavaScript/TypeScript, Java',
                    type: 'file'
                },
                {
                    name: 'frameworks.txt',
                    content: 'React, Next.js, React Native, Express.js, Prisma, Spring Boot',
                    type: 'file'
                },
                {
                    name: 'tools.txt',
                    content: 'Docker, Git, MQTT, Stripe, Tailwind CSS, Zustand, Three.js, TurboRepo, Iyzico',
                    type: 'file'
                },
                {
                    name: 'design.txt',
                    content: 'UI/UX Design, Figma, Tailwind CSS, pixel-perfect components',
                    type: 'file'
                }
            ]
        },
        {
            name: 'education',
            folders: [],
            files: [
                {
                    name: 'university.txt',
                    content: 'BSc Civil Engineering\nDokuz Eylul University (2015-2021)',
                    type: 'file'
                }
            ]
        },
        {
            name: 'hobbies',
            folders: [],
            files: [
                {
                    name: 'reading.txt',
                    content: 'Enjoys reading blog posts, developer docs, and exploring SaaS architecture patterns.',
                    type: 'file'
                },
                {
                    name: 'fitness.txt',
                    content: 'Goes to the gym 2-3 times/week. 40 min treadmill, 30 min strength training.',
                    type: 'file'
                },
                {
                    name: 'coffee-nerd.md',
                    content: 'Has two coffee machines and enjoys reviewing them. Left-handed coffee enthusiast.',
                    type: 'file'
                },
                {
                    name: 'fun.txt',
                    content: 'Enjoys witty riddles and jokes. Built a streaming setup with lights, webcam, and professional mic.',
                    type: 'file'
                },
                {
                    name: 'stream-setup.txt',
                    content: `Dual monitor, Logitech 4K webcam, RGB lights, pro mic, adjustable arms. Used for recording educational videos and live demos.`,
                    type: 'file'
                }
            ]
        },
        {
            name: 'config',
            folders: [],
            files: [
                {
                    name: 'settings.json',
                    content: '{"theme":"dark","font":"Fira Code"}',
                    type: 'file'
                }
            ]
        }
    ],
    files: [
        {
            name: 'readme.txt',
            content: `# Welcome to my terminal!\n\nThis is a simulated terminal environment. You can explore my files and folders using commands like 'ls', 'cd', and 'cat'.\n\nTo get started, try typing 'ls' to list the contents of the current directory.`,
            type: 'file'
        },
        {
            name: 'contact.info',
            content: `Email: kuraykaraaslan@gmail.com\nLinkedIn: linkedin.com/in/kuray\nGitHub: github.com/kuraykaraaslan`,
            type: 'file'
        },
        {
            name: 'about.txt',
            content: `Kuray Karaaslan — developer, builder, engineer in transition. From construction sites to codebases, now designing better systems than buildings.`,
            type: 'file'
        },
        {
            name: '.bashrc',
            content: '# Custom bash config with alias for productivity',
            type: 'file'
        }
    ]
};

export default filesystem;


=== ./components/easter/Terminal/Partials/models.ts ===
// models.ts

export interface TerminalFile {
    name: string;
    content: string;
    type: 'file';
}

export interface TerminalFolder {
    name: string;
    folders: TerminalFolder[];
    files: TerminalFile[];
}

export type CommandOutput =
    | { type: 'text'; content: string }
    | { type: 'list'; items: Array<{ name: string; type: 'file' | 'folder' }> }
    | { type: 'error'; message: string };

export interface HistoryItem {
    command: string;
    output: CommandOutput;
    directoryPath: string[];
}

=== ./components/easter/Terminal/Partials/commands.ts ===
// commands.ts

import { TerminalFolder, CommandOutput } from "./models";
import { useTerminal } from "../Hooks/useTerminal";
import { rm } from "fs";
import { clear } from "console";
import { arch } from "os";

type CommandHandler = (
    currentPath: string[],
    fileSystem: TerminalFolder,
    args: string[]
) => {
    output: CommandOutput;
    newFileSystem?: TerminalFolder;
    newPath?: string[];
};


// Helper function to get a folder by path
export const getFolderByPath = (root: TerminalFolder, path: string[]): TerminalFolder | null => {
    let currentFolder = root;
    for (const dirName of path) {
        const folder = currentFolder.folders.find(f => f.name === dirName);
        if (!folder) return null;
        currentFolder = folder;
    }
    return currentFolder;
};

// Helper function to update folder structure immutably
const updateFolderInTree = (
    current: TerminalFolder,
    path: string[],
    updater: (folder: TerminalFolder) => TerminalFolder
): TerminalFolder => {
    if (path.length === 0) return updater(current);
    const [nextDir, ...restPath] = path;
    return {
        ...current,
        folders: current.folders.map(folder => {
            if (folder.name === nextDir) {
                return updateFolderInTree(folder, restPath, updater);
            }
            return folder;
        })
    };
};

const resolvePath = (currentPath: string[], inputPath: string): string[] => {
    // Handle absolute paths (our filesystem root is home)
    if (inputPath.startsWith('/')) {
        return inputPath.split('/').slice(1);
    }

    // Handle relative paths
    let newPath = [...currentPath];
    const parts = inputPath.split('/');

    for (const part of parts) {
        if (part === '..') {
            if (newPath.length > 0) {
                newPath.pop();
            }
        } else if (part !== '.' && part !== '') {
            newPath.push(part);
        }
    }

    return newPath;
};


export const commandMap: Record<string, CommandHandler> = {
    ls: (currentPath, fileSystem, args) => {
        const targetPath = args[0] ? resolvePath(currentPath, args[0]) : currentPath;
        const targetDir = getFolderByPath(fileSystem, targetPath);
        if (!targetDir) {
            return {
                output: {
                    type: 'error',
                    message: `ls: cannot access '${args[0]}': No such file or directory`
                }
            };
        }
        const folders = targetDir.folders
            .map(f => ({ name: f.name, type: 'folder' as const }))
            .sort((a, b) => a.name.localeCompare(b.name));
        const files = targetDir.files
            .map(f => ({ name: f.name, type: 'file' as const }))
            .sort((a, b) => a.name.localeCompare(b.name));
        return {
            output: {
                type: 'list',
                items: [...folders, ...files]
            }
        };
    },
    cd: (currentPath, fileSystem, args) => {
        if (args.length === 0) return { output: { type: 'error', message: 'cd: missing argument' } };
        const target = args[0];
        if (target === '..') {
            if (currentPath.length === 0) return { output: { type: 'error', message: 'Already at root' } };
            return { output: { type: 'text', content: '' }, newPath: currentPath.slice(0, -1) };
        }
        const newPath = [...currentPath, target];
        const targetDir = getFolderByPath(fileSystem, newPath);
        return targetDir
            ? { output: { type: 'text', content: '' }, newPath }
            : { output: { type: 'error', message: `cd: ${target}: No such directory` } };
    },
    mkdir: (currentPath, fileSystem, args) => {
        if (args.length === 0) return { output: { type: 'error', message: 'mkdir: missing operand' } };
        const dirName = args[0];

        const invalidChars = /[<>:"/\\|?*]/;
        if (invalidChars.test(dirName)) {
            return { output: { type: 'error', message: `mkdir: invalid directory name '${dirName}'` } };
        }

        const currentDir = getFolderByPath(fileSystem, currentPath);
        if (!currentDir) return { output: { type: 'error', message: 'Current directory not found' } };
        if (currentDir.folders.some(f => f.name === dirName)) {
            return { output: { type: 'error', message: `mkdir: ${dirName}: File exists` } };
        }
        const newFileSystem = updateFolderInTree(fileSystem, currentPath, folder => ({
            ...folder,
            folders: [...folder.folders, { name: dirName, folders: [], files: [] }]
        }));
        return { output: { type: 'text', content: '' }, newFileSystem };
    },
    cat: (currentPath, fileSystem, args) => {
        if (args.length === 0) {
            return { output: { type: 'error', message: 'cat: missing file operand' } };
        }
        const currentDir = getFolderByPath(fileSystem, currentPath);
        if (!currentDir) return { output: { type: 'error', message: 'Directory not found' } };
        const fileName = args[0];
        const targetFile = currentDir.files.find(f => f.name === fileName);
        const targetFolder = currentDir.folders.find(f => f.name === fileName);
        if (targetFolder) {
            return {
                output: {
                    type: 'error',
                    message: `cat: ${fileName}: Is a directory`
                }
            };
        }
        if (!targetFile) {
            return {
                output: {
                    type: 'error',
                    message: `cat: ${fileName}: No such file or directory`
                }
            };
        }
        return {
            output: {
                type: 'text',
                content: targetFile.content
            }
        };
    },
    neofetch: () => ({
        output: {
            type: 'text',
            content:
                '\n' +
                '    ██╗  ██╗██╗   ██╗██████╗  █████╗ ██╗   ██╗\n' +
                '    ██║ ██╔╝██║   ██║██╔══██╗██╔══██╗╚██╗ ██╔╝\n' +
                '    █████╔╝ ██║   ██║██████╔╝███████║ ╚████╔╝ \n' +
                '    ██╔═██╗ ██║   ██║██╔══██╗██╔══██║  ╚██╔╝  \n' +
                '    ██║  ██╗╚██████╔╝██║  ██║██║  ██║   ██║   \n' +
                '    ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   \n' +
                '\n' +
                'OS: PortfolioOS v2.1.0\n' +
                'Host: Terminal Portfolio\n' +
                'Kernel: 5.19.0-react-terminal\n' +
                'CPU: Intel i9-13900K (24) @ 5.8GHz\n' +
                'Memory: 32GB DDR5 @ 4800MHz\n' +
                'Uptime: 24/7 Available\n' +
                'Terminal: WebTerminal 3.1.4\n'
        }
    }),
    tree: (currentPath, fileSystem) => {
        const targetDir = getFolderByPath(fileSystem, currentPath);
        if (!targetDir) {
            return {
                output: {
                    type: 'error',
                    message: `tree: cannot access '${currentPath.join('/')}': No such file or directory`
                }
            };
        }
        const formatTree = (dir: TerminalFolder, prefix: string): string => {
            let result = `${prefix}${dir.name}/\n`;
            const items = [...dir.folders, ...dir.files].sort((a, b) => a.name.localeCompare(b.name));
            items.forEach((item, index) => {
                const isLast = index === items.length - 1;
                const newPrefix = `${prefix}${isLast ? '    ' : '│   '}`;
                if ('folders' in item) { // Check if the item is a folder
                    result += formatTree(item, newPrefix);
                } else {
                    result += `${newPrefix}${item.name}\n`;
                }
            }
            );
            return result;
        };
        const treeString = formatTree(targetDir, '');
        return {
            output: {
                type: 'text',
                content: treeString
            }
        };
    },
    mv: (currentPath, fileSystem, args) => {
        if (args.length < 2) {
            return { output: { type: 'error', message: 'mv: missing operand' } };
        }
        const currentDir = getFolderByPath(fileSystem, currentPath);
        if (!currentDir) return { output: { type: 'error', message: 'Directory not found' } };
        const oldName = args[0];
        const newName = args[1];
        const targetFile = currentDir.files.find(f => f.name === oldName);
        const targetFolder = currentDir.folders.find(f => f.name === oldName);
        if (!targetFile && !targetFolder) {
            return {
                output: {
                    type: 'error',
                    message: `mv: ${oldName}: No such file or directory`
                }
            };
        }
        if (targetFile) {
            if (currentDir.files.some(f => f.name === newName)) {
                return { output: { type: 'error', message: `mv: ${newName}: File exists` } };
            }
            const newFileSystem = updateFolderInTree(fileSystem, currentPath, folder => ({
                ...folder,
                files: folder.files.map(f => f.name === oldName ? { ...f, name: newName } : f)
            }));
            return { output: { type: 'text', content: '' }, newFileSystem };
        }
        if (targetFolder) {
            if (currentDir.folders.some(f => f.name === newName)) {
                return { output: { type: 'error', message: `mv: ${newName}: Directory exists` } };
            }
            const newFileSystem = updateFolderInTree(fileSystem, currentPath, folder => ({
                ...folder,
                folders: folder.folders.map(f => f.name === oldName ? { ...f, name: newName } : f)
            }));
            return { output: { type: 'text', content: '' }, newFileSystem };
        }
        return {
            output: {
                type: 'error',
                message: `mv: ${oldName}: No such file or directory`
            }
        };
    },
    cp: (currentPath, fileSystem, args) => {
        if (args.length < 2) {
            return { output: { type: 'error', message: 'cp: missing operand' } };
        }
        const currentDir = getFolderByPath(fileSystem, currentPath);
        if (!currentDir) return { output: { type: 'error', message: 'Directory not found' } };
        const sourceName = args[0];
        const targetName = args[1];
        const sourceFile = currentDir.files.find(f => f.name === sourceName);
        const sourceFolder = currentDir.folders.find(f => f.name === sourceName);
        if (!sourceFile && !sourceFolder) {
            return {
                output: {
                    type: 'error',
                    message: `cp: ${sourceName}: No such file or directory`
                }
            };
        }
        if (sourceFile) {
            if (currentDir.files.some(f => f.name === targetName)) {
                return { output: { type: 'error', message: `cp: ${targetName}: File exists` } };
            }
            const newFileSystem = updateFolderInTree(fileSystem, currentPath, folder => ({
                ...folder,
                files: [...folder.files, { ...sourceFile, name: targetName }]
            }));
            return { output: { type: 'text', content: '' }, newFileSystem };
        }
        if (sourceFolder) {
            if (currentDir.folders.some(f => f.name === targetName)) {
                return { output: { type: 'error', message: `cp: ${targetName}: Directory exists` } };
            }
            const newFileSystem = updateFolderInTree(fileSystem, currentPath, folder => ({
                ...folder,
                folders: [...folder.folders, { ...sourceFolder, name: targetName }]
            }));
            return { output: { type: 'text', content: '' }, newFileSystem };
        }
        return {
            output: {
                type: 'error',
                message: `cp: ${sourceName}: No such file or directory`
            }
        };
    },
    help: () => ({
        output: {
            type: "text",
            content: `Available commands:
            ls    - List directory contents
            cd    - Change directory
            cat   - Show file content
            mkdir - Create a new directory
            neofetch - Show system information
            pwd   - Show current directory
            clear - Clear terminal
            help  - Show this help message
            touch - Create a new file
            rm    - Remove a file
            echo  - Print text to the terminal
            whoami - Show current user
            date  - Show current date and time
            exit  - Exit the terminal
            mv    - Move or rename files/directories
            cp    - Copy files/directories
            tree  - Show directory structure
            uptime - Show system uptime
              `
        }
    }),
    rm: (currentPath, fileSystem, args) => {
        if (args.length === 0) {
            return { output: { type: 'error', message: 'rm: missing operand' } };
        }
        const currentDir = getFolderByPath(fileSystem, currentPath);
        if (!currentDir) return { output: { type: 'error', message: 'Directory not found' } };
        const fileName = args[0];
        const targetFile = currentDir.files.find(f => f.name === fileName);
        if (!targetFile) {
            return {
                output: {
                    type: 'error',
                    message: `rm: ${fileName}: No such file or directory`
                }
            };
        }
        const newFileSystem = updateFolderInTree(fileSystem, currentPath, folder => ({
            ...folder,
            files: folder.files.filter(f => f.name !== fileName)
        }));
        return { output: { type: 'text', content: '' }, newFileSystem };
    },
    pwd: (currentPath) => ({
        output: {
            type: 'text',
            content: '/' + currentPath.join('/')
        }
    }),
    touch: (currentPath, fileSystem, args) => {
        if (args.length === 0) return { output: { type: 'error', message: 'touch: missing file name' } };
        const fileName = args[0];
        const currentDir = getFolderByPath(fileSystem, currentPath);
        if (!currentDir) return { output: { type: 'error', message: 'Directory not found' } };
        if (currentDir.files.some(f => f.name === fileName)) {
            return { output: { type: 'error', message: `touch: ${fileName}: File exists` } };
        }
        const newFileSystem = updateFolderInTree(fileSystem, currentPath, folder => ({
            ...folder,
            files: [...folder.files, { name: fileName, content: '', type: 'file' }]
        }));
        return { output: { type: 'text', content: '' }, newFileSystem };
    },
    echo: (currentPath, fileSystem, args) => {
        const textToEcho = args.join(' ');
        return {
            output: {
                type: 'text',
                content: textToEcho
            }
        };
    },
    whoami: (() => ({
        output: {
            type: 'text',
            content: 'kuraykaraaslan'
        }
    })),
    date: () => ({
        output: {
            type: 'text',
            content: new Date().toLocaleString()
        }
    }),
    //since 2023-agust-26
    uptime: () => {
        const uptime = process.uptime();
        const days = Math.floor(uptime / (24 * 60 * 60));
        const hours = Math.floor((uptime % (24 * 60 * 60)) / (60 * 60));
        const minutes = Math.floor((uptime % (60 * 60)) / 60);
        const seconds = Math.floor(uptime % 60);
        return {
            output: {
                type: 'text',
                content: `${days}d ${hours}h ${minutes}m ${seconds}s`
            }
        };
    }
};
// Add more command handlers as needed

export const executeCommand = (
    command: string,
    currentPath: string[],
    fileSystem: TerminalFolder
) => {
    const [cmd, ...args] = command.split(" ");
    const handler = commandMap[cmd];

    return handler
        ? handler(currentPath, fileSystem, args)
        : { output: { type: "error", message: `${cmd}: command not found` } };
};


=== ./components/easter/Terminal/Hooks/useTerminal.ts ===
// useTerminal.ts

import { useState } from 'react';
import { TerminalFolder, HistoryItem, CommandOutput } from '../Partials/models';
import { executeCommand } from '../Partials/commands';
import filesystem from '../Partials/filesystem';
import { useRouter } from 'next/navigation';

export const useTerminal = () => {
    const [fileSystem, setFileSystem] = useState<TerminalFolder>(filesystem);
    const [currentPath, setCurrentPath] = useState<string[]>([]);
    const [history, setHistory] = useState<HistoryItem[]>([]);

    const router = useRouter();

    const processCommand = (command: string) => {
        const result = executeCommand(
            command,
            currentPath,
            fileSystem
        );

        // Handle clear command
        if (command.trim() === 'clear') {
            setHistory([]);
            setCurrentPath([]);
            setFileSystem(filesystem);
            return;
        }

        //handle history
        if (command.trim() === 'history') {
            const historyOutput: CommandOutput = {
                type: 'list',
                items: history.map((item, index) => ({
                    name: `${index + 1}: ${item.command}`,
                    type: 'file'
                }))
            };
            const newHistoryItem: HistoryItem = {
                command,
                output: historyOutput,
                directoryPath: currentPath
            };
            setHistory(prev => [...prev, newHistoryItem]);
            return;
        }

        // Handle exit command
        if (command.trim() === 'exit') {
            const exitOutput: CommandOutput = {
                type: 'text',
                content: 'Exiting terminal...'
            };
            setTimeout(() => {
                router.push('/');
            }
            , 1000);

            const newHistoryItem: HistoryItem = {
                command,
                output: exitOutput,
                directoryPath: currentPath
            };
            setHistory(prev => [...prev, newHistoryItem]);
            return;

        }

        const { output } = result;
        const newHistoryItem: HistoryItem = {
            command,
            output: output as CommandOutput, // Ensure output is cast to CommandOutput
            directoryPath: currentPath
        };

        setHistory(prev => [...prev, newHistoryItem]);
        if ('newFileSystem' in result && result.newFileSystem) {
            setFileSystem(result.newFileSystem);
        }
        if ('newPath' in result && result.newPath) {
            setCurrentPath(result.newPath);
        }
    };

    return { history, processCommand, currentPath, fileSystem, setHistory };


};

=== ./components/admin/SlotTemplateBuilder/index.tsx ===
'use client'

import axiosInstance from '@/libs/axios'
import { Day, Slot, SlotTemplate } from '@/types/CalendarTypes'
import { useEffect, useState } from 'react'
import { toast } from 'react-toastify'
import { format, parse, startOfWeek, addDays } from 'date-fns'

interface SlotTemplateBuilderProps {
    selectedDay: Day
    selectedDate: Date
    DAYS: Day[]
    TIME_INTERVALS: number[]
    setSelectedDay: (day: Day) => void,
    setSelectedDate: (date: Date) => void
}

export default function SlotTemplateBuilder({
    selectedDay,
    selectedDate = new Date(),
    DAYS,
    TIME_INTERVALS,
    setSelectedDay,
    setSelectedDate
}: SlotTemplateBuilderProps) {

    const [templateSlots, setTemplateSlots] = useState<Slot[]>([])
    const [interval, setInterval] = useState<number>(30)
    const [startTime, setStartTime] = useState('08:00')
    const [endTime, setEndTime] = useState('18:00')
    const [saving, setSaving] = useState(false)
    const [newTime, setNewTime] = useState('')

    const formattedDate = format(selectedDate, 'yyyy-MM-dd')

    /** Fetch Template Slots */
    const fetchTemplate = async (day: Day) => {
        try {
            const res = await axiosInstance.get(`/api/slot-templates/${day}`)
            setTemplateSlots(
                res.data.slots?.map((s: any) => ({
                    startTime: new Date(s.startTime),
                    endTime: new Date(s.endTime),
                    capacity: s.capacity
                })) || []
            )
        } catch (err) {
            console.error(err)
            toast.error('Failed to fetch template slots')
        }
    }

    useEffect(() => {
        fetchTemplate(selectedDay)
    }, [selectedDay])

    /** Generate slots between start and end */
    const generateTemplateSlots = () => {
        const [sh, sm] = startTime.split(':').map(Number)
        const [eh, em] = endTime.split(':').map(Number)
        const startMinutes = sh * 60 + sm
        const endMinutes = eh * 60 + em

        if (startMinutes >= endMinutes)
            return toast.error('Start time must be earlier than end time')

        const generated: Slot[] = []
        let current = startMinutes
        while (current < endMinutes) {
            const startH = Math.floor(current / 60)
            const startM = current % 60
            const endH = Math.floor((current + interval) / 60)
            const endM = (current + interval) % 60

            const start = parse(
                `${formattedDate} ${String(startH).padStart(2, '0')}:${String(startM).padStart(2, '0')}`,
                'yyyy-MM-dd HH:mm',
                new Date()
            )
            const end = parse(
                `${formattedDate} ${String(endH).padStart(2, '0')}:${String(endM).padStart(2, '0')}`,
                'yyyy-MM-dd HH:mm',
                new Date()
            )

            if (end > start && end <= parse(`${formattedDate} ${endTime}`, 'yyyy-MM-dd HH:mm', new Date())) {
                generated.push({ startTime: start, endTime: end, capacity: 1 })
            }

            current += interval
        }

        setTemplateSlots(generated)
        toast.info(`Generated ${generated.length} slots`)
    }

    /** Add manual slot */
    const addTemplateSlot = () => {
        if (!newTime) return toast.warn('Please select a time')

        const start = parse(`${formattedDate} ${newTime}`, 'yyyy-MM-dd HH:mm', new Date())
        const end = new Date(start.getTime() + interval * 60 * 1000)

        if (templateSlots.some((s) => s.startTime.getTime() === start.getTime()))
            return toast.warn('Slot already exists')

        const newSlot: Slot = { startTime: start, endTime: end, capacity: 1 }
        setTemplateSlots((prev) => [...prev, newSlot].sort((a, b) => a.startTime.getTime() - b.startTime.getTime()))
        setNewTime('')
    }

    /** Remove one or all slots */
    const removeTemplateSlot = (slot: Slot) =>
        setTemplateSlots((prev) => prev.filter((s) => s.startTime.getTime() !== slot.startTime.getTime()))
    const removeAllTemplateSlots = () => setTemplateSlots([])

    /** Save Template */
    const saveTemplate = async () => {
        setSaving(true)
        try {
            const payload: SlotTemplate = {
                day: selectedDay,
                slots: templateSlots
            }
            await axiosInstance.post(`/api/slot-templates/${selectedDay}`, payload)
            toast.success('Template saved successfully')
        } catch (e) {
            console.error(e)
            toast.error('Failed to save template')
        } finally {
            setSaving(false)
        }
    }

    /** Apply Template to Date */
    const applyTemplateToDate = async () => {

        if (!confirm(`Apply ${selectedDay} template to ${formattedDate}? This will overwrite existing slots.`)) return
        if (templateSlots.length === 0) return toast.warn('No slots to apply')

        try {
            const payload = {
                formattedDate: formattedDate,
            }
            await axiosInstance.post('/api/slot-templates/' + selectedDay + '/apply', payload)
            toast.success(`Template applied to ${formattedDate}`)
        } catch (err) {
            console.error(err)
            toast.error('Failed to apply template')
        }
    }

    /** Apply all templates to current week (Mon–Sun) */
    const applyAllTemplateToWeek = async () => {

        if (!confirm(`This will overwrite existing slots for the week that start from the ${format(startOfWeek(selectedDate, { weekStartsOn: 1 }), 'dd MMM yyyy')}. Continue?`)) return

        try {
            const weekStart = startOfWeek(selectedDate, { weekStartsOn: 1 }) // Monday
            for (let i = 0; i < 7; i++) {
                const day = DAYS[i]
                const date = addDays(weekStart, i)
                const formatted = format(date, 'yyyy-MM-dd')

                // fetch each day's template first
                const res = await axiosInstance.get(`/api/slot-templates/${day}`)
                const slots: Slot[] =
                    res.data.slots?.map((s: any) => ({
                        startTime: new Date(s.startTime),
                        endTime: new Date(s.endTime),
                        capacity: s.capacity
                    })) || []

                if (slots.length > 0) {
                    const payload = {
                        date: formatted,
                        slots: slots.map((s) => ({
                            startTime: s.startTime.toISOString(),
                            endTime: s.endTime.toISOString(),
                            capacity: s.capacity
                        }))
                    }
                    await axiosInstance.post(`/api/slots-template/${day}/apply`, payload)
                }
            }

            toast.success('Templates applied to all week successfully')
        } catch (err) {
            console.error(err)
            toast.error('Failed to apply templates to week')
        }
    }

    return (
        <div className="card bg-base-100 shadow-xl border border-base-200">
            <div className="card-body">
                <h2 className="text-2xl font-semibold mb-2">Template Builder</h2>
                <div className="text-sm text-gray-500 mb-4">
                    Create and manage slot templates for each day of the week.
                </div>

                {/* Day Selector */}
                <div className="flex flex-wrap gap-2 mb-4">
                    {DAYS.map((day) => (
                        <button
                            key={day}
                            onClick={() => setSelectedDay(day)}
                            className={`btn btn-sm rounded-full ${selectedDay === day
                                ? 'btn-primary text-white'
                                : 'btn-outline border-gray-400 text-gray-600'
                                }`}
                        >
                            {day.charAt(0).toUpperCase() + day.slice(1)}
                        </button>
                    ))}
                </div>

                {/* Generator */}
                <div className="grid grid-cols-2 sm:grid-cols-4 gap-3 mb-4">
                    <div>
                        <label className="text-xs text-gray-600">Start</label>
                        <input
                            type="time"
                            value={startTime}
                            onChange={(e) => setStartTime(e.target.value)}
                            className="input input-bordered w-full"
                        />
                    </div>
                    <div>
                        <label className="text-xs text-gray-600">End</label>
                        <input
                            type="time"
                            value={endTime}
                            onChange={(e) => setEndTime(e.target.value)}
                            className="input input-bordered w-full"
                        />
                    </div>
                    <div>
                        <label className="text-xs text-gray-600">Interval</label>
                        <select
                            value={interval}
                            onChange={(e) => setInterval(Number(e.target.value))}
                            className="select select-bordered w-full"
                        >
                            {TIME_INTERVALS.map((i) => (
                                <option key={i} value={i}>
                                    {i} min
                                </option>
                            ))}
                        </select>
                    </div>
                    <div className="flex items-end">
                        <button onClick={generateTemplateSlots} className="btn btn-outline w-full">
                            Generate
                        </button>
                    </div>
                </div>

                {/* Manual Add */}
                <div className="flex gap-2 mb-4">
                    <input
                        type="time"
                        value={newTime}
                        onChange={(e) => setNewTime(e.target.value)}
                        className="input input-bordered w-full"
                    />
                    <button className="btn btn-outline" onClick={addTemplateSlot}>
                        Add
                    </button>
                </div>

                {/* Save + Apply */}
                <div className="grid grid-cols-3 gap-2 mb-4">
                    <button
                        onClick={saveTemplate}
                        disabled={saving}
                        className="btn btn-primary text-white"
                    >
                        {saving ? 'Saving...' : 'Save'}
                    </button>
                    <button onClick={applyTemplateToDate} className="btn btn-accent text-white">
                        Apply to {formattedDate}
                    </button>
                    <button onClick={applyAllTemplateToWeek} className="btn btn-secondary text-white">
                        Apply to Week of {format(startOfWeek(selectedDate, { weekStartsOn: 1 }), 'dd MMM')}
                    </button>
                </div>

                {/* Remove All */}
                <button onClick={removeAllTemplateSlots} className="btn btn-outline w-full mb-3">
                    Remove All Slots
                </button>

                {/* Slot List */}
                <div className="bg-base-200 rounded-lg max-h-[300px] overflow-y-auto p-2">
                    {templateSlots.length === 0 ? (
                        <p className="text-gray-500 text-center py-6">No slots yet</p>
                    ) : (
                        templateSlots.map((slot, i) => (
                            <SingleTemplateSlot
                                key={i}
                                slot={slot}
                                removeTemplateSlot={removeTemplateSlot}
                            />
                        ))
                    )}
                </div>
            </div>
        </div>
    )
}

function SingleTemplateSlot({
    slot, key, removeTemplateSlot
}: {
    slot: Slot,
    key: number,
    removeTemplateSlot: (slot: Slot) => void
}) {
    return (
        <div
            key={key}
            className="flex justify-between items-center px-3 py-2 bg-base-100 rounded-lg mb-2 shadow-sm"
        >
            <span className="font-mono">
                {format(new Date(slot.startTime), 'HH:mm')} - {format(new Date(slot.endTime), 'HH:mm')}
            </span>
            <button
                className="btn btn-xs btn-error text-white"
                onClick={() => removeTemplateSlot(slot)}
            >
                ✕
            </button>
        </div>
    )
}

=== ./components/admin/SlotsEditor/index.tsx ===
import { Day, Slot } from "@/types/CalendarTypes"
import { useEffect, useState } from "react";
import { format } from "date-fns";
import Calendar from 'react-calendar';
import 'react-calendar/dist/Calendar.css';
import axiosInstance from "@/libs/axios";
import { toast } from "react-toastify";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faTrash } from "@fortawesome/free-solid-svg-icons";

const SlotsEditor = (
    {
        selectedDay,
        selectedDate,
        setSelectedDay,
        setSelectedDate
    }: {
        selectedDay: Day,
        selectedDate: Date,
        setSelectedDay: (day: Day) => void,
        setSelectedDate: (date: Date) => void
    }
) => {

    const [dailySlots, setDailySlots] = useState<Slot[]>([])
    const [loading, setLoading] = useState(false)
    const formattedDate = format(selectedDate, 'yyyy-MM-dd')


    /** Fetch Slots for selected date */
    const fetchDailySlots = async (date: string) => {
        setLoading(true)
        try {
            const res = await axiosInstance.get(`/api/slots/${date}`)
            setDailySlots(res.data.slots || [])
        } catch {
            toast.error('Failed to fetch daily slots')
        } finally {
            setLoading(false)
        }
    }

    const removeSlot = (index: number) => {
        const updatedSlots = [...dailySlots]
        updatedSlots.splice(index, 1)
        setDailySlots(updatedSlots)
    }

    const updateDailySlots = () => {
        setLoading(true)
        axiosInstance.put(`/api/slots/${formattedDate}`, { slots: dailySlots })
            .then(() => {
                toast.success('Slots updated successfully')
            })
            .catch(() => {
                toast.error('Failed to update slots')
            })
            .finally(() => {
                setLoading(false)
            })
    }

    useEffect(() => {
        fetchDailySlots(formattedDate)
    }, [formattedDate])

    return (
        <div className="card bg-base-100 shadow-xl border border-base-200 p-4">
            <div className="flex flex-col items-center mb-6">
                <Calendar
                    onChange={(value) => {
                        if (value instanceof Date) {
                            setSelectedDate(value);
                        } else if (Array.isArray(value) && value[0] instanceof Date) {
                            setSelectedDate(value[0]);
                        }

                    }}
                    value={selectedDate}
                    className="react-calendar border border-gray-300 rounded-lg p-2 w-full"
                />
            </div>

            <h2 className="text-lg font-semibold mb-2 text-center">
                {format(selectedDate, 'EEEE, dd MMM yyyy')}
            </h2>

            {loading ? (
                <div className="text-center py-10 text-gray-500">Loading...</div>
            ) : dailySlots.length === 0 ? (
                <div className="text-center py-10 text-gray-500">No slots for this day</div>
            ) : (
                <div className="overflow-y-auto max-h-[250px]">
                    {dailySlots.map((slot, i) => (
                        <SingleSlot
                            key={i}
                            slot={slot}
                            index={i}
                            removeSlot={removeSlot}
                        />
                    ))}
                </div>
            )}

            <div className="mt-4 w-full flex justify-end">
                <button
                    className="btn btn-primary btn-block"
                    onClick={updateDailySlots}
                    disabled={loading}
                >
                    {loading ? 'Saving...' : 'Save Changes'}
                </button>
            </div>
        </div>
    )
}

export function SingleSlot({
    slot, index, removeSlot
}: {
    slot: Slot,
    index: number,
    removeSlot: (index: number) => void
}) {

    return (
        <div
            key={index}
            className="flex justify-between items-center px-3 py-2 bg-base-100 rounded-lg mb-2 shadow-sm"
        >
            <span className="font-mono">
                {format(new Date(slot.startTime), 'HH:mm')} - {format(new Date(slot.endTime), 'HH:mm')}
            </span>
            <span className="text-sm text-gray-500">
                Capacity: {slot.capacity}
            </span>
            <button
                className="btn btn-xs btn-error text-white"
                onClick={() => removeSlot(index)}
            >
                ✕
            </button>
        </div>
    )
}

export default SlotsEditor;

=== ./components/admin/AIPrompt/index.tsx ===
import React, { useState } from 'react';
import axiosInstance from '@/libs/axios';
import { faRobot } from '@fortawesome/free-solid-svg-icons';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';

const AIPrompt = ({
    setTitle,
    setContent,
    setDescription,
    setKeywords,
    setSlug,
    setCreatedAt,
    toast
}: {
    setTitle: (title: string) => void,
    setContent: (content: string) => void,
    setDescription: (description: string) => void,
    setKeywords: (keywords: string[]) => void,
    setSlug: (slug: string) => void,
    setCreatedAt: (createdAt: Date) => void,
    toast: any
}) => {

    const [internalContent, setInternalContent] = useState('');

    const prompt = `
        create a post for this prompt: \n
    
        ${internalContent}
    
        format: {
            title: xxx,
            description: xxx,
            keywords: xxx, 
            content: xxx, //wysiwyg content
            createdAt: xxx, //a date recommended for the post if that post published on related date
        }
    
        `;

    const generatePost = async () => {
        await axiosInstance.post('/api/ai/gpt-4o', {
            prompt
        }).then((res) => {

            if (res.data.error || res.status !== 200) {
                toast.error(res.data.error.message);
                return;
            }

            try {
                const text = res.data.text;
                setTitle(text.title);
                setContent(text.content);
                setDescription(text.description);
                setSlug(text.slug);
                setCreatedAt(text.createdAt);

                if (text.keywords) {
                    //check if it is a string or an array
                    if (typeof text.keywords === 'string') {
                        setKeywords(text.keywords.split(','));
                    } else {
                        setKeywords(text.keywords);
                    }
                }


            } catch (error) {
                toast.error('Error while parsing the response');
            }
        }).catch((response) => {
            toast.error(response.error.message);
        });
    }

    const openModal = () => {
        if (document.getElementById('my_modal_4')) {
            // @ts-ignore
            document.getElementById('my_modal_4')?.showModal();
        }
    }

    return (
        <>
            <dialog id="my_modal_4" className="modal">
                <div className="modal-box w-11/12 max-w-5xl">
                    <h3 className="font-bold text-lg">OpenAI GPT-4 Post Generator</h3>
                    <div className="modal-body w-full">
                        <textarea className="textarea h-64 w-full mt-4" value={internalContent} onChange={(e) => setInternalContent(e.target.value)}></textarea>
                        <button className="btn btn-primary mt-2" onClick={generatePost}>Generate Post</button>
                    </div>
                    <div className="modal-action">
                        <form method="dialog">
                            {/* if there is a button, it will close the modal */}
                            <button className="btn">Close</button>
                        </form>
                    </div>
                </div>
            </dialog>
            <button className="btn bg-yellow-400" onClick={openModal}>
                <FontAwesomeIcon icon={faRobot} className="mr-2" /> AI Prompt
            </button>
        </>
    );
};

export default AIPrompt;

=== ./components/admin/Selects/CategorySelect.tsx ===
import { Category } from '@prisma/client';
import React, { useEffect, useState } from 'react';
import axiosInstance from '@/libs/axios';

const CategorySelect = ({ selectedCategoryId, setSelectedCategoryId }: { selectedCategoryId: string, setSelectedCategoryId: (categoryId: string) => void }) => {
    
    const [categories, setCategories] = useState<Category[]>([]);

    useEffect(() => {
        axiosInstance.get('/api/categories?pageSize=100').then((response) => {
            const { categories } = response.data;
            setCategories(categories);
        });
    }, []);

    function onChange(e: React.ChangeEvent<HTMLSelectElement>) {
        const selectedCategory = categories.find((category) => category.categoryId === e.target.value);
        if (selectedCategory) {
            setSelectedCategoryId(selectedCategory.categoryId);
        }
    }

    return (
        <div>
            <select value={selectedCategoryId} onChange={onChange} className="select select-bordered w-full">
                <option value="">Select Category</option>
                {categories.map((category) => (
                    <option key={category.categoryId} value={category.categoryId}>
                        {category.title}
                    </option>
                ))}

            </select>
        </div >
    );
}

export default CategorySelect;

=== ./components/admin/Selects/UserSelect.tsx ===
import axiosInstance from '@/libs/axios';
import { User } from '@prisma/client';
import React, { useEffect, useState } from 'react';

const UserSelect = ({ selectedUserId, setSelectedUserId }: { selectedUserId: string, setSelectedUserId: (userId: string) => void }) => {

    const [users, setUsers] = useState<User[]>([]);

    useEffect(() => {
        axiosInstance.get('/api/users?pageSize=100').then((response) => {
            const { users } = response.data;
            setUsers(users);
        });
    }, []);

    function onChange(e: React.ChangeEvent<HTMLSelectElement>) {
        const selectedUser = users.find((user) => user.userId === e.target.value);
        if (selectedUser) {
            setSelectedUserId(selectedUser.userId);
        }
    }

    return (
        <div>
            <select value={selectedUserId} onChange={onChange} className="select select-bordered w-full">
                <option value="">Select User</option>
                {users.map((user) => (
                    <option key={user.userId} value={user.userId}>
                        {user.name}
                    </option>
                ))}

            </select>
        </div >
    );
}

export default UserSelect;

=== ./components/admin/Tables/ProjectTable.tsx ===
'use client'
import React from 'react';
import {Project} from '@prisma/client';
import Link from 'next/link';
import Image from 'next/image';
import axiosInstance from '@/libs/axios';
import { Category } from '@prisma/client';
import { useRouter } from 'next/navigation';

const ProjectTable = () => {

    const [search, setSearch] = React.useState('');
    const [projects, setProjects] = React.useState<Partial<Project>[]>([]);
    const [page, setPage] = React.useState(0);
    const [pageSize, setPageSize] = React.useState(10);
    const [total, setTotal] = React.useState(0);

    const router = useRouter();

    React.useEffect(() => {

        axiosInstance.get("/api/projects" + `?page=${page + 1}&pageSize=${pageSize}&search=${search}&sort=desc`)
            .then((response) => {
                setProjects(response.data.projects);
                setTotal(response.data.total);
            })
            .catch((error) => {
                console.error(error);
            });
    }
        , [page, pageSize, search]);

    const deleteProject = async (projectId: string) => {
        //confirm
        if (!confirm('Are you sure you want to delete this project?')) {
            return;
        }

        //delete
        try {
            await axiosInstance.delete(`/api/projects/${projectId}`);
            setProjects(projects.filter(project => project.projectId !== projectId));
        } catch (error) {
            console.error(error);
        }
    }

    return (
        <div className="container mx-auto">
            <div className="flex justify-between md:items-center flex-col md:flex-row">
                <h1 className="text-3xl font-bold h-16 md:items-center">{"Projects"}</h1>
                <div className="flex gap-2 h-16 w-full md:w-auto md:flex-none">
                    <input type="text" placeholder="Search" className="input input-bordered flex-1 md:flex-none" value={search} onChange={(e) => setSearch(e.target.value)} />
                    <Link className="btn btn-primary btn-sm h-12" href="/admin/projects/create">
                        Create Project
                    </Link>
                </div>
            </div>

            <div className="overflow-x-auto w-full bg-base-200 mt-4 rounded-lg min-h-[400px]">
                <table className="table">
                    {/* head */}
                    <thead className="bg-base-300 h-12">
                        <tr className="h-12">
                            <th className="w-16">
                            </th>
                            <th>
                                Title
                            </th>
                            <th className="max-w-20">
                                Tech Stack
                            </th>
                            <th className="max-w-16">
                                Slug</th>
                            <th>Status</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        {projects.map((project, index) => (
                            <tr key={index} className="h-12 hover:bg-primary hover:bg-opacity-10">
                                <td>
                                    {project.image ?
                                        <Image width={32} height={32} src={project.image} className="h-8 w-8 rounded-full" alt={project.title as string} />
                                        :
                                        <div className="h-8 w-8 bg-base-300 rounded-full"></div>
                                    }
                                </td>
                                <td>{project.title}</td>
                                <td>{project.technologies && project.technologies.join(', ')}</td>
                                <td>{project.slug}</td>
                                <td>{project.status}</td>
                                <td className="flex gap-2">
                                    <Link href={`/admin/projects/${project.projectId}`} className="btn btn-sm btn-primary">Edit</Link>
                                    <Link href={`/project/${project.slug}`} className="btn btn-sm btn-secondary">View</Link>
                                    <button onClick={() => deleteProject(project.projectId as string)} className="btn btn-sm bg-red-500 text-white hidden md:flex">Delete</button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            <div className="flex justify-between items-center mt-4">
                <div>
                    <span>Showing {projects.length} of {total} projects</span>
                </div>
                <div className="flex gap-2">
                    <button onClick={() => setPage(page - 1)} disabled={page === 0} className="btn btn-sm btn-secondary h-12">Previous</button>
                    <button onClick={() => setPage(page + 1)} disabled={(page + 1) * pageSize >= total} className="btn btn-sm btn-secondary h-12">Next</button>
                </div>
            </div>
        </div>
    );
};

export default ProjectTable;

=== ./components/admin/Tables/CommentTable.tsx ===
'use client'
import React from 'react';
import { PostWithData } from '@/types/BlogTypes';
import Link from 'next/link';
import Image from 'next/image';
import axiosInstance from '@/libs/axios';
import { Category } from '@prisma/client';
import { useRouter } from 'next/navigation';
import { CommentWithData } from '@/types/CommentWithData';

const CommentTable = ({ post }: { post?: PostWithData }) => {

    const [search, setSearch] = React.useState('');
    const [comments, setComments] = React.useState<Partial<CommentWithData>[]>([]);
    const [page, setPage] = React.useState(0);
    const [pageSize, setPageSize] = React.useState(10);
    const [total, setTotal] = React.useState(0);

    const router = useRouter();

    React.useEffect(() => {

        axiosInstance.get("/api/comments" + `?page=${page + 1}&pageSize=${pageSize}&search=${search}&sort=desc&pending=true` + (post ? `&postId=${post.postId}` : ''))
            .then((response) => {
                setComments(response.data.comments);
                setTotal(response.data.total);
            })
            .catch((error) => {
                console.error(error);
            });
    }
        , [page, pageSize, search]);

    const deleteComment = async (commentId: string) => {
        //confirm
        if (!confirm('Are you sure you want to delete this post?')) {
            return;
        }

        //delete
        try {
            await axiosInstance.delete(`/api/comments/${commentId}`);
            setComments(comments.filter(comment => comment.commentId !== commentId));
        } catch (error) {
            console.error(error);
        }
    }

    const approveComment = async (commentId: string) => {
        //confirm
        if (!confirm('Are you sure you want to approve this post?')) {
            return;
        }

        //approve
        try {
            await axiosInstance.put(`/api/comments`, { commentId, status: "APPROVED" });
            setComments(comments.map(comment => {
                if (comment.commentId === commentId) {
                    return { ...comment, status: 'APPROVED' };
                }
                return comment;
            }));
        } catch (error) {
            console.error(error);
        }
    }

    const rejectComment = async (commentId: string) => {

        //confirm
        if (!confirm('Are you sure you want to reject this post?')) {
            return;
        }

        //reject
        try {
            await axiosInstance.put(`/api/comments`, { commentId, status: "PENDING" });
            setComments(comments.map(comment => {
                if (comment.commentId === commentId) {
                    return { ...comment, status: 'PENDING' };
                }
                return comment;
            }));
        } catch (error) {
            console.error(error);
        }
    }


    return (
        <div className="container mx-auto">
            <div className="flex justify-between md:items-center flex-col md:flex-row">
                <h1 className="text-3xl font-bold h-16 md:items-center">{post ? post.title + " Comments" : "Comments"}</h1>
                <div className="flex gap-2 h-16 w-full md:w-auto md:flex-none">
                    <input type="text" placeholder="Search" className="input input-bordered flex-1 md:flex-none" value={search} onChange={(e) => setSearch(e.target.value)} />
                </div>
            </div>

            <div className="overflow-x-auto w-full bg-base-200 mt-4 rounded-lg min-h-[400px]">
                <table className="table">
                    {/* head */}
                    <thead className="bg-base-300 h-12">
                        <tr className="h-12">
                            <th className="grid-cols-2">
                                Post
                            </th>
                            <th className="grid-cols-1">
                                <p>Contact</p>
                            </th>
                            <th className="max-w-16">
                                Content
                            </th>
                            <th>Status</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        {comments.map((comment, index) => (
                            <tr key={index} className="h-12 hover:bg-primary hover:bg-opacity-10">
                                <td className="max-w-20 grid-cols-2">
                                    {comment.post?.title}
                                </td>
                                <td className="flex flex-col gap-1 max-w-20">
                                    <span>{comment.email}</span>
                                    <span>{comment.name}</span>
                                </td>
                                <td>{comment.content}</td>
                                <td className="max-w-16">
                                    {comment.status}
                                </td>
                                <td className="flex gap-2 max-w-16">
                                    <button onClick={() => deleteComment(comment.commentId as string)} className="btn btn-sm bg-red-500 text-white hidden md:flex">Delete</button>

                                    {comment.status === 'PENDING' ? (
                                        <button onClick={() => approveComment(comment.commentId as string)} className="btn btn-sm bg-green-500 text-white hidden md:flex">Approve</button>
                                    ) : (
                                        <button onClick={() => rejectComment(comment.commentId as string)} className="btn btn-sm bg-yellow-500 text-white hidden md:flex">Reject</button>
                                    )}
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            <div className="flex justify-between items-center mt-4">
                <div>
                    <span>Showing {comments.length} of {total} comments</span>
                </div>
                <div className="flex gap-2">
                    <button onClick={() => setPage(page - 1)} disabled={page === 0} className="btn btn-sm btn-secondary h-12">Previous</button>
                    <button onClick={() => setPage(page + 1)} disabled={(page + 1) * pageSize >= total} className="btn btn-sm btn-secondary h-12">Next</button>
                </div>
            </div>
        </div>
    );
};

export default CommentTable;

=== ./components/admin/Tables/UserTable.tsx ===
'use client'
import React, { useState, useEffect } from 'react';
import Link from 'next/link';
import Image from 'next/image';
import axiosInstance from '@/libs/axios';
import { User } from '@prisma/client';
import { toast } from 'react-toastify';

const UserTable = () => {

    const [users, setUsers] = React.useState<Partial<User>[]>([]);
    const [page, setPage] = React.useState(0);
    const [pageSize, setPageSize] = React.useState(10);
    const [total, setTotal] = React.useState(0);

    const [search, setSearch] = React.useState('');

    useEffect(() => {

        axiosInstance.get(`/api/users?page=${page + 1}&pageSize=${pageSize}&search=${search}`)
            .then((response) => {
                setUsers(response.data.users);
                setTotal(response.data.total);
            })
            .catch((error) => {
            });
    }
        , [page, pageSize, search]);


    const deleteUser = async (userId: string) => {
        //confirm
        if (!confirm('Are you sure you want to delete this user?')) {
            return;
        }
        //delete
        await axiosInstance.delete(`/api/users/${userId}`).then((response) => {
            toast.success(response.data.message || 'User deleted successfully.');
            setUsers(users.filter(user => user.userId !== userId));
        }).catch((error) => {
            toast.error(error.response.data.message || 'Failed to delete user.');
        }
        );

    }


    return (
        <div className="container mx-auto">
            <div className="flex justify-between md:items-center flex-col md:flex-row">
                <h1 className="text-3xl font-bold h-16 md:items-center">Users</h1>
                <div className="flex gap-2 h-16 w-full md:w-auto md:flex-none">
                    <input type="text" placeholder="Search" className="input input-bordered flex-1 md:flex-none" value={search} onChange={(e) => setSearch(e.target.value)} />
                    <Link className="btn btn-primary btn-sm h-12" href="/admin/users/create">
                        Create User
                    </Link>
                </div>
            </div>


            <div className="overflow-x-auto w-full bg-base-200 mt-4 rounded-lg min-h-[400px]">
                <table className="table">
                    {/* head */}
                    <thead className="bg-base-300 h-12">
                        <tr className="h-12">
                            <th>Image</th>
                            <th>Name</th>
                            <th>Email</th>
                            <th>Role</th>
                            <th>User Slug</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        {users.map((user, index) => (
                            <tr key={index} className="h-12 hover:bg-primary hover:bg-opacity-10">
                                <td>
                                    {user.image ?
                                        <Image width={32} height={32} src={user.image} className="h-8 w-8 rounded-full" alt={user.name as string} />
                                        :
                                        <div className="h-8 w-8 bg-base-300 rounded-full"></div>
                                    }
                                </td>
                                <td>{user.name}</td>
                                <td>{user.email}</td>
                                <td>{user.role}</td>
                                <td>{user.slug}</td>
                                <td className="flex gap-2">
                                    <Link href={`/admin/users/${user.userId}`} className="btn btn-sm btn-primary">Edit</Link>
                                    <Link href={`/blog/${user.slug}`} className="btn btn-sm btn-secondary hidden md:flex">View</Link>
                                    <button onClick={() => deleteUser(user.userId as string)} className="btn btn-sm btn-warning hidden md:flex">Delete</button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            <div className="flex justify-between items-center mt-4">
                <div>
                    <span>Showing {users.length} of {total} users</span>
                </div>
                <div className="flex gap-2">
                    <button onClick={() => setPage(page - 1)} disabled={page === 0} className="btn btn-sm btn-secondary h-12">Previous</button>
                    <button onClick={() => setPage(page + 1)} disabled={(page + 1) * pageSize >= total} className="btn btn-sm btn-secondary h-12">Next</button>
                </div>
            </div>
        </div>
    );
};

export default UserTable;

=== ./components/admin/Tables/ProjectLinkTable.tsx ===
'use client'
import React from 'react';
const ProjectLinkTable = ({ projectLinks, setProjectLinks }: { projectLinks: string[], setProjectLinks: (value: string[]) => void }) => {


    return (
        <div className="overflow-x-auto w-full bg-base-100 mt-4 rounded-lg min-h-[400px]">
            <table className="table w-full">
                <thead>
                    <tr>
                        <th>URL</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    {projectLinks?.map((link : string, index: number) => {
                                            
                        return (
                            <tr>
                                <td className="">
                                    <input type="text" name="url" className="input input-bordered w-full"
                                    onChange={(e) => {
                                        setProjectLinks([...projectLinks.slice(0, index), e.target.value, ...projectLinks.slice(index + 1)]);
                                    }
                                    } value={link} />
                                </td>
                                <td>
                                    <button onClick={() => {
                                        setProjectLinks([...projectLinks.slice(0, index), ...projectLinks.slice(index + 1)]);
                                    }} className="btn btn-sm btn-error">Delete</button>
                                </td>
                            </tr>
                        );
                    })}
                </tbody>
            </table>
        </div>
    );

}


export default ProjectLinkTable;


=== ./components/admin/Tables/PostTable.tsx ===
'use client'
import React from 'react';
import { PostWithData } from '@/types/BlogTypes';
import Link from 'next/link';
import Image from 'next/image';
import axiosInstance from '@/libs/axios';
import { Category } from '@prisma/client';
import { useRouter } from 'next/navigation';

const PostTable = ({ category }: { category?: Category }) => {

    const [search, setSearch] = React.useState('');
    const [posts, setPosts] = React.useState<Partial<PostWithData>[]>([]);
    const [page, setPage] = React.useState(0);
    const [pageSize, setPageSize] = React.useState(10);
    const [total, setTotal] = React.useState(0);

    const router = useRouter();

    React.useEffect(() => {

        axiosInstance.get("/api/posts" + `?page=${page + 1}&pageSize=${pageSize}&search=${search}&sort=desc&status=ALL` + (category ? `&categoryId=${category.categoryId}` : ''))
            .then((response) => {
                setPosts(response.data.posts);
                setTotal(response.data.total);
            })
            .catch((error) => {
                console.error(error);
            });
    }
        , [page, pageSize, search]);

    const deletePost = async (postId: string) => {
        //confirm
        if (!confirm('Are you sure you want to delete this post?')) {
            return;
        }

        //delete
        try {
            await axiosInstance.delete(`/api/posts/${postId}`);
            setPosts(posts.filter(post => post.postId !== postId));
        } catch (error) {
            console.error(error);
        }
    }

    return (
        <div className="container mx-auto">
            <div className="flex justify-between md:items-center flex-col md:flex-row">
                <h1 className="text-3xl font-bold h-16 md:items-center">{category ? category.title + " Posts" : "Posts"}</h1>
                <div className="flex gap-2 h-16 w-full md:w-auto md:flex-none">
                    <input type="text" placeholder="Search" className="input input-bordered flex-1 md:flex-none" value={search} onChange={(e) => setSearch(e.target.value)} />
                    <Link className="btn btn-primary btn-sm h-12" href="/admin/posts/create">
                        Create Post
                    </Link>
                </div>
            </div>

            <div className="overflow-x-auto w-full bg-base-200 mt-4 rounded-lg min-h-[400px]">
                <table className="table">
                    {/* head */}
                    <thead className="bg-base-300 h-12">
                        <tr className="h-12">
                            <th className="w-16">
                            </th>
                            <th>
                                Title
                            </th>
                            <th className="max-w-20">
                                Category</th>
                            <th className="max-w-16">
                                Slug</th>
                            <th>Status</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        {posts.map((post, index) => (
                            <tr key={index} className="h-12 hover:bg-primary hover:bg-opacity-10">
                                <td>
                                    {post.image ?
                                        <Image width={32} height={32} src={post.image} className="h-8 w-8 rounded-full" alt={post.title as string} />
                                        :
                                        <div className="h-8 w-8 bg-base-300 rounded-full"></div>
                                    }
                                </td>
                                <td>{post.title}</td>
                                <td>{post.category?.title}</td>
                                <td>{post.slug}</td>
                                <td>{post.status}</td>
                                <td className="flex gap-2">
                                    <Link href={`/admin/posts/${post.postId}`} className="btn btn-sm btn-primary">Edit</Link>
                                    <Link href={`/blog/${post.category?.slug}/${post.slug}`} className="btn btn-sm btn-secondary">View</Link>
                                    <button onClick={() => deletePost(post.postId as string)} className="btn btn-sm bg-red-500 text-white hidden md:flex">Delete</button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            <div className="flex justify-between items-center mt-4">
                <div>
                    <span>Showing {posts.length} of {total} posts</span>
                </div>
                <div className="flex gap-2">
                    <button onClick={() => setPage(page - 1)} disabled={page === 0} className="btn btn-sm btn-secondary h-12">Previous</button>
                    <button onClick={() => setPage(page + 1)} disabled={(page + 1) * pageSize >= total} className="btn btn-sm btn-secondary h-12">Next</button>
                </div>
            </div>
        </div>
    );
};

export default PostTable;

=== ./components/admin/Tables/CategoryTable.tsx ===
'use client'
import React, { useState, useEffect } from 'react';
import Link from "next/link";
import { Category } from "@prisma/client";
import axiosInstance from "@/libs/axios";
import Image from 'next/image';


const CategoryTable = () => {
    const [categories, setCategories] = useState<Category[]>([]);
    const [page, setPage] = React.useState(0);
    const [pageSize, setPageSize] = React.useState(10);
    const [total, setTotal] = React.useState(0);

    const [search, setSearch] = React.useState('');

    useEffect(() => {

        axiosInstance.get(`/api/categories?page=${page + 1}&pageSize=${pageSize}&search=${search}`)
            .then((response) => {
                setCategories(response.data.categories);
                setTotal(response.data.total);
            })
            .catch((error) => {
                console.error(error);
            });
    }
        , [page, pageSize, search]);


    const deleteCategory = async (categoryId: string) => {
        //confirm
        if (!confirm('Are you sure you want to delete this category?')) {
            return;
        }

        //delete
        try {
            await axiosInstance.delete(`/api/categories/${categoryId}`);
            setCategories(categories.filter((category) => category.categoryId !== categoryId));
        } catch (error) {
            console.error(error);
        }
    }


    return (
        <div className="container mx-auto">
            <div className="flex justify-between md:items-center flex-col md:flex-row">
                <h1 className="text-3xl font-bold h-16 md:items-center">Categories</h1>
                <div className="flex gap-2 h-16 w-full md:w-auto md:flex-none">
                    <input type="text" placeholder="Search" className="input input-bordered flex-1 md:flex-none" value={search} onChange={(e) => setSearch(e.target.value)} />
                    <Link className="btn btn-primary btn-sm h-12" href="/admin/categories/create">
                        Create Category
                    </Link>
                </div>
            </div>


            <div className="overflow-x-auto w-full bg-base-200 mt-4 rounded-lg min-h-[400px]">
                <table className="table">
                    {/* head */}
                    <thead className="bg-base-300 h-12">
                        <tr className="h-12">
                            <th>Image</th>
                            <th>Title</th>
                            <th>Slug</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        {categories.map((category, index) => (
                            <tr key={index} className="releative h-12 hover:bg-primary hover:bg-opacity-10">

                                <td>
                                    {category.image ?
                                        <Image width={32} height={32} src={category.image} className="h-8 w-8 rounded-full" alt={category.title} />
                                        :
                                        <div className="h-8 w-8 bg-base-300 rounded-full"></div>
                                    }
                                </td>
                                <td>{category.title}</td>
                                <td>{category.slug}</td>
                                <td className="flex gap-2 absolute right-4">
                                    <Link href={`/admin/categories/${category.categoryId}`} className="btn btn-sm btn-secondary hidden md:flex">Edit</Link>
                                    <Link href={`/blog/${category.slug}`} className="btn btn-sm btn-primary hidden md:flex">View</Link>
                                    <Link href={`/admin/categories/${category.categoryId}/posts`} className="btn btn-sm btn-warning hidden md:flex">Posts</Link>
                                    <button onClick={() => deleteCategory(category.categoryId)} className="btn btn-sm btn-secondary">Delete</button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            <div className="flex justify-between mt-3">
                <div>
                    <span>Showing {categories.length} of {total} categories</span>
                </div>
                <div className="flex gap-2">
                    <button onClick={() => setPage(page - 1)} disabled={page === 0} className="btn btn-sm btn-secondary h-12">Previous</button>
                    <button onClick={() => setPage(page + 1)} disabled={(page + 1) * pageSize >= total} className="btn btn-sm btn-secondary h-12">Next</button>
                </div>
            </div>
        </div>
    );
}

export default CategoryTable;

=== ./components/admin/Navbar/index.tsx ===
'use client';
import { faBars, faCaretDown, faTicket, faUser, faCode } from "@fortawesome/free-solid-svg-icons";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { useState } from "react";
import Link from "next/link";
import { createHash } from "crypto";
import useGlobalStore from "@/libs/zustand";

import ThemeButton from "./Partials/ThemeButton";
import Image from "next/image";
import { useRouter } from "next/navigation";
import Logo from "@/components/common/Logo";

const Navbar = () => {

    const router = useRouter();

    const { user } = useGlobalStore();

    const email = user?.email;
    const hash = createHash('sha256').digest('hex');
    const gravitarUrl = `https://www.gravatar.com/avatar/${hash}?d=identicon`;


    const [isFeaturesMenuOpen, setIsFeaturesMenuOpen] = useState(false);
    const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);

    const toggleFeaturesMenu = () => {
        setIsFeaturesMenuOpen(!isFeaturesMenuOpen);
    };

    const toggleMobileMenu = () => {
        setIsMobileMenuOpen(!isMobileMenuOpen);
    };

    const menu = [
        {
            name: "Home",
            href: "/admin",
        },
        {
            name: "Projects",
            href: "/admin/projects",
        },
        {
            name: "Categories",
            href: "/admin/categories",
        },
        {
            name: "Posts",
            href: "/admin/posts",
        },
        {
            name: "Comments",
            href: "/admin/comments",
        },
        {
            name: "Users",
            href: "/admin/users",
        },
        {
            name: "Slots",
            href: "/admin/slots",
        },
        {
            name: "Settings",
            href: "/admin/settings",
        }
    ];

    return (
        <>
            <div className="">
                <nav className="mx-auto h-16 flex items-stretch items-center justify-between lg:px-8 from-base-100 to-base-300 bg-gradient-to-b shadow-lg text-primary" aria-label="Global">
                    <div className="py-4 pl-4 lg:pl-0 flex items-center gap-2">
                        <Logo href="/admin" />
                        <ThemeButton />
                    </div>
                    <div className="flex lg:hidden">
                        <button type="button" className="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 p-6 mr-2" aria-controls="mobile-menu" aria-expanded="false" onClick={toggleMobileMenu}>
                            <span className="sr-only">Open main menu</span>
                            <FontAwesomeIcon
                                icon={faBars}
                                className="h-6 w-6"
                                aria-hidden="true"
                            />
                        </button>
                    </div>
                    <div className="hidden lg:flex lg:flex-1 lg:justify-center">
                        {menu.map((item, index) => (
                            <Link key={index} href={item.href} className="relative group inline-flex items-center justify-center text-base font-medium px-6">
                                <div className="text-sm leading-6">{item.name}</div>
                            </Link>
                        ))}
                    </div>
                    <div className="hidden lg:flex lg:justify-end justify-center items-center">
                        <span className="text-sm font-semibold leading-6 text-primary px-4 py-2">{user?.name ? user?.name : email?.split('@')[0]}</span>
                        <Link href="#" className="flex items-center justify-center border-2 border-primary rounded-full">
                            <Image width={48} height={48}
                                src={user?.profilePicture ? user?.profilePicture : gravitarUrl} alt="User Image" className="w-12 h-12 rounded-full" />
                        </Link>
                    </div>
                </nav>
            </div>
            {/* Mobile menu, show/hide based on mobile menu state. with dimming overlay */}
            <div className={`${isMobileMenuOpen ? "block" : "hidden"} lg:hidden`} id="mobile-menu" style={{ position: "fixed", zIndex: 100 }}>
                <div className="fixed inset-0 z-40 flex">
                    <div className="fixed inset-0" onClick={toggleMobileMenu}>
                        <div className="absolute inset-0 bg-base-200 opacity-75"></div>
                    </div>
                    <div className="relative flex-1 flex flex-col max-w-xs w-full bg-base-100">
                        <div className="flex-1 h-0 pt-5 pb-4 overflow-y-auto">
                            <div className="flex items-center justify-center">
                                <Link href="/admin" className="flex items-center">
                                    <FontAwesomeIcon icon={faCode} className="text-primary w-8 h-8 mr-2" />
                                    <span className="text-primary text-2xl font-bold">kuray.dev</span>
                                </Link>
                            </div>
                            <nav className="mt-5 px-2 space-y-1">
                                {menu.map((item, index) => (
                                    <button key={index} className="block px-3 py-2 rounded-md text-base font-medium"
                                        onClick={() => {
                                            router.push(item.href);
                                            toggleMobileMenu();
                                        }}>
                                        {item.name}
                                    </button>
                                ))}
                            </nav>
                        </div>
                        <div className="flex justify-center pb-4">
                            <Link href="/auth/login" className="btn text-sm font-semibold leading-6 bg-primary text-base rounded-s">Log in</Link>
                        </div>
                    </div>
                </div>
            </div>
        </>

    )
};

export default Navbar;

=== ./components/admin/Navbar/Partials/ThemeButton.tsx ===
// Implementation of ThemeButton component in components/admin/Navbar/index.tsx:
import ThemeButton from "@/components/frontend/Navbar/Partials/ThemeButton";
export default ThemeButton;


=== ./components/admin/Navbar/Menu/index.tsx ===


=== ./components/admin/Posts/PostsTable.tsx ===
import React from 'react';
import Image from 'next/image';
import { Post } from '@prisma/client';

const PostsTable = () => {


    return (
        <div className="overflow-x-auto">
            <table className="table">
                {/* head */}
                <thead>
                    <tr>
                        <th>
                            <label>
                                <input type="checkbox" className="checkbox" />
                            </label>
                        </th>
                        <th>Name</th>
                        <th>Job</th>
                        <th>Favorite Color</th>
                        <th></th>
                    </tr>
                </thead>
                <tbody>
                    {/* row 1 */}
                    <tr>
                        <th>
                            <label>
                                <input type="checkbox" className="checkbox" />
                            </label>
                        </th>
                        <td>
                            <div className="flex items-center gap-3">
                                <div className="avatar">
                                    <div className="mask mask-squircle h-12 w-12">
                                        <Image
                                            src="https://img.daisyui.com/images/profile/demo/2@94.webp"
                                            alt="Avatar Tailwind CSS Component" />
                                    </div>
                                </div>
                                <div>
                                    <div className="font-bold">Hart Hagerty</div>
                                    <div className="text-sm opacity-50">United States</div>
                                </div>
                            </div>
                        </td>
                        <td>
                            Zemlak, Daniel and Leannon
                            <br />
                            <span className="badge badge-ghost badge-sm">Desktop Support Technician</span>
                        </td>
                        <td>Purple</td>
                        <th>
                            <button className="btn btn-ghost btn-xs">details</button>
                        </th>
                    </tr>
                    {/* row 2 */}
                    <tr>
                        <th>
                            <label>
                                <input type="checkbox" className="checkbox" />
                            </label>
                        </th>
                        <td>
                            <div className="flex items-center gap-3">
                                <div className="avatar">
                                    <div className="mask mask-squircle h-12 w-12">
                                        <Image
                                            src="https://img.daisyui.com/images/profile/demo/3@94.webp"
                                            alt="Avatar Tailwind CSS Component" />
                                    </div>
                                </div>
                                <div>
                                    <div className="font-bold">Brice Swyre</div>
                                    <div className="text-sm opacity-50">China</div>
                                </div>
                            </div>
                        </td>
                        <td>
                            Carroll Group
                            <br />
                            <span className="badge badge-ghost badge-sm">Tax Accountant</span>
                        </td>
                        <td>Red</td>
                        <th>
                            <button className="btn btn-ghost btn-xs">details</button>
                        </th>
                    </tr>
                    {/* row 3 */}
                    <tr>
                        <th>
                            <label>
                                <input type="checkbox" className="checkbox" />
                            </label>
                        </th>
                        <td>
                            <div className="flex items-center gap-3">
                                <div className="avatar">
                                    <div className="mask mask-squircle h-12 w-12">
                                        <Image
                                            src="https://img.daisyui.com/images/profile/demo/4@94.webp"
                                            alt="Avatar Tailwind CSS Component" />
                                    </div>
                                </div>
                                <div>
                                    <div className="font-bold">Marjy Ferencz</div>
                                    <div className="text-sm opacity-50">Russia</div>
                                </div>
                            </div>
                        </td>
                        <td>
                            Rowe-Schoen
                            <br />
                            <span className="badge badge-ghost badge-sm">Office Assistant I</span>
                        </td>
                        <td>Crimson</td>
                        <th>
                            <button className="btn btn-ghost btn-xs">details</button>
                        </th>
                    </tr>
                    {/* row 4 */}
                    <tr>
                        <th>
                            <label>
                                <input type="checkbox" className="checkbox" />
                            </label>
                        </th>
                        <td>
                            <div className="flex items-center gap-3">
                                <div className="avatar">
                                    <div className="mask mask-squircle h-12 w-12">
                                        <Image
                                            src="https://img.daisyui.com/images/profile/demo/5@94.webp"
                                            alt="Avatar Tailwind CSS Component" />
                                    </div>
                                </div>
                                <div>
                                    <div className="font-bold">Yancy Tear</div>
                                    <div className="text-sm opacity-50">Brazil</div>
                                </div>
                            </div>
                        </td>
                        <td>
                            Wyman-Ledner
                            <br />
                            <span className="badge badge-ghost badge-sm">Community Outreach Specialist</span>
                        </td>
                        <td>Indigo</td>
                        <th>
                            <button className="btn btn-ghost btn-xs">details</button>
                        </th>
                    </tr>
                </tbody>
                {/* foot */}
                <tfoot>
                    <tr>
                        <th></th>
                        <th>Name</th>
                        <th>Job</th>
                        <th>Favorite Color</th>
                        <th></th>
                    </tr>
                </tfoot>
            </table>
        </div>
    );
};

export default PostsTable;

=== ./components/admin/Editor/index.tsx ===
'use client';
import React, { useRef } from 'react';
import { Editor as TinyMCEEditorType } from 'tinymce';
import { Editor } from '@tinymce/tinymce-react';
import axiosInstance from '@/libs/axios';


const NEXT_PUBLIC_TINYMCE_API_KEY = process.env.NEXT_PUBLIC_TINYMCE_API_KEY;

const TinyMCEEditor = ({ value, onChange }: { value: string, onChange: (value: string) => void }) => {
    function onInit(evt: any, editor: TinyMCEEditorType) {
    }


    const image_upload_handler = (blobInfo : any, progress : any) => new Promise(async (resolve, reject) => {
       
        const formData = new FormData();
        formData.append('file', blobInfo.blob(), blobInfo.filename());
        formData.append('folder', 'categories');

        await axiosInstance.post('/api/aws', formData, {
            headers: {
                'Content-Type': 'multipart/form-data'
            }
        }).then((res) => {
            resolve(res.data.url);
        }
        ).catch((error) => {
            reject('Error uploading image');
        });
        
    });

    return (
        <Editor
            apiKey={NEXT_PUBLIC_TINYMCE_API_KEY}
            onInit={onInit}
            value={value}
            onEditorChange={(newValue) => onChange(newValue)}
            init={{
                height: 500,
                menubar: false,
                plugins: [
                    'advlist', 'autolink', 'lists', 'link', 'image ', 'charmap', 'preview',
                    'anchor', 'searchreplace', 'visualblocks', 'code', 'fullscreen',
                    'insertdatetime', 'media', 'table', 'code', 'help', 'wordcount'
                ],
                toolbar: 'undo redo | blocks | image | bold italic forecolor | ' +
                    'alignleft aligncenter alignright alignjustify | ' +
                    'bullist numlist outdent indent | removeformat | help',
                content_style: 'body { font-family:Helvetica,Arial,sans-serif; font-size:14px; background-color: transparent; }',
                images_upload_handler: image_upload_handler as any
            }}

        />
    );
}

export default TinyMCEEditor;

=== ./components/admin/StatsSection/index.tsx ===
'use client';
import React, { useEffect } from "react";
import StatCard from "./Partials/StatCard";
import { faUserAlt, faBlog, faEye, faFolder, faComment, faStar, faHeart, faClock, faChartLine, faThumbsUp } from "@fortawesome/free-solid-svg-icons";
import axiosInstance from "@/libs/axios";

const StatsSection = () => {

  const [loading, setLoading] = React.useState(true);
  const [values, setValues] = React.useState({
    totalPosts: 0,
    totalCategories: 0,
    totalUsers: 0,
    totalViews: 0,
    totalComments: 0
  });

  async function getStats() {
    await axiosInstance.get(`/api/stats`).then((res) => {
      setValues(res.data.values);
    }).catch((err) => {
    });
  }

  useEffect(() => {
    if (loading) {
      setLoading(false);
      getStats();
    }
  }, []);



  const stats = [
    {
      icon: faUserAlt,
      title: "Users",
      value: values.totalUsers,
      description: "Total users"
    },
    {
      icon: faBlog,
      title: "Posts",
      value: values.totalPosts,
      description: "Total posts"
    },
    {
      icon: faEye,
      title: "Views",
      value: values.totalViews,
      description: "Total views"
    },
    {
      icon: faFolder,
      title: "Categories",
      value: values.totalCategories,
      description: "Total categories"
    },
    {
      icon: faComment,
      title: "Comments",
      value: values.totalComments,
      description: "Total comments"
    }
  ];


  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {stats.map((stat, index) => (
        <StatCard key={index} {...stat} />
      ))}
    </div>
  );
};

export default StatsSection;

=== ./components/admin/StatsSection/Partials/StatCard.tsx ===
import { FontAwesomeIcon, } from '@fortawesome/react-fontawesome';
import { IconDefinition } from '@fortawesome/free-solid-svg-icons';
import React from 'react';

const StatCard = (
  { icon, title, value, description } : 
  { icon: IconDefinition, title: string, value: any, description: string }
) => {
  return (
    <div className="flex items-center p-4 bg-base-200 rounded-lg shadow-md h-32 min-w-60">
      <div className="flex-shrink-0 w-12 h-12 bg-primary text-base-100 rounded-full flex items-center justify-center">
        <FontAwesomeIcon icon={icon} width={24} height={24} />
      </div>
      <div className="ml-4">
        <h4 className="text-lg font-medium">{title}</h4>
        <p className="text-2xl font-bold">{value}</p>
        <p className="text-sm">{description}</p>
      </div>
    </div>
  );
};

export default StatCard;

=== ./components/common/Loading/index.tsx ===
import React from 'react';

const Loading: React.FC = () => {
    return (
        <div className="fixed left-0 top-0 z-50 block h-full w-full bg-white opacity-75">
            <span className="r-4 relative top-1/2 mx-auto my-0 block h-0 w-0 text-green-500 opacity-75">
                <div role="status">
                    <svg aria-hidden="true" className="mr-8 h-8 w-8 animate-spin fill-primary" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg" > <path d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z" fill="currentColor" /> <path d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z" fill="currentFill" />
                    </svg>
                    <span className="sr-only">Loading...</span>
                </div>
            </span>
        </div>
    );
};

export default Loading;

=== ./components/common/ImageLoad/index.tsx ===
'use client';
import React, { useState, useEffect, use } from 'react';
import axiosInstance from '@/libs/axios';
interface ImageLoadProps {
    image: string;
    setImage: (value: string) => void;
    uploadFolder?: string;
    toast?: any;
}

const ImageLoad = ({ image, setImage, uploadFolder = 'default', toast }: ImageLoadProps) => {

    const [imageFile, setImageFile] = useState<File | null>(null);

    const uploadImage = async () => {
        if (!imageFile) {
            return;
        }

        const formData = new FormData();
        formData.append('file', imageFile);
        formData.append('folder', 'categories');

        await axiosInstance.post('/api/aws', formData, {
            headers: {
                'Content-Type': 'multipart/form-data'
            }
        }).then((res) => {

            setImage(res.data.url);
            if (toast) { toast.success('Image uploaded successfully'); }

        }).catch((error) => {
            if (toast) { toast.error('Error uploading image'); } else { console.error(error); }
        });
    }


    return (
        <>
            <img src={image ? image as string : 'https://placehold.co/384x256'}
                width={384} height={256}
                alt="Image" className="h-64 w-96 object-cover rounded-lg" />
            <div className="relative flex justify-between items-center">
                <input
                    type="file"
                    placeholder="Image URL"
                    className="input input-bordered mt-2 p-4 flex-1 h-16"
                    //only jpg, jpeg, png
                    accept="image/jpeg, image/png"

                    onChange={(e) => {
                        const file = e.target.files?.[0];
                        if (file) {
                            setImageFile(file);
                            //setImageUrl(URL.createObjectURL(file));
                        }
                    }}
                />
                <div className="absolute right-2 top-2 p-2 rounded-lg">
                    <button type="button" className="h-12 p-2 rounded-lg bg-primary mr-2 text-white" onClick={uploadImage}>
                        Upload Image
                    </button>
                </div>
            </div>
        </>
    );
};

export default ImageLoad;

=== ./components/common/Logo/index.tsx ===
import React from 'react'

import { FontAwesomeIcon } from '@fortawesome/react-fontawesome'
import { faCode } from '@fortawesome/free-solid-svg-icons'
import Link from 'next/link'
interface LogoProps {
  className?: string
  iconClassName?: string
  textClassName?: string
  href?: string
}

const Logo: React.FC = ({ 
  className = "btn btn-ghost md:rounded-full hover:bg-transparent active:bg-transparent focus:bg-transparent focus:outline-none focus:ring-0 focus:ring-offset-0 disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-transparent disabled:focus:bg-transparent disabled:active:bg-transparent disabled:focus:ring-0 disabled:focus:outline-none"
, iconClassName = "text-2xl w-6", textClassName = "text-lg font-bold", href = "/" }: LogoProps) => (
  <Link className={className} href={href} onClick={() => window.scrollTo(0, 0)}>
    <FontAwesomeIcon icon={faCode} className={iconClassName} />
    <span className={textClassName + ' ml-1'}>kuray.dev</span>
  </Link>
)

export default Logo


=== ./components/auth/SSOLogin/index.tsx ===
'use client'
import React, { useMemo, useCallback } from 'react'
import { useRouter } from 'next/navigation'
import axiosInstance from '@/libs/axios'
import { toast } from 'react-toastify'

import { FontAwesomeIcon } from '@fortawesome/react-fontawesome'
import {
  faApple,
  faGithub,
  faGoogle,
  faMicrosoft,
  faFacebook,
  faTwitter,
  faTiktok
} from '@fortawesome/free-brands-svg-icons'
import { faPeopleGroup } from '@fortawesome/free-solid-svg-icons'
import { IconDefinition } from '@fortawesome/fontawesome-svg-core'

const AutodeskIcon: IconDefinition = {
  prefix: 'fab',
  //@ts-ignore
  iconName: 'autodesk',
  icon: [
    24,
    24,
    [],
    '',
    'M14.574 1.0203c-0.097-0.096997-0.29099-0.58198-0.97097-0.58198h-6.7038s0.97097 0.096997 1.36 1.068c0 0 1.069 2.5269 2.0399 4.9558 2.8179 6.6068 7.1898 17.099 7.1898 17.099h6.5108c0.097-0.097-9.3267-22.443-9.4247-22.54zm-8.8407 0.87497-5.3438 12.631c-0.29199 0.87497-0.097997 1.9439 1.457 1.9439h4.1779l3.6919-8.8417c-1.166-2.9149-2.1359-5.2478-2.1359-5.2478-0.096997-0.29199-0.38899-1.069-0.97197-1.069-0.58298 0-0.77698 0.48598-0.87397 0.58298zm-0.097997 15.643h-4.4689c-0.77698 0-1.166-0.48598-1.166-0.48598 0.77698 1.36 3.0119 5.6358 3.0119 5.6358 0.38899 0.48598 0.77698 0.77698 1.36 0.77698 1.263 0 3.2069-1.263 3.2069-1.263l7.4808-4.6639z'
  ]
}

const buttonMap: Record<string, { bg: string; hover: string; text: string; icon: IconDefinition }> = {
  google: { bg: 'bg-[#4285F4]', hover: 'hover:bg-[#357AE8]', text: 'text-white', icon: faGoogle },
  apple: { bg: 'bg-black', hover: 'hover:bg-gray-800', text: 'text-white', icon: faApple },
  autodesk: { bg: 'bg-[#FF6A13]', hover: 'hover:bg-[#FF4C00]', text: 'text-white', icon: AutodeskIcon },
  github: { bg: 'bg-[#333]', hover: 'hover:bg-[#222]', text: 'text-white', icon: faGithub },
  microsoft: { bg: 'bg-[#0078D4]', hover: 'hover:bg-[#005A9E]', text: 'text-white', icon: faMicrosoft },
  facebook: { bg: 'bg-[#3b5998]', hover: 'hover:bg-[#2d4373]', text: 'text-white', icon: faFacebook },
  twitter: { bg: 'bg-[#1DA1F2]', hover: 'hover:bg-[#0d95e8]', text: 'text-white', icon: faTwitter },
  tiktok: { bg: 'bg-black', hover: 'hover:bg-gray-900', text: 'text-white', icon: faTiktok }
}

type SSOLoginMode = 'modal' | 'pins' | 'list'

interface SSOLoginProps {
  mode?: SSOLoginMode
}

const SSOLoginContent: React.FC<SSOLoginProps> = ({ mode }) => {
  const router = useRouter()

  const allowedProviders = useMemo(() => {
    return (process.env.SSO_ALLOWED_PROVIDERS || '')
      .split(',')
      .map(p => p.trim())
      .filter(Boolean)
  }, [])

  const handleLogin = useCallback(
    async (provider: string) => {
      if (!allowedProviders.includes(provider)) {
        toast.error(`SSO login for ${provider} is not allowed.`)
        return
      }
      try {
        const res = await axiosInstance.get(`/api/auth/sso/${provider}`)
        window.location.href = res.data.url
      } catch (e) {
        toast.error('SSO yönlendirme hatası.')
        console.error(e)
      }
    },
    [allowedProviders]
  )

  if (allowedProviders.length === 0) {
    return (
      <div className='text-center text-sm text-gray-500'>
        No SSO providers configured.
      </div>
    )
  }

  const renderButton = (provider: string, circle = false) => {
    const config = buttonMap[provider]
    const classes = `btn ${circle ? 'btn-circle' : 'btn-block'} ${config?.bg} ${config?.hover} ${config?.text} text-sm font-semibold`
    return (
      <button key={provider} className={classes} onClick={() => handleLogin(provider)}>
        <FontAwesomeIcon icon={config?.icon || faPeopleGroup} className='h-4 w-4' />
        {!circle && (
          <span className='ml-2'>
            Login with {provider.charAt(0).toUpperCase() + provider.slice(1)}
          </span>
        )}
      </button>
    )
  }

  return (
    <div className={mode === 'list' ? 'flex flex-col space-y-2' : 'flex flex-row flex-wrap space-x-2 justify-center'}>
      {allowedProviders.map(p => renderButton(p, mode !== 'list'))}
    </div>
  )
}

const SSOLogin: React.FC<SSOLoginProps> = ({ mode = 'list' }) => {
  if (mode === 'modal') {
    return (
      <>
        <button
          className='btn btn-primary btn-block text-sm text-white font-semibold leading-6'
          onClick={() => (document?.getElementById('sso_modal') as HTMLDialogElement)?.showModal()}
        >
          <FontAwesomeIcon icon={faPeopleGroup} className='h-4 w-4' />
          <span className='ml-2'>Login with Social Media</span>
        </button>
        <dialog id='sso_modal' className='modal'>
          <div className='modal-box'>
            <h3 className='font-bold text-lg mb-4'>Login with Social Media</h3>
            <SSOLoginContent mode='list' />
            <div className='modal-action'>
              <form method='dialog'>
                <button className='btn'>Close</button>
              </form>
            </div>
          </div>
        </dialog>
      </>
    )
  }

  return <SSOLoginContent mode={mode} />
}

export default SSOLogin


=== ./.next/types/validator.ts ===
// This file is generated automatically by Next.js
// Do not edit this file manually
// This file validates that all pages and layouts export the correct types

import type { AppRoutes, LayoutRoutes, ParamMap, AppRouteHandlerRoutes } from "./routes.js"
import type { ResolvingMetadata, ResolvingViewport } from "next/dist/lib/metadata/types/metadata-interface.js"
import type { NextRequest } from 'next/server.js'

type AppPageConfig<Route extends AppRoutes = AppRoutes> = {
  default: React.ComponentType<{ params: Promise<ParamMap[Route]> } & any> | ((props: { params: Promise<ParamMap[Route]> } & any) => React.ReactNode | Promise<React.ReactNode> | never | void | Promise<void>)
  generateStaticParams?: (props: { params: ParamMap[Route] }) => Promise<any[]> | any[]
  generateMetadata?: (
    props: { params: Promise<ParamMap[Route]> } & any,
    parent: ResolvingMetadata
  ) => Promise<any> | any
  generateViewport?: (
    props: { params: Promise<ParamMap[Route]> } & any,
    parent: ResolvingViewport
  ) => Promise<any> | any
  metadata?: any
  viewport?: any
}

type LayoutConfig<Route extends LayoutRoutes = LayoutRoutes> = {
  default: React.ComponentType<LayoutProps<Route>> | ((props: LayoutProps<Route>) => React.ReactNode | Promise<React.ReactNode> | never | void | Promise<void>)
  generateStaticParams?: (props: { params: ParamMap[Route] }) => Promise<any[]> | any[]
  generateMetadata?: (
    props: { params: Promise<ParamMap[Route]> } & any,
    parent: ResolvingMetadata
  ) => Promise<any> | any
  generateViewport?: (
    props: { params: Promise<ParamMap[Route]> } & any,
    parent: ResolvingViewport
  ) => Promise<any> | any
  metadata?: any
  viewport?: any
}

type RouteHandlerConfig<Route extends AppRouteHandlerRoutes = AppRouteHandlerRoutes> = {
  GET?: (request: NextRequest, context: { params: Promise<ParamMap[Route]> }) => Promise<Response | void> | Response | void
  POST?: (request: NextRequest, context: { params: Promise<ParamMap[Route]> }) => Promise<Response | void> | Response | void
  PUT?: (request: NextRequest, context: { params: Promise<ParamMap[Route]> }) => Promise<Response | void> | Response | void
  PATCH?: (request: NextRequest, context: { params: Promise<ParamMap[Route]> }) => Promise<Response | void> | Response | void
  DELETE?: (request: NextRequest, context: { params: Promise<ParamMap[Route]> }) => Promise<Response | void> | Response | void
  HEAD?: (request: NextRequest, context: { params: Promise<ParamMap[Route]> }) => Promise<Response | void> | Response | void
  OPTIONS?: (request: NextRequest, context: { params: Promise<ParamMap[Route]> }) => Promise<Response | void> | Response | void
}


// Validate ../../app/(admin)/admin/categories/[categoryId]/page.tsx
{
  const handler = {} as typeof import("../../app/(admin)/admin/categories/[categoryId]/page.js")
  handler satisfies AppPageConfig<"/admin/categories/[categoryId]">
}

// Validate ../../app/(admin)/admin/categories/[categoryId]/posts/page.tsx
{
  const handler = {} as typeof import("../../app/(admin)/admin/categories/[categoryId]/posts/page.js")
  handler satisfies AppPageConfig<"/admin/categories/[categoryId]/posts">
}

// Validate ../../app/(admin)/admin/categories/create/page.tsx
{
  const handler = {} as typeof import("../../app/(admin)/admin/categories/create/page.js")
  handler satisfies AppPageConfig<"/admin/categories/create">
}

// Validate ../../app/(admin)/admin/categories/page.tsx
{
  const handler = {} as typeof import("../../app/(admin)/admin/categories/page.js")
  handler satisfies AppPageConfig<"/admin/categories">
}

// Validate ../../app/(admin)/admin/comments/page.tsx
{
  const handler = {} as typeof import("../../app/(admin)/admin/comments/page.js")
  handler satisfies AppPageConfig<"/admin/comments">
}

// Validate ../../app/(admin)/admin/page.tsx
{
  const handler = {} as typeof import("../../app/(admin)/admin/page.js")
  handler satisfies AppPageConfig<"/admin">
}

// Validate ../../app/(admin)/admin/posts/[postId]/page.tsx
{
  const handler = {} as typeof import("../../app/(admin)/admin/posts/[postId]/page.js")
  handler satisfies AppPageConfig<"/admin/posts/[postId]">
}

// Validate ../../app/(admin)/admin/posts/page.tsx
{
  const handler = {} as typeof import("../../app/(admin)/admin/posts/page.js")
  handler satisfies AppPageConfig<"/admin/posts">
}

// Validate ../../app/(admin)/admin/projects/[projectId]/page.tsx
{
  const handler = {} as typeof import("../../app/(admin)/admin/projects/[projectId]/page.js")
  handler satisfies AppPageConfig<"/admin/projects/[projectId]">
}

// Validate ../../app/(admin)/admin/projects/page.tsx
{
  const handler = {} as typeof import("../../app/(admin)/admin/projects/page.js")
  handler satisfies AppPageConfig<"/admin/projects">
}

// Validate ../../app/(admin)/admin/settings/page.tsx
{
  const handler = {} as typeof import("../../app/(admin)/admin/settings/page.js")
  handler satisfies AppPageConfig<"/admin/settings">
}

// Validate ../../app/(admin)/admin/slots/page.tsx
{
  const handler = {} as typeof import("../../app/(admin)/admin/slots/page.js")
  handler satisfies AppPageConfig<"/admin/slots">
}

// Validate ../../app/(admin)/admin/users/[userId]/page.tsx
{
  const handler = {} as typeof import("../../app/(admin)/admin/users/[userId]/page.js")
  handler satisfies AppPageConfig<"/admin/users/[userId]">
}

// Validate ../../app/(admin)/admin/users/create/page.tsx
{
  const handler = {} as typeof import("../../app/(admin)/admin/users/create/page.js")
  handler satisfies AppPageConfig<"/admin/users/create">
}

// Validate ../../app/(admin)/admin/users/page.tsx
{
  const handler = {} as typeof import("../../app/(admin)/admin/users/page.js")
  handler satisfies AppPageConfig<"/admin/users">
}

// Validate ../../app/(auth)/auth/callback/page.tsx
{
  const handler = {} as typeof import("../../app/(auth)/auth/callback/page.js")
  handler satisfies AppPageConfig<"/auth/callback">
}

// Validate ../../app/(auth)/auth/forgot-password/page.tsx
{
  const handler = {} as typeof import("../../app/(auth)/auth/forgot-password/page.js")
  handler satisfies AppPageConfig<"/auth/forgot-password">
}

// Validate ../../app/(auth)/auth/login/page.tsx
{
  const handler = {} as typeof import("../../app/(auth)/auth/login/page.js")
  handler satisfies AppPageConfig<"/auth/login">
}

// Validate ../../app/(auth)/auth/logout/page.tsx
{
  const handler = {} as typeof import("../../app/(auth)/auth/logout/page.js")
  handler satisfies AppPageConfig<"/auth/logout">
}

// Validate ../../app/(auth)/auth/register/page.tsx
{
  const handler = {} as typeof import("../../app/(auth)/auth/register/page.js")
  handler satisfies AppPageConfig<"/auth/register">
}

// Validate ../../app/(easter)/easter/terminal/page.tsx
{
  const handler = {} as typeof import("../../app/(easter)/easter/terminal/page.js")
  handler satisfies AppPageConfig<"/easter/terminal">
}

// Validate ../../app/(frontend)/blog/[categorySlug]/[postSlug]/page.tsx
{
  const handler = {} as typeof import("../../app/(frontend)/blog/[categorySlug]/[postSlug]/page.js")
  handler satisfies AppPageConfig<"/blog/[categorySlug]/[postSlug]">
}

// Validate ../../app/(frontend)/blog/[categorySlug]/page.tsx
{
  const handler = {} as typeof import("../../app/(frontend)/blog/[categorySlug]/page.js")
  handler satisfies AppPageConfig<"/blog/[categorySlug]">
}

// Validate ../../app/(frontend)/blog/page.tsx
{
  const handler = {} as typeof import("../../app/(frontend)/blog/page.js")
  handler satisfies AppPageConfig<"/blog">
}

// Validate ../../app/(frontend)/blog/user/[userId]/page.tsx
{
  const handler = {} as typeof import("../../app/(frontend)/blog/user/[userId]/page.js")
  handler satisfies AppPageConfig<"/blog/user/[userId]">
}

// Validate ../../app/(frontend)/page.tsx
{
  const handler = {} as typeof import("../../app/(frontend)/page.js")
  handler satisfies AppPageConfig<"/">
}

// Validate ../../app/(frontend)/privacy-policy/page.tsx
{
  const handler = {} as typeof import("../../app/(frontend)/privacy-policy/page.js")
  handler satisfies AppPageConfig<"/privacy-policy">
}

// Validate ../../app/(frontend)/project/[projectSlug]/page.tsx
{
  const handler = {} as typeof import("../../app/(frontend)/project/[projectSlug]/page.js")
  handler satisfies AppPageConfig<"/project/[projectSlug]">
}

// Validate ../../app/(frontend)/project/page.tsx
{
  const handler = {} as typeof import("../../app/(frontend)/project/page.js")
  handler satisfies AppPageConfig<"/project">
}

// Validate ../../app/(frontend)/terms-of-use/page.tsx
{
  const handler = {} as typeof import("../../app/(frontend)/terms-of-use/page.js")
  handler satisfies AppPageConfig<"/terms-of-use">
}

// Validate ../../app/(my-links)/my-links/page.tsx
{
  const handler = {} as typeof import("../../app/(my-links)/my-links/page.js")
  handler satisfies AppPageConfig<"/my-links">
}

// Validate ../../app/(api)/api/ai/dall-e/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/ai/dall-e/route.js")
  handler satisfies RouteHandlerConfig<"/api/ai/dall-e">
}

// Validate ../../app/(api)/api/ai/gpt-4o/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/ai/gpt-4o/route.js")
  handler satisfies RouteHandlerConfig<"/api/ai/gpt-4o">
}

// Validate ../../app/(api)/api/appointments/[appointmentId]/book/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/appointments/[appointmentId]/book/route.js")
  handler satisfies RouteHandlerConfig<"/api/appointments/[appointmentId]/book">
}

// Validate ../../app/(api)/api/appointments/[appointmentId]/cancel/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/appointments/[appointmentId]/cancel/route.js")
  handler satisfies RouteHandlerConfig<"/api/appointments/[appointmentId]/cancel">
}

// Validate ../../app/(api)/api/appointments/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/appointments/route.js")
  handler satisfies RouteHandlerConfig<"/api/appointments">
}

// Validate ../../app/(api)/api/auth/callback/[provider]/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/auth/callback/[provider]/route.js")
  handler satisfies RouteHandlerConfig<"/api/auth/callback/[provider]">
}

// Validate ../../app/(api)/api/auth/forgot-password/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/auth/forgot-password/route.js")
  handler satisfies RouteHandlerConfig<"/api/auth/forgot-password">
}

// Validate ../../app/(api)/api/auth/login/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/auth/login/route.js")
  handler satisfies RouteHandlerConfig<"/api/auth/login">
}

// Validate ../../app/(api)/api/auth/logout/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/auth/logout/route.js")
  handler satisfies RouteHandlerConfig<"/api/auth/logout">
}

// Validate ../../app/(api)/api/auth/register/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/auth/register/route.js")
  handler satisfies RouteHandlerConfig<"/api/auth/register">
}

// Validate ../../app/(api)/api/auth/reset-password/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/auth/reset-password/route.js")
  handler satisfies RouteHandlerConfig<"/api/auth/reset-password">
}

// Validate ../../app/(api)/api/auth/session/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/auth/session/route.js")
  handler satisfies RouteHandlerConfig<"/api/auth/session">
}

// Validate ../../app/(api)/api/auth/sso/[provider]/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/auth/sso/[provider]/route.js")
  handler satisfies RouteHandlerConfig<"/api/auth/sso/[provider]">
}

// Validate ../../app/(api)/api/aws/from-url/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/aws/from-url/route.js")
  handler satisfies RouteHandlerConfig<"/api/aws/from-url">
}

// Validate ../../app/(api)/api/aws/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/aws/route.js")
  handler satisfies RouteHandlerConfig<"/api/aws">
}

// Validate ../../app/(api)/api/booking/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/booking/route.js")
  handler satisfies RouteHandlerConfig<"/api/booking">
}

// Validate ../../app/(api)/api/categories/[categoryId]/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/categories/[categoryId]/route.js")
  handler satisfies RouteHandlerConfig<"/api/categories/[categoryId]">
}

// Validate ../../app/(api)/api/categories/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/categories/route.js")
  handler satisfies RouteHandlerConfig<"/api/categories">
}

// Validate ../../app/(api)/api/comments/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/comments/route.js")
  handler satisfies RouteHandlerConfig<"/api/comments">
}

// Validate ../../app/(api)/api/contact/form/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/contact/form/route.js")
  handler satisfies RouteHandlerConfig<"/api/contact/form">
}

// Validate ../../app/(api)/api/contact/info/mail/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/contact/info/mail/route.js")
  handler satisfies RouteHandlerConfig<"/api/contact/info/mail">
}

// Validate ../../app/(api)/api/contact/info/phone/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/contact/info/phone/route.js")
  handler satisfies RouteHandlerConfig<"/api/contact/info/phone">
}

// Validate ../../app/(api)/api/contact/subscription/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/contact/subscription/route.js")
  handler satisfies RouteHandlerConfig<"/api/contact/subscription">
}

// Validate ../../app/(api)/api/posts/[postId]/cover.jpeg/route.tsx
{
  const handler = {} as typeof import("../../app/(api)/api/posts/[postId]/cover.jpeg/route.js")
  handler satisfies RouteHandlerConfig<"/api/posts/[postId]/cover.jpeg">
}

// Validate ../../app/(api)/api/posts/[postId]/like/count/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/posts/[postId]/like/count/route.js")
  handler satisfies RouteHandlerConfig<"/api/posts/[postId]/like/count">
}

// Validate ../../app/(api)/api/posts/[postId]/like/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/posts/[postId]/like/route.js")
  handler satisfies RouteHandlerConfig<"/api/posts/[postId]/like">
}

// Validate ../../app/(api)/api/posts/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/posts/route.js")
  handler satisfies RouteHandlerConfig<"/api/posts">
}

// Validate ../../app/(api)/api/projects/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/projects/route.js")
  handler satisfies RouteHandlerConfig<"/api/projects">
}

// Validate ../../app/(api)/api/sections/github/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/sections/github/route.js")
  handler satisfies RouteHandlerConfig<"/api/sections/github">
}

// Validate ../../app/(api)/api/sections/gitlab/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/sections/gitlab/route.js")
  handler satisfies RouteHandlerConfig<"/api/sections/gitlab">
}

// Validate ../../app/(api)/api/settings/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/settings/route.js")
  handler satisfies RouteHandlerConfig<"/api/settings">
}

// Validate ../../app/(api)/api/slot-templates/[day]/apply/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/slot-templates/[day]/apply/route.js")
  handler satisfies RouteHandlerConfig<"/api/slot-templates/[day]/apply">
}

// Validate ../../app/(api)/api/slot-templates/[day]/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/slot-templates/[day]/route.js")
  handler satisfies RouteHandlerConfig<"/api/slot-templates/[day]">
}

// Validate ../../app/(api)/api/slots/[date]/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/slots/[date]/route.js")
  handler satisfies RouteHandlerConfig<"/api/slots/[date]">
}

// Validate ../../app/(api)/api/slots/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/slots/route.js")
  handler satisfies RouteHandlerConfig<"/api/slots">
}

// Validate ../../app/(api)/api/stats/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/stats/route.js")
  handler satisfies RouteHandlerConfig<"/api/stats">
}

// Validate ../../app/(api)/api/users/[userId]/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/users/[userId]/route.js")
  handler satisfies RouteHandlerConfig<"/api/users/[userId]">
}

// Validate ../../app/(api)/api/users/route.ts
{
  const handler = {} as typeof import("../../app/(api)/api/users/route.js")
  handler satisfies RouteHandlerConfig<"/api/users">
}

// Validate ../../app/(api)/api/widget/posts/route.tsx
{
  const handler = {} as typeof import("../../app/(api)/api/widget/posts/route.js")
  handler satisfies RouteHandlerConfig<"/api/widget/posts">
}

// Validate ../../app/(frontend)/blog/sitemap.xml/route.ts
{
  const handler = {} as typeof import("../../app/(frontend)/blog/sitemap.xml/route.js")
  handler satisfies RouteHandlerConfig<"/blog/sitemap.xml">
}

// Validate ../../app/(frontend)/project/sitemap.xml/route.ts
{
  const handler = {} as typeof import("../../app/(frontend)/project/sitemap.xml/route.js")
  handler satisfies RouteHandlerConfig<"/project/sitemap.xml">
}

// Validate ../../app/sitemap-static.xml/route.ts
{
  const handler = {} as typeof import("../../app/sitemap-static.xml/route.js")
  handler satisfies RouteHandlerConfig<"/sitemap-static.xml">
}

// Validate ../../app/sitemap.xml/route.ts
{
  const handler = {} as typeof import("../../app/sitemap.xml/route.js")
  handler satisfies RouteHandlerConfig<"/sitemap.xml">
}





// Validate ../../app/(admin)/admin/layout.tsx
{
  const handler = {} as typeof import("../../app/(admin)/admin/layout.js")
  handler satisfies LayoutConfig<"/admin">
}

// Validate ../../app/(admin)/layout.tsx
{
  const handler = {} as typeof import("../../app/(admin)/layout.js")
  handler satisfies LayoutConfig<"/">
}

// Validate ../../app/(auth)/layout.tsx
{
  const handler = {} as typeof import("../../app/(auth)/layout.js")
  handler satisfies LayoutConfig<"/">
}

// Validate ../../app/(easter)/easter/terminal/layout.tsx
{
  const handler = {} as typeof import("../../app/(easter)/easter/terminal/layout.js")
  handler satisfies LayoutConfig<"/easter/terminal">
}

// Validate ../../app/(frontend)/blog/layout.tsx
{
  const handler = {} as typeof import("../../app/(frontend)/blog/layout.js")
  handler satisfies LayoutConfig<"/blog">
}

// Validate ../../app/(frontend)/layout.tsx
{
  const handler = {} as typeof import("../../app/(frontend)/layout.js")
  handler satisfies LayoutConfig<"/">
}

// Validate ../../app/(my-links)/layout.tsx
{
  const handler = {} as typeof import("../../app/(my-links)/layout.js")
  handler satisfies LayoutConfig<"/">
}

// Validate ../../app/layout.tsx
{
  const handler = {} as typeof import("../../app/layout.js")
  handler satisfies LayoutConfig<"/">
}


=== ./.next/types/routes.d.ts ===
// This file is generated automatically by Next.js
// Do not edit this file manually

type AppRoutes = "/" | "/admin" | "/admin/categories" | "/admin/categories/[categoryId]" | "/admin/categories/[categoryId]/posts" | "/admin/categories/create" | "/admin/comments" | "/admin/posts" | "/admin/posts/[postId]" | "/admin/projects" | "/admin/projects/[projectId]" | "/admin/settings" | "/admin/slots" | "/admin/users" | "/admin/users/[userId]" | "/admin/users/create" | "/auth/callback" | "/auth/forgot-password" | "/auth/login" | "/auth/logout" | "/auth/register" | "/blog" | "/blog/[categorySlug]" | "/blog/[categorySlug]/[postSlug]" | "/blog/user/[userId]" | "/easter/terminal" | "/my-links" | "/privacy-policy" | "/project" | "/project/[projectSlug]" | "/terms-of-use"
type AppRouteHandlerRoutes = "/api/ai/dall-e" | "/api/ai/gpt-4o" | "/api/appointments" | "/api/appointments/[appointmentId]/book" | "/api/appointments/[appointmentId]/cancel" | "/api/auth/callback/[provider]" | "/api/auth/forgot-password" | "/api/auth/login" | "/api/auth/logout" | "/api/auth/register" | "/api/auth/reset-password" | "/api/auth/session" | "/api/auth/sso/[provider]" | "/api/aws" | "/api/aws/from-url" | "/api/booking" | "/api/categories" | "/api/categories/[categoryId]" | "/api/comments" | "/api/contact/form" | "/api/contact/info/mail" | "/api/contact/info/phone" | "/api/contact/subscription" | "/api/posts" | "/api/posts/[postId]/cover.jpeg" | "/api/posts/[postId]/like" | "/api/posts/[postId]/like/count" | "/api/projects" | "/api/sections/github" | "/api/sections/gitlab" | "/api/settings" | "/api/slot-templates/[day]" | "/api/slot-templates/[day]/apply" | "/api/slots" | "/api/slots/[date]" | "/api/stats" | "/api/users" | "/api/users/[userId]" | "/api/widget/posts" | "/blog/sitemap.xml" | "/project/sitemap.xml" | "/sitemap-static.xml" | "/sitemap.xml"
type PageRoutes = never
type LayoutRoutes = "/" | "/admin" | "/blog" | "/easter/terminal"
type RedirectRoutes = never
type RewriteRoutes = never
type Routes = AppRoutes | PageRoutes | LayoutRoutes | RedirectRoutes | RewriteRoutes | AppRouteHandlerRoutes


interface ParamMap {
  "/": {}
  "/admin": {}
  "/admin/categories": {}
  "/admin/categories/[categoryId]": { "categoryId": string; }
  "/admin/categories/[categoryId]/posts": { "categoryId": string; }
  "/admin/categories/create": {}
  "/admin/comments": {}
  "/admin/posts": {}
  "/admin/posts/[postId]": { "postId": string; }
  "/admin/projects": {}
  "/admin/projects/[projectId]": { "projectId": string; }
  "/admin/settings": {}
  "/admin/slots": {}
  "/admin/users": {}
  "/admin/users/[userId]": { "userId": string; }
  "/admin/users/create": {}
  "/api/ai/dall-e": {}
  "/api/ai/gpt-4o": {}
  "/api/appointments": {}
  "/api/appointments/[appointmentId]/book": { "appointmentId": string; }
  "/api/appointments/[appointmentId]/cancel": { "appointmentId": string; }
  "/api/auth/callback/[provider]": { "provider": string; }
  "/api/auth/forgot-password": {}
  "/api/auth/login": {}
  "/api/auth/logout": {}
  "/api/auth/register": {}
  "/api/auth/reset-password": {}
  "/api/auth/session": {}
  "/api/auth/sso/[provider]": { "provider": string; }
  "/api/aws": {}
  "/api/aws/from-url": {}
  "/api/booking": {}
  "/api/categories": {}
  "/api/categories/[categoryId]": { "categoryId": string; }
  "/api/comments": {}
  "/api/contact/form": {}
  "/api/contact/info/mail": {}
  "/api/contact/info/phone": {}
  "/api/contact/subscription": {}
  "/api/posts": {}
  "/api/posts/[postId]/cover.jpeg": { "postId": string; }
  "/api/posts/[postId]/like": { "postId": string; }
  "/api/posts/[postId]/like/count": { "postId": string; }
  "/api/projects": {}
  "/api/sections/github": {}
  "/api/sections/gitlab": {}
  "/api/settings": {}
  "/api/slot-templates/[day]": { "day": string; }
  "/api/slot-templates/[day]/apply": { "day": string; }
  "/api/slots": {}
  "/api/slots/[date]": { "date": string; }
  "/api/stats": {}
  "/api/users": {}
  "/api/users/[userId]": { "userId": string; }
  "/api/widget/posts": {}
  "/auth/callback": {}
  "/auth/forgot-password": {}
  "/auth/login": {}
  "/auth/logout": {}
  "/auth/register": {}
  "/blog": {}
  "/blog/[categorySlug]": { "categorySlug": string; }
  "/blog/[categorySlug]/[postSlug]": { "categorySlug": string; "postSlug": string; }
  "/blog/sitemap.xml": {}
  "/blog/user/[userId]": { "userId": string; }
  "/easter/terminal": {}
  "/my-links": {}
  "/privacy-policy": {}
  "/project": {}
  "/project/[projectSlug]": { "projectSlug": string; }
  "/project/sitemap.xml": {}
  "/sitemap-static.xml": {}
  "/sitemap.xml": {}
  "/terms-of-use": {}
}


export type ParamsOf<Route extends Routes> = ParamMap[Route]

interface LayoutSlotMap {
  "/": never
  "/admin": never
  "/blog": never
  "/easter/terminal": never
}


export type { AppRoutes, PageRoutes, LayoutRoutes, RedirectRoutes, RewriteRoutes, ParamMap, AppRouteHandlerRoutes }

declare global {
  /**
   * Props for Next.js App Router page components
   * @example
   * ```tsx
   * export default function Page(props: PageProps<'/blog/[slug]'>) {
   *   const { slug } = await props.params
   *   return <div>Blog post: {slug}</div>
   * }
   * ```
   */
  interface PageProps<AppRoute extends AppRoutes> {
    params: Promise<ParamMap[AppRoute]>
    searchParams: Promise<Record<string, string | string[] | undefined>>
  }

  /**
   * Props for Next.js App Router layout components
   * @example
   * ```tsx
   * export default function Layout(props: LayoutProps<'/dashboard'>) {
   *   return <div>{props.children}</div>
   * }
   * ```
   */
  type LayoutProps<LayoutRoute extends LayoutRoutes> = {
    params: Promise<ParamMap[LayoutRoute]>
    children: React.ReactNode
  } & {
    [K in LayoutSlotMap[LayoutRoute]]: React.ReactNode
  }

  /**
   * Context for Next.js App Router route handlers
   * @example
   * ```tsx
   * export async function GET(request: NextRequest, context: RouteContext<'/api/users/[id]'>) {
   *   const { id } = await context.params
   *   return Response.json({ id })
   * }
   * ```
   */
  interface RouteContext<AppRouteHandlerRoute extends AppRouteHandlerRoutes> {
    params: Promise<ParamMap[AppRouteHandlerRoute]>
  }
}


=== ./.next/types/cache-life.d.ts ===
// Type definitions for Next.js cacheLife configs

declare module 'next/cache' {
  export { unstable_cache } from 'next/dist/server/web/spec-extension/unstable-cache'
  export {
    revalidateTag,
    revalidatePath,
    unstable_expireTag,
    unstable_expirePath,
  } from 'next/dist/server/web/spec-extension/revalidate'
  export { unstable_noStore } from 'next/dist/server/web/spec-extension/unstable-no-store'

  
    /**
     * Cache this `"use cache"` for a timespan defined by the `"default"` profile.
     * ```
     *   stale:      300 seconds (5 minutes)
     *   revalidate: 900 seconds (15 minutes)
     *   expire:     never
     * ```
     * 
     * This cache may be stale on clients for 5 minutes before checking with the server.
     * If the server receives a new request after 15 minutes, start revalidating new values in the background.
     * It lives for the maximum age of the server cache. If this entry has no traffic for a while, it may serve an old value the next request.
     */
    export function unstable_cacheLife(profile: "default"): void
    
    /**
     * Cache this `"use cache"` for a timespan defined by the `"seconds"` profile.
     * ```
     *   stale:      30 seconds
     *   revalidate: 1 seconds
     *   expire:     60 seconds (1 minute)
     * ```
     * 
     * This cache may be stale on clients for 30 seconds before checking with the server.
     * If the server receives a new request after 1 seconds, start revalidating new values in the background.
     * If this entry has no traffic for 1 minute it will expire. The next request will recompute it.
     */
    export function unstable_cacheLife(profile: "seconds"): void
    
    /**
     * Cache this `"use cache"` for a timespan defined by the `"minutes"` profile.
     * ```
     *   stale:      300 seconds (5 minutes)
     *   revalidate: 60 seconds (1 minute)
     *   expire:     3600 seconds (1 hour)
     * ```
     * 
     * This cache may be stale on clients for 5 minutes before checking with the server.
     * If the server receives a new request after 1 minute, start revalidating new values in the background.
     * If this entry has no traffic for 1 hour it will expire. The next request will recompute it.
     */
    export function unstable_cacheLife(profile: "minutes"): void
    
    /**
     * Cache this `"use cache"` for a timespan defined by the `"hours"` profile.
     * ```
     *   stale:      300 seconds (5 minutes)
     *   revalidate: 3600 seconds (1 hour)
     *   expire:     86400 seconds (1 day)
     * ```
     * 
     * This cache may be stale on clients for 5 minutes before checking with the server.
     * If the server receives a new request after 1 hour, start revalidating new values in the background.
     * If this entry has no traffic for 1 day it will expire. The next request will recompute it.
     */
    export function unstable_cacheLife(profile: "hours"): void
    
    /**
     * Cache this `"use cache"` for a timespan defined by the `"days"` profile.
     * ```
     *   stale:      300 seconds (5 minutes)
     *   revalidate: 86400 seconds (1 day)
     *   expire:     604800 seconds (1 week)
     * ```
     * 
     * This cache may be stale on clients for 5 minutes before checking with the server.
     * If the server receives a new request after 1 day, start revalidating new values in the background.
     * If this entry has no traffic for 1 week it will expire. The next request will recompute it.
     */
    export function unstable_cacheLife(profile: "days"): void
    
    /**
     * Cache this `"use cache"` for a timespan defined by the `"weeks"` profile.
     * ```
     *   stale:      300 seconds (5 minutes)
     *   revalidate: 604800 seconds (1 week)
     *   expire:     2592000 seconds (30 days)
     * ```
     * 
     * This cache may be stale on clients for 5 minutes before checking with the server.
     * If the server receives a new request after 1 week, start revalidating new values in the background.
     * If this entry has no traffic for 30 days it will expire. The next request will recompute it.
     */
    export function unstable_cacheLife(profile: "weeks"): void
    
    /**
     * Cache this `"use cache"` for a timespan defined by the `"max"` profile.
     * ```
     *   stale:      300 seconds (5 minutes)
     *   revalidate: 2592000 seconds (30 days)
     *   expire:     never
     * ```
     * 
     * This cache may be stale on clients for 5 minutes before checking with the server.
     * If the server receives a new request after 30 days, start revalidating new values in the background.
     * It lives for the maximum age of the server cache. If this entry has no traffic for a while, it may serve an old value the next request.
     */
    export function unstable_cacheLife(profile: "max"): void
    
    /**
     * Cache this `"use cache"` using a custom timespan.
     * ```
     *   stale: ... // seconds
     *   revalidate: ... // seconds
     *   expire: ... // seconds
     * ```
     *
     * This is similar to Cache-Control: max-age=`stale`,s-max-age=`revalidate`,stale-while-revalidate=`expire-revalidate`
     *
     * If a value is left out, the lowest of other cacheLife() calls or the default, is used instead.
     */
    export function unstable_cacheLife(profile: {
      /**
       * This cache may be stale on clients for ... seconds before checking with the server.
       */
      stale?: number,
      /**
       * If the server receives a new request after ... seconds, start revalidating new values in the background.
       */
      revalidate?: number,
      /**
       * If this entry has no traffic for ... seconds it will expire. The next request will recompute it.
       */
      expire?: number
    }): void
  

  export { cacheTag as unstable_cacheTag } from 'next/dist/server/use-cache/cache-tag'
}


=== ./.next/types/app/layout.ts ===
// File: /home/kuray/KurayDevV2/app/layout.tsx
import * as entry from '../../../app/layout.js'
import type { ResolvingMetadata, ResolvingViewport } from 'next/dist/lib/metadata/types/metadata-interface.js'

type TEntry = typeof import('../../../app/layout.js')

type SegmentParams<T extends Object = any> = T extends Record<string, any>
  ? { [K in keyof T]: T[K] extends string ? string | string[] | undefined : never }
  : T

// Check that the entry is a valid entry
checkFields<Diff<{
  default: Function
  config?: {}
  generateStaticParams?: Function
  revalidate?: RevalidateRange<TEntry> | false
  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'
  dynamicParams?: boolean
  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'
  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]
  runtime?: 'nodejs' | 'experimental-edge' | 'edge'
  maxDuration?: number
  
  metadata?: any
  generateMetadata?: Function
  viewport?: any
  generateViewport?: Function
  experimental_ppr?: boolean
  
}, TEntry, ''>>()


// Check the prop type of the entry function
checkFields<Diff<LayoutProps, FirstArg<TEntry['default']>, 'default'>>()

// Check the arguments and return type of the generateMetadata function
if ('generateMetadata' in entry) {
  checkFields<Diff<LayoutProps, FirstArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
  checkFields<Diff<ResolvingMetadata, SecondArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
}

// Check the arguments and return type of the generateViewport function
if ('generateViewport' in entry) {
  checkFields<Diff<LayoutProps, FirstArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
  checkFields<Diff<ResolvingViewport, SecondArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
}

// Check the arguments and return type of the generateStaticParams function
if ('generateStaticParams' in entry) {
  checkFields<Diff<{ params: SegmentParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()
  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()
}

export interface PageProps {
  params?: Promise<SegmentParams>
  searchParams?: Promise<any>
}
export interface LayoutProps {
  children?: React.ReactNode

  params?: Promise<SegmentParams>
}

// =============
// Utility types
type RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never

// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>

type FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never
type SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never
type MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never



function checkFields<_ extends { [k in keyof any]: never }>() {}

// https://github.com/sindresorhus/type-fest
type Numeric = number | bigint
type Zero = 0 | 0n
type Negative<T extends Numeric> = T extends Zero ? never : `${T}` extends `-${string}` ? T : never
type NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'


=== ./.next/types/app/(frontend)/layout.ts ===
// File: /home/kuray/KurayDevV2/app/(frontend)/layout.tsx
import * as entry from '../../../../app/(frontend)/layout.js'
import type { ResolvingMetadata, ResolvingViewport } from 'next/dist/lib/metadata/types/metadata-interface.js'

type TEntry = typeof import('../../../../app/(frontend)/layout.js')

type SegmentParams<T extends Object = any> = T extends Record<string, any>
  ? { [K in keyof T]: T[K] extends string ? string | string[] | undefined : never }
  : T

// Check that the entry is a valid entry
checkFields<Diff<{
  default: Function
  config?: {}
  generateStaticParams?: Function
  revalidate?: RevalidateRange<TEntry> | false
  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'
  dynamicParams?: boolean
  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'
  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]
  runtime?: 'nodejs' | 'experimental-edge' | 'edge'
  maxDuration?: number
  
  metadata?: any
  generateMetadata?: Function
  viewport?: any
  generateViewport?: Function
  experimental_ppr?: boolean
  
}, TEntry, ''>>()


// Check the prop type of the entry function
checkFields<Diff<LayoutProps, FirstArg<TEntry['default']>, 'default'>>()

// Check the arguments and return type of the generateMetadata function
if ('generateMetadata' in entry) {
  checkFields<Diff<LayoutProps, FirstArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
  checkFields<Diff<ResolvingMetadata, SecondArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
}

// Check the arguments and return type of the generateViewport function
if ('generateViewport' in entry) {
  checkFields<Diff<LayoutProps, FirstArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
  checkFields<Diff<ResolvingViewport, SecondArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
}

// Check the arguments and return type of the generateStaticParams function
if ('generateStaticParams' in entry) {
  checkFields<Diff<{ params: SegmentParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()
  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()
}

export interface PageProps {
  params?: Promise<SegmentParams>
  searchParams?: Promise<any>
}
export interface LayoutProps {
  children?: React.ReactNode

  params?: Promise<SegmentParams>
}

// =============
// Utility types
type RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never

// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>

type FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never
type SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never
type MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never



function checkFields<_ extends { [k in keyof any]: never }>() {}

// https://github.com/sindresorhus/type-fest
type Numeric = number | bigint
type Zero = 0 | 0n
type Negative<T extends Numeric> = T extends Zero ? never : `${T}` extends `-${string}` ? T : never
type NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'


=== ./.next/types/app/(frontend)/page.ts ===
// File: /home/kuray/KurayDevV2/app/(frontend)/page.tsx
import * as entry from '../../../../app/(frontend)/page.js'
import type { ResolvingMetadata, ResolvingViewport } from 'next/dist/lib/metadata/types/metadata-interface.js'

type TEntry = typeof import('../../../../app/(frontend)/page.js')

type SegmentParams<T extends Object = any> = T extends Record<string, any>
  ? { [K in keyof T]: T[K] extends string ? string | string[] | undefined : never }
  : T

// Check that the entry is a valid entry
checkFields<Diff<{
  default: Function
  config?: {}
  generateStaticParams?: Function
  revalidate?: RevalidateRange<TEntry> | false
  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'
  dynamicParams?: boolean
  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'
  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]
  runtime?: 'nodejs' | 'experimental-edge' | 'edge'
  maxDuration?: number
  
  metadata?: any
  generateMetadata?: Function
  viewport?: any
  generateViewport?: Function
  experimental_ppr?: boolean
  
}, TEntry, ''>>()


// Check the prop type of the entry function
checkFields<Diff<PageProps, FirstArg<TEntry['default']>, 'default'>>()

// Check the arguments and return type of the generateMetadata function
if ('generateMetadata' in entry) {
  checkFields<Diff<PageProps, FirstArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
  checkFields<Diff<ResolvingMetadata, SecondArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
}

// Check the arguments and return type of the generateViewport function
if ('generateViewport' in entry) {
  checkFields<Diff<PageProps, FirstArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
  checkFields<Diff<ResolvingViewport, SecondArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
}

// Check the arguments and return type of the generateStaticParams function
if ('generateStaticParams' in entry) {
  checkFields<Diff<{ params: SegmentParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()
  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()
}

export interface PageProps {
  params?: Promise<SegmentParams>
  searchParams?: Promise<any>
}
export interface LayoutProps {
  children?: React.ReactNode

  params?: Promise<SegmentParams>
}

// =============
// Utility types
type RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never

// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>

type FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never
type SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never
type MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never



function checkFields<_ extends { [k in keyof any]: never }>() {}

// https://github.com/sindresorhus/type-fest
type Numeric = number | bigint
type Zero = 0 | 0n
type Negative<T extends Numeric> = T extends Zero ? never : `${T}` extends `-${string}` ? T : never
type NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'


=== ./.next/types/app/(api)/api/contact/info/mail/route.ts ===
// File: /home/kuray/KurayDevV2/app/(api)/api/contact/info/mail/route.ts
import * as entry from '../../../../../../../../app/(api)/api/contact/info/mail/route.js'
import type { NextRequest } from 'next/server.js'

type TEntry = typeof import('../../../../../../../../app/(api)/api/contact/info/mail/route.js')

type SegmentParams<T extends Object = any> = T extends Record<string, any>
  ? { [K in keyof T]: T[K] extends string ? string | string[] | undefined : never }
  : T

// Check that the entry is a valid entry
checkFields<Diff<{
  GET?: Function
  HEAD?: Function
  OPTIONS?: Function
  POST?: Function
  PUT?: Function
  DELETE?: Function
  PATCH?: Function
  config?: {}
  generateStaticParams?: Function
  revalidate?: RevalidateRange<TEntry> | false
  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'
  dynamicParams?: boolean
  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'
  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]
  runtime?: 'nodejs' | 'experimental-edge' | 'edge'
  maxDuration?: number
  
}, TEntry, ''>>()

type RouteContext = { params: Promise<SegmentParams> }
// Check the prop type of the entry function
if ('GET' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'GET'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'GET'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'GET',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'GET',
        __return_type__: ReturnType<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
}
// Check the prop type of the entry function
if ('HEAD' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'HEAD'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'HEAD'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'HEAD',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'HEAD',
        __return_type__: ReturnType<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
}
// Check the prop type of the entry function
if ('OPTIONS' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'OPTIONS'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'OPTIONS'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'OPTIONS',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'OPTIONS',
        __return_type__: ReturnType<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
}
// Check the prop type of the entry function
if ('POST' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'POST'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'POST'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'POST',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'POST',
        __return_type__: ReturnType<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
}
// Check the prop type of the entry function
if ('PUT' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'PUT'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'PUT'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'PUT',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'PUT',
        __return_type__: ReturnType<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
}
// Check the prop type of the entry function
if ('DELETE' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'DELETE'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'DELETE'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'DELETE',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'DELETE',
        __return_type__: ReturnType<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
}
// Check the prop type of the entry function
if ('PATCH' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'PATCH'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'PATCH'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'PATCH',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'PATCH',
        __return_type__: ReturnType<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
}

// Check the arguments and return type of the generateStaticParams function
if ('generateStaticParams' in entry) {
  checkFields<Diff<{ params: SegmentParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()
  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()
}

export interface PageProps {
  params?: Promise<SegmentParams>
  searchParams?: Promise<any>
}
export interface LayoutProps {
  children?: React.ReactNode

  params?: Promise<SegmentParams>
}

// =============
// Utility types
type RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never

// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>

type FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never
type SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never
type MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never

type ParamCheck<T> = {
  __tag__: string
  __param_position__: string
  __param_type__: T
}

function checkFields<_ extends { [k in keyof any]: never }>() {}

// https://github.com/sindresorhus/type-fest
type Numeric = number | bigint
type Zero = 0 | 0n
type Negative<T extends Numeric> = T extends Zero ? never : `${T}` extends `-${string}` ? T : never
type NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'


=== ./.next/types/app/(api)/api/projects/route.ts ===
// File: /home/kuray/KurayDevV2/app/(api)/api/projects/route.ts
import * as entry from '../../../../../../app/(api)/api/projects/route.js'
import type { NextRequest } from 'next/server.js'

type TEntry = typeof import('../../../../../../app/(api)/api/projects/route.js')

type SegmentParams<T extends Object = any> = T extends Record<string, any>
  ? { [K in keyof T]: T[K] extends string ? string | string[] | undefined : never }
  : T

// Check that the entry is a valid entry
checkFields<Diff<{
  GET?: Function
  HEAD?: Function
  OPTIONS?: Function
  POST?: Function
  PUT?: Function
  DELETE?: Function
  PATCH?: Function
  config?: {}
  generateStaticParams?: Function
  revalidate?: RevalidateRange<TEntry> | false
  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'
  dynamicParams?: boolean
  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'
  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]
  runtime?: 'nodejs' | 'experimental-edge' | 'edge'
  maxDuration?: number
  
}, TEntry, ''>>()

type RouteContext = { params: Promise<SegmentParams> }
// Check the prop type of the entry function
if ('GET' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'GET'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'GET'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'GET',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'GET',
        __return_type__: ReturnType<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
}
// Check the prop type of the entry function
if ('HEAD' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'HEAD'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'HEAD'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'HEAD',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'HEAD',
        __return_type__: ReturnType<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
}
// Check the prop type of the entry function
if ('OPTIONS' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'OPTIONS'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'OPTIONS'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'OPTIONS',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'OPTIONS',
        __return_type__: ReturnType<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
}
// Check the prop type of the entry function
if ('POST' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'POST'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'POST'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'POST',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'POST',
        __return_type__: ReturnType<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
}
// Check the prop type of the entry function
if ('PUT' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'PUT'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'PUT'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'PUT',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'PUT',
        __return_type__: ReturnType<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
}
// Check the prop type of the entry function
if ('DELETE' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'DELETE'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'DELETE'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'DELETE',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'DELETE',
        __return_type__: ReturnType<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
}
// Check the prop type of the entry function
if ('PATCH' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'PATCH'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'PATCH'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'PATCH',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'PATCH',
        __return_type__: ReturnType<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
}

// Check the arguments and return type of the generateStaticParams function
if ('generateStaticParams' in entry) {
  checkFields<Diff<{ params: SegmentParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()
  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()
}

export interface PageProps {
  params?: Promise<SegmentParams>
  searchParams?: Promise<any>
}
export interface LayoutProps {
  children?: React.ReactNode

  params?: Promise<SegmentParams>
}

// =============
// Utility types
type RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never

// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>

type FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never
type SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never
type MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never

type ParamCheck<T> = {
  __tag__: string
  __param_position__: string
  __param_type__: T
}

function checkFields<_ extends { [k in keyof any]: never }>() {}

// https://github.com/sindresorhus/type-fest
type Numeric = number | bigint
type Zero = 0 | 0n
type Negative<T extends Numeric> = T extends Zero ? never : `${T}` extends `-${string}` ? T : never
type NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'


=== ./.next/types/app/(api)/api/slot-templates/[day]/route.ts ===
// File: /home/kuray/KurayDevV2/app/(api)/api/slot-templates/[day]/route.ts
import * as entry from '../../../../../../../app/(api)/api/slot-templates/[day]/route.js'
import type { NextRequest } from 'next/server.js'

type TEntry = typeof import('../../../../../../../app/(api)/api/slot-templates/[day]/route.js')

type SegmentParams<T extends Object = any> = T extends Record<string, any>
  ? { [K in keyof T]: T[K] extends string ? string | string[] | undefined : never }
  : T

// Check that the entry is a valid entry
checkFields<Diff<{
  GET?: Function
  HEAD?: Function
  OPTIONS?: Function
  POST?: Function
  PUT?: Function
  DELETE?: Function
  PATCH?: Function
  config?: {}
  generateStaticParams?: Function
  revalidate?: RevalidateRange<TEntry> | false
  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'
  dynamicParams?: boolean
  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'
  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]
  runtime?: 'nodejs' | 'experimental-edge' | 'edge'
  maxDuration?: number
  
}, TEntry, ''>>()

type RouteContext = { params: Promise<SegmentParams> }
// Check the prop type of the entry function
if ('GET' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'GET'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'GET'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'GET',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'GET',
        __return_type__: ReturnType<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
}
// Check the prop type of the entry function
if ('HEAD' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'HEAD'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'HEAD'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'HEAD',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'HEAD',
        __return_type__: ReturnType<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
}
// Check the prop type of the entry function
if ('OPTIONS' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'OPTIONS'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'OPTIONS'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'OPTIONS',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'OPTIONS',
        __return_type__: ReturnType<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
}
// Check the prop type of the entry function
if ('POST' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'POST'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'POST'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'POST',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'POST',
        __return_type__: ReturnType<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
}
// Check the prop type of the entry function
if ('PUT' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'PUT'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'PUT'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'PUT',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'PUT',
        __return_type__: ReturnType<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
}
// Check the prop type of the entry function
if ('DELETE' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'DELETE'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'DELETE'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'DELETE',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'DELETE',
        __return_type__: ReturnType<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
}
// Check the prop type of the entry function
if ('PATCH' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'PATCH'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'PATCH'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'PATCH',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'PATCH',
        __return_type__: ReturnType<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
}

// Check the arguments and return type of the generateStaticParams function
if ('generateStaticParams' in entry) {
  checkFields<Diff<{ params: SegmentParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()
  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()
}

export interface PageProps {
  params?: Promise<SegmentParams>
  searchParams?: Promise<any>
}
export interface LayoutProps {
  children?: React.ReactNode

  params?: Promise<SegmentParams>
}

// =============
// Utility types
type RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never

// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>

type FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never
type SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never
type MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never

type ParamCheck<T> = {
  __tag__: string
  __param_position__: string
  __param_type__: T
}

function checkFields<_ extends { [k in keyof any]: never }>() {}

// https://github.com/sindresorhus/type-fest
type Numeric = number | bigint
type Zero = 0 | 0n
type Negative<T extends Numeric> = T extends Zero ? never : `${T}` extends `-${string}` ? T : never
type NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'


=== ./.next/types/app/(api)/api/slots/[date]/route.ts ===
// File: /home/kuray/KurayDevV2/app/(api)/api/slots/[date]/route.ts
import * as entry from '../../../../../../../app/(api)/api/slots/[date]/route.js'
import type { NextRequest } from 'next/server.js'

type TEntry = typeof import('../../../../../../../app/(api)/api/slots/[date]/route.js')

type SegmentParams<T extends Object = any> = T extends Record<string, any>
  ? { [K in keyof T]: T[K] extends string ? string | string[] | undefined : never }
  : T

// Check that the entry is a valid entry
checkFields<Diff<{
  GET?: Function
  HEAD?: Function
  OPTIONS?: Function
  POST?: Function
  PUT?: Function
  DELETE?: Function
  PATCH?: Function
  config?: {}
  generateStaticParams?: Function
  revalidate?: RevalidateRange<TEntry> | false
  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'
  dynamicParams?: boolean
  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'
  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]
  runtime?: 'nodejs' | 'experimental-edge' | 'edge'
  maxDuration?: number
  
}, TEntry, ''>>()

type RouteContext = { params: Promise<SegmentParams> }
// Check the prop type of the entry function
if ('GET' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'GET'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'GET'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'GET',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'GET',
        __return_type__: ReturnType<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
}
// Check the prop type of the entry function
if ('HEAD' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'HEAD'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'HEAD'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'HEAD',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'HEAD',
        __return_type__: ReturnType<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
}
// Check the prop type of the entry function
if ('OPTIONS' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'OPTIONS'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'OPTIONS'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'OPTIONS',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'OPTIONS',
        __return_type__: ReturnType<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
}
// Check the prop type of the entry function
if ('POST' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'POST'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'POST'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'POST',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'POST',
        __return_type__: ReturnType<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
}
// Check the prop type of the entry function
if ('PUT' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'PUT'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'PUT'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'PUT',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'PUT',
        __return_type__: ReturnType<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
}
// Check the prop type of the entry function
if ('DELETE' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'DELETE'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'DELETE'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'DELETE',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'DELETE',
        __return_type__: ReturnType<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
}
// Check the prop type of the entry function
if ('PATCH' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'PATCH'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'PATCH'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'PATCH',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'PATCH',
        __return_type__: ReturnType<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
}

// Check the arguments and return type of the generateStaticParams function
if ('generateStaticParams' in entry) {
  checkFields<Diff<{ params: SegmentParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()
  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()
}

export interface PageProps {
  params?: Promise<SegmentParams>
  searchParams?: Promise<any>
}
export interface LayoutProps {
  children?: React.ReactNode

  params?: Promise<SegmentParams>
}

// =============
// Utility types
type RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never

// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>

type FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never
type SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never
type MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never

type ParamCheck<T> = {
  __tag__: string
  __param_position__: string
  __param_type__: T
}

function checkFields<_ extends { [k in keyof any]: never }>() {}

// https://github.com/sindresorhus/type-fest
type Numeric = number | bigint
type Zero = 0 | 0n
type Negative<T extends Numeric> = T extends Zero ? never : `${T}` extends `-${string}` ? T : never
type NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'


=== ./.next/types/app/(api)/api/slots/route.ts ===
// File: /home/kuray/KurayDevV2/app/(api)/api/slots/route.ts
import * as entry from '../../../../../../app/(api)/api/slots/route.js'
import type { NextRequest } from 'next/server.js'

type TEntry = typeof import('../../../../../../app/(api)/api/slots/route.js')

type SegmentParams<T extends Object = any> = T extends Record<string, any>
  ? { [K in keyof T]: T[K] extends string ? string | string[] | undefined : never }
  : T

// Check that the entry is a valid entry
checkFields<Diff<{
  GET?: Function
  HEAD?: Function
  OPTIONS?: Function
  POST?: Function
  PUT?: Function
  DELETE?: Function
  PATCH?: Function
  config?: {}
  generateStaticParams?: Function
  revalidate?: RevalidateRange<TEntry> | false
  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'
  dynamicParams?: boolean
  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'
  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]
  runtime?: 'nodejs' | 'experimental-edge' | 'edge'
  maxDuration?: number
  
}, TEntry, ''>>()

type RouteContext = { params: Promise<SegmentParams> }
// Check the prop type of the entry function
if ('GET' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'GET'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'GET'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'GET',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'GET',
        __return_type__: ReturnType<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
}
// Check the prop type of the entry function
if ('HEAD' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'HEAD'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'HEAD'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'HEAD',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'HEAD',
        __return_type__: ReturnType<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
}
// Check the prop type of the entry function
if ('OPTIONS' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'OPTIONS'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'OPTIONS'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'OPTIONS',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'OPTIONS',
        __return_type__: ReturnType<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
}
// Check the prop type of the entry function
if ('POST' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'POST'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'POST'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'POST',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'POST',
        __return_type__: ReturnType<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
}
// Check the prop type of the entry function
if ('PUT' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'PUT'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'PUT'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'PUT',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'PUT',
        __return_type__: ReturnType<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
}
// Check the prop type of the entry function
if ('DELETE' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'DELETE'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'DELETE'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'DELETE',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'DELETE',
        __return_type__: ReturnType<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
}
// Check the prop type of the entry function
if ('PATCH' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'PATCH'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: 'PATCH'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'PATCH',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'PATCH',
        __return_type__: ReturnType<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
}

// Check the arguments and return type of the generateStaticParams function
if ('generateStaticParams' in entry) {
  checkFields<Diff<{ params: SegmentParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()
  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()
}

export interface PageProps {
  params?: Promise<SegmentParams>
  searchParams?: Promise<any>
}
export interface LayoutProps {
  children?: React.ReactNode

  params?: Promise<SegmentParams>
}

// =============
// Utility types
type RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never

// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>

type FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never
type SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never
type MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never

type ParamCheck<T> = {
  __tag__: string
  __param_position__: string
  __param_type__: T
}

function checkFields<_ extends { [k in keyof any]: never }>() {}

// https://github.com/sindresorhus/type-fest
type Numeric = number | bigint
type Zero = 0 | 0n
type Negative<T extends Numeric> = T extends Zero ? never : `${T}` extends `-${string}` ? T : never
type NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'


=== ./.next/types/app/(admin)/layout.ts ===
// File: /home/kuray/KurayDevV2/app/(admin)/layout.tsx
import * as entry from '../../../../app/(admin)/layout.js'
import type { ResolvingMetadata, ResolvingViewport } from 'next/dist/lib/metadata/types/metadata-interface.js'

type TEntry = typeof import('../../../../app/(admin)/layout.js')

type SegmentParams<T extends Object = any> = T extends Record<string, any>
  ? { [K in keyof T]: T[K] extends string ? string | string[] | undefined : never }
  : T

// Check that the entry is a valid entry
checkFields<Diff<{
  default: Function
  config?: {}
  generateStaticParams?: Function
  revalidate?: RevalidateRange<TEntry> | false
  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'
  dynamicParams?: boolean
  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'
  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]
  runtime?: 'nodejs' | 'experimental-edge' | 'edge'
  maxDuration?: number
  
  metadata?: any
  generateMetadata?: Function
  viewport?: any
  generateViewport?: Function
  experimental_ppr?: boolean
  
}, TEntry, ''>>()


// Check the prop type of the entry function
checkFields<Diff<LayoutProps, FirstArg<TEntry['default']>, 'default'>>()

// Check the arguments and return type of the generateMetadata function
if ('generateMetadata' in entry) {
  checkFields<Diff<LayoutProps, FirstArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
  checkFields<Diff<ResolvingMetadata, SecondArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
}

// Check the arguments and return type of the generateViewport function
if ('generateViewport' in entry) {
  checkFields<Diff<LayoutProps, FirstArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
  checkFields<Diff<ResolvingViewport, SecondArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
}

// Check the arguments and return type of the generateStaticParams function
if ('generateStaticParams' in entry) {
  checkFields<Diff<{ params: SegmentParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()
  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()
}

export interface PageProps {
  params?: Promise<SegmentParams>
  searchParams?: Promise<any>
}
export interface LayoutProps {
  children?: React.ReactNode

  params?: Promise<SegmentParams>
}

// =============
// Utility types
type RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never

// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>

type FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never
type SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never
type MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never



function checkFields<_ extends { [k in keyof any]: never }>() {}

// https://github.com/sindresorhus/type-fest
type Numeric = number | bigint
type Zero = 0 | 0n
type Negative<T extends Numeric> = T extends Zero ? never : `${T}` extends `-${string}` ? T : never
type NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'


=== ./.next/types/app/(admin)/admin/layout.ts ===
// File: /home/kuray/KurayDevV2/app/(admin)/admin/layout.tsx
import * as entry from '../../../../../app/(admin)/admin/layout.js'
import type { ResolvingMetadata, ResolvingViewport } from 'next/dist/lib/metadata/types/metadata-interface.js'

type TEntry = typeof import('../../../../../app/(admin)/admin/layout.js')

type SegmentParams<T extends Object = any> = T extends Record<string, any>
  ? { [K in keyof T]: T[K] extends string ? string | string[] | undefined : never }
  : T

// Check that the entry is a valid entry
checkFields<Diff<{
  default: Function
  config?: {}
  generateStaticParams?: Function
  revalidate?: RevalidateRange<TEntry> | false
  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'
  dynamicParams?: boolean
  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'
  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]
  runtime?: 'nodejs' | 'experimental-edge' | 'edge'
  maxDuration?: number
  
  metadata?: any
  generateMetadata?: Function
  viewport?: any
  generateViewport?: Function
  experimental_ppr?: boolean
  
}, TEntry, ''>>()


// Check the prop type of the entry function
checkFields<Diff<LayoutProps, FirstArg<TEntry['default']>, 'default'>>()

// Check the arguments and return type of the generateMetadata function
if ('generateMetadata' in entry) {
  checkFields<Diff<LayoutProps, FirstArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
  checkFields<Diff<ResolvingMetadata, SecondArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
}

// Check the arguments and return type of the generateViewport function
if ('generateViewport' in entry) {
  checkFields<Diff<LayoutProps, FirstArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
  checkFields<Diff<ResolvingViewport, SecondArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
}

// Check the arguments and return type of the generateStaticParams function
if ('generateStaticParams' in entry) {
  checkFields<Diff<{ params: SegmentParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()
  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()
}

export interface PageProps {
  params?: Promise<SegmentParams>
  searchParams?: Promise<any>
}
export interface LayoutProps {
  children?: React.ReactNode

  params?: Promise<SegmentParams>
}

// =============
// Utility types
type RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never

// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>

type FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never
type SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never
type MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never



function checkFields<_ extends { [k in keyof any]: never }>() {}

// https://github.com/sindresorhus/type-fest
type Numeric = number | bigint
type Zero = 0 | 0n
type Negative<T extends Numeric> = T extends Zero ? never : `${T}` extends `-${string}` ? T : never
type NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'


=== ./.next/types/app/(admin)/admin/slots/page.ts ===
// File: /home/kuray/KurayDevV2/app/(admin)/admin/slots/page.tsx
import * as entry from '../../../../../../app/(admin)/admin/slots/page.js'
import type { ResolvingMetadata, ResolvingViewport } from 'next/dist/lib/metadata/types/metadata-interface.js'

type TEntry = typeof import('../../../../../../app/(admin)/admin/slots/page.js')

type SegmentParams<T extends Object = any> = T extends Record<string, any>
  ? { [K in keyof T]: T[K] extends string ? string | string[] | undefined : never }
  : T

// Check that the entry is a valid entry
checkFields<Diff<{
  default: Function
  config?: {}
  generateStaticParams?: Function
  revalidate?: RevalidateRange<TEntry> | false
  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'
  dynamicParams?: boolean
  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'
  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]
  runtime?: 'nodejs' | 'experimental-edge' | 'edge'
  maxDuration?: number
  
  metadata?: any
  generateMetadata?: Function
  viewport?: any
  generateViewport?: Function
  experimental_ppr?: boolean
  
}, TEntry, ''>>()


// Check the prop type of the entry function
checkFields<Diff<PageProps, FirstArg<TEntry['default']>, 'default'>>()

// Check the arguments and return type of the generateMetadata function
if ('generateMetadata' in entry) {
  checkFields<Diff<PageProps, FirstArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
  checkFields<Diff<ResolvingMetadata, SecondArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
}

// Check the arguments and return type of the generateViewport function
if ('generateViewport' in entry) {
  checkFields<Diff<PageProps, FirstArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
  checkFields<Diff<ResolvingViewport, SecondArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
}

// Check the arguments and return type of the generateStaticParams function
if ('generateStaticParams' in entry) {
  checkFields<Diff<{ params: SegmentParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()
  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()
}

export interface PageProps {
  params?: Promise<SegmentParams>
  searchParams?: Promise<any>
}
export interface LayoutProps {
  children?: React.ReactNode

  params?: Promise<SegmentParams>
}

// =============
// Utility types
type RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never

// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>

type FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never
type SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never
type MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never



function checkFields<_ extends { [k in keyof any]: never }>() {}

// https://github.com/sindresorhus/type-fest
type Numeric = number | bigint
type Zero = 0 | 0n
type Negative<T extends Numeric> = T extends Zero ? never : `${T}` extends `-${string}` ? T : never
type NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'


=== ./helpers/Validater.tsx ===
export default class Validator {
  static validateStatus(status: string) {
      
    if (!status) {
      throw new Error("INVALID_STATUS");
    }

    const statuses = ["ACTIVE", "INACTIVE", "PENDING", "BLOCKED"];
    if (!statuses.includes(status)) {
      throw new Error("INVALID_STATUS");
    }
    
  }
  /* Validaters */

  static validateID(id: string): void {
    if (!id) {
      throw new Error("INVALID_ID");
    }

    const idRegex = /^[a-zA-Z0-9_\-]+$/;
    if (!id.match(idRegex)) {
      throw new Error("INVALID_ID");
    }
  }


  static validateEmail(email: string): void {
    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    if (!emailRegex.test(email)) {
      throw new Error("INVALID_EMAIL");
    }
  }

  static validatePassword(password: string | null): void {
    // Allow empty password for password reset
    if (!password) {
      return;
    }

    if (password.length < 8) {
      throw new Error("PASSWORD_TOO_SHORT");
    }

    if (password.length > 50) {
      throw new Error("PASSWORD_TOO_LONG");
    }

    /* 
            Password must contain at least one uppercase letter, one lowercase letter, one digit, and one special character.
            Password must not contain any whitespace.
            No SQL injection.
            Allow Turkish characters.
        */
    const passwordRegex =
      /^(?=.*[a-zçğıöşü])(?=.*[A-ZÇĞİÖŞÜ])(?=.*\d)(?=.*[@$!%*?&])[A-Za-zçğıöşüÖÇŞİĞÜ0-9@$!%*?&]{8,50}$/;

    if (!passwordRegex.test(password)) {
      throw new Error("INVALID_PASSWORD");
    }
  }

  static validateStringField(
    field: string | null | undefined,
    field_name: string,
    allowEmpty: boolean = false,
  ): void {
    /*
            No SQL injection.
            Allow Turkish characters.
        */

    if (allowEmpty && !field) {
      return;
    }

    if (!field && !allowEmpty) {
      throw new Error(`EMPTY_${field_name.toUpperCase()}`);
    }

    if (field && field.length < 2) {
      if (field_name) {
        throw new Error(`INVALID_${field_name.toUpperCase()}`);
      }
      throw new Error("INVALID_STRING_FIELD");
    }

    const stringFieldRegex = /^[a-zA-ZçğıöşüÇĞİÖŞÜ\s]*$/;

    if (!stringFieldRegex.test("string")) {
      if (field_name) {
        throw new Error(`INVALID_${field_name.toUpperCase()}`);
      }
      throw new Error("INVALID_STRING_FIELD");
    }
  }

  static validatePhone(phone: number | null): void {
    // Allow empty phone for phone verification
    if (!phone) {
      return;
    }
    //starts with + and has numbers only
    const phoneRegex = /^\+[0-9]+$/;
    if (!phoneRegex.test(phone.toString())) {
      throw new Error("INVALID_PHONE");
    }
  }

  static validateDomain(domain: string): void {
    if (!domain) {
      throw new Error("INVALID_DOMAIN");
    }

    // domain can only contain letters, numbers, hyphens, and dots
    const domainRegex = /^[a-zA-Z0-9.-]+$/;
    if (!domain.match(domainRegex)) {
      throw new Error("INVALID_DOMAIN");
    }

    return;
  }

  static validateName(name: string): void {
    if (!name) {
      throw new Error("INVALID_NAME");
    }

    const regex = /^[a-zA-ZçğıöşüÇĞİÖŞÜ\s]+$/;

    if (!name.match(regex)) {
      throw new Error("INVALID_NAME");
    }

    return;
  }

  static validateNaturalNumber(number: any): void {

    const regex = /^[0-9]+$/; // Natural number means positive integer and zero
    if (!regex.test(number)) {
      throw new Error("INVALID_NUMBER");
    }

  }

  static validateRole(role: string): void {
    if (!role) {
      throw new Error("INVALID_ROLE");
    }

    const roles = ["USER", "ADMIN"];
    if (!roles.includes(role)) {
      throw new Error("INVALID_ROLE");
    }
  }

  static validateRoles(roles: string[] | string): void {

    if (typeof roles === "string") {
      roles = [roles];
    }

    if (!roles) {
      throw new Error("INVALID_ROLES");
    }

    roles.forEach((role) => {
      Validator.validateRole(role);
    } );


  }

  static validateToken(token: string): void {
    if (!token) {
      throw new Error("INVALID_TOKEN");
    }

    // $2b$10$WSIIQClD4OZ.MGTYKSUO6O2h7kp0JP17X.DdaAC3B3pB7wJ3yiTAi
    const tokenRegex = /^[a-zA-Z0-9./$]+$/;
    if (!token.match(tokenRegex)) {
      throw new Error("INVALID_TOKEN");
    }

    return;
  }

  static validateSixDigitCode(code: string): void {
    if (!code) {
      throw new Error("INVALID_CODE");
    }

    const codeRegex = /^[0-9]{6}$/;
    if (!code.match(codeRegex)) {
      throw new Error("INVALID_CODE");
    }

    return;
  }

  static validateURL(url: string | undefined | null, allowEmpty: boolean = false): void {

    if (allowEmpty && !url) {
      return;
    }

    if (!url && !allowEmpty) {
      throw new Error("INVALID_URL");
    }

    const urlRegex = /^(http|https):\/\/[^ "]+$/;
    if (url && !url.match(urlRegex)) {
      throw new Error("INVALID_URL");
    }

  }
}

=== ./helpers/MailTemplates/Admin/AdminContactUsMailTemplate.tsx ===
function AdminContactUsMailTemplate(props: { email: string, message: string, name: string, phone: string }) : string {
  
  const { email, message, name , phone } = props;
  
  const INFORM_NAME = process.env.INFORM_NAME as string;
  const INFORM_TITLE = process.env.INFORM_TITLE as string;
  const INFORM_MAIL = process.env.INFORM_MAIL as string;
  const INFORM_PHONE = process.env.INFORM_PHONE as string;

  const mailBody = `
    <div>
        <p>Hi ${INFORM_NAME},</p>
        <p>A new message has been received from the contact form.</p>
        <p>Here is a copy of the message:</p>
        <p>${message}</p>
        <br>
        <p>Contact details:</p>
        <p>Name: ${name}</p>
        <p>Email: ${email}</p>
        <p>Phone: ${phone}</p>
        <p>Best regards,</p>
        <br>
        <p>${INFORM_TITLE}</p>
        <p>Phone: ${INFORM_PHONE}</p>
        <p>Email: ${INFORM_MAIL}</p>
        <p>
    </div>`;
  return mailBody;
}

export default AdminContactUsMailTemplate;

=== ./helpers/MailTemplates/Customer/CustomerContactUsMailTemplate.tsx ===
function CustomerContactUsMailTemplate(props: { email: string, message: string, name: string, phone: string }) : string {
  
  const { email, message, name , phone } = props;
  
  const INFORM_NAME = process.env.INFORM_MAIL as string;
  const INFORM_TITLE = process.env.INFORM_TITLE as string;
  const INFORM_MAIL = process.env.INFORM_MAIL as string;
  const INFORM_PHONE = process.env.INFORM_PHONE as string;

  const mailBody = `
    <div>
        <p>Hi ${name},</p>
        <p>Thank you for contacting us. We have received your message and will get back to you as soon as possible.</p>
        <p>Here is a copy of your message:</p>
        <p>${message}</p>
        <p>Your contact details:</p>
        <p>Email: ${email}</p>
        <p>Phone: ${phone}</p>
        <p>If you have any further questions, please do not hesitate to contact us.</p>
        <p>Best regards,</p>
        <p>Kuray Karaaslan</p>
        <p>Phone: ${INFORM_PHONE}</p>
        <p>Email: ${INFORM_MAIL}</p>
        <p>
    </div>`;
  return mailBody;
}

export default CustomerContactUsMailTemplate;


=== ./helpers/MetadataHelper.tsx ===
import { Metadata } from 'next';

const APPLICATION_HOST = process.env.APPLICATION_HOST;

export default class MetadataHelper {

    // Generate JSON-LD for Organization
    public static getOrganizationJsonLd() {
        return {
            "@context": "https://schema.org",
            "@type": "Organization",
            "name": "Kuray Karaaslan",
            "url": APPLICATION_HOST,
            "logo": `${APPLICATION_HOST}/assets/img/og.png`,
            "sameAs": [
                "https://github.com/kuraykaraaslan",
                "https://twitter.com/kuraykaraaslan",
                "https://www.linkedin.com/in/kuraykaraaslan/"
            ]
        };
    }

    // Generate JSON-LD for Article
    public static getArticleJsonLd(meta: Metadata) {
        if (!meta?.openGraph?.url || !/\/blog\//.test(String(meta.openGraph.url))) return null;
        const title = meta?.title || 'Kuray Karaaslan';
        const description = meta?.description || 'Software developer, tech blogger, and open-source enthusiast.';
        const url = meta?.openGraph?.url || APPLICATION_HOST || '';
        // Helper to extract image URL as string
        function getImageUrl(img: any): string {
            if (!img) return `${APPLICATION_HOST}/assets/img/og.png`;
            if (typeof img === 'string') return img;
            if (typeof img === 'object' && 'url' in img) return String(img.url);
            return String(img);
        }
        let images: string[] = [];
        if (Array.isArray(meta?.openGraph?.images)) {
            images = meta.openGraph.images.map(getImageUrl);
        } else if (meta?.openGraph?.images) {
            images = [getImageUrl(meta.openGraph.images)];
        } else {
            images = [`${APPLICATION_HOST}/assets/img/og.png`];
        }
        const image = images[0];
        return {
            "@context": "https://schema.org",
            "@type": "Article",
            "headline": title,
            "description": description,
            "image": image,
            "author": {
                "@type": "Person",
                "name": "Kuray Karaaslan"
            },
            "publisher": {
                "@type": "Organization",
                "name": "Kuray Karaaslan",
                "logo": {
                    "@type": "ImageObject",
                    "url": `${APPLICATION_HOST}/assets/img/og.png`
                }
            },
            "mainEntityOfPage": url,
            "url": url
        };
    }

    public static generateElements(meta: Metadata) {
        // Fallbacks
        const title = meta?.title || 'Kuray Karaaslan';
        const description = meta?.description || 'Software developer, tech blogger, and open-source enthusiast.';
        const url = meta?.openGraph?.url || APPLICATION_HOST || '';

        // Helper to extract image URL as string
        function getImageUrl(img: any): string {
            if (!img) return `${APPLICATION_HOST}/assets/img/og.png`;
            if (typeof img === 'string') return img;
            if (typeof img === 'object' && 'url' in img) return String(img.url);
            return String(img);
        }

        let images: string[] = [];
        if (Array.isArray(meta?.openGraph?.images)) {
            images = meta.openGraph.images.map(getImageUrl);
        } else if (meta?.openGraph?.images) {
            images = [getImageUrl(meta.openGraph.images)];
        } else {
            images = [`${APPLICATION_HOST}/assets/img/og.png`];
        }

        // Dynamic og:type based on URL pattern only
        let ogType = 'website';
        if (meta?.openGraph?.url && /\/blog\//.test(String(meta.openGraph.url))) {
            ogType = 'article';
        }

        // Canonical tag
        const canonicalUrl = url;

        // JSON-LD
        const orgJsonLd = MetadataHelper.getOrganizationJsonLd();
        const articleJsonLd = MetadataHelper.getArticleJsonLd(meta);

        return (
            <>
                <title>{String(title)}</title>
                <meta name="description" content={String(description)} />
                <link rel="canonical" href={String(canonicalUrl)} />
                <meta property="og:title" content={String(meta?.openGraph?.title || title)} />
                <meta property="og:description" content={String(meta?.openGraph?.description || description)} />
                <meta property="og:type" content={ogType} />
                <meta property="og:url" content={String(url)} />
                {images.map((img, idx) => (
                    <meta property="og:image" content={img} key={`og:image:${idx}`} />
                ))}
                <meta name="twitter:card" content="summary_large_image" />
                <meta name="twitter:site" content="@dropshoptickets" />
                <meta name="twitter:creator" content="@dropshoptickets" />
                <meta name="twitter:title" content={String(title)} />
                <meta name="twitter:description" content={String(description)} />
                <meta name="twitter:image" content={images[0]} />
                {/* JSON-LD Structured Data */}
                <script type="application/ld+json" dangerouslySetInnerHTML={{ __html: JSON.stringify(orgJsonLd) }} />
                {articleJsonLd && (
                    <script type="application/ld+json" dangerouslySetInnerHTML={{ __html: JSON.stringify(articleJsonLd) }} />
                )}
            </>
        );
    }

}

=== ./helpers/SitemapGenerator.ts ===
// helpers/SitemapGenerator.ts
import { SitemapUrl } from '@/types/SitemapTypes';

export type ChangeFreq =
  | 'always' | 'hourly' | 'daily' | 'weekly' | 'monthly' | 'yearly' | 'never';

export const getBaseUrl = () => {
  const raw =
    process.env.NEXT_PUBLIC_APPLICATION_HOST ??
    process.env.APPLICATION_HOST ??
    'https://kuraykaraaslan.com';
  return raw.replace(/\/+$/, '');
};

const escapeXml = (s: string) =>
  s.replaceAll('&','&amp;')
   .replaceAll('<','&lt;')
   .replaceAll('>','&gt;')
   .replaceAll('"','&quot;')
   .replaceAll("'","&apos;");

export const renderUrlSet = (urls: SitemapUrl[]) => {
  const items = urls.map(u => `
  <url>
    <loc>${escapeXml(u.loc)}</loc>
    ${u.lastmod ? `<lastmod>${escapeXml(u.lastmod)}</lastmod>` : ''}
    <changefreq>${u.changefreq ?? 'daily'}</changefreq>
    <priority>${(u.priority ?? 0.7).toFixed(1)}</priority>
  </url>`).join('');

  return `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
${items}
</urlset>`;
};

export const renderSitemapIndex = (locs: string[]) => {
  const items = locs.map(l => `
  <sitemap>
    <loc>${escapeXml(l)}</loc>
  </sitemap>`).join('');

  return `<?xml version="1.0" encoding="UTF-8"?>
<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
${items}
</sitemapindex>`;
};


=== ./helpers/SendSMS.tsx ===
import { Twilio } from "twilio";
import axios from "axios";


export default class SendSMS {



  /* 
    This function is responsible for selecting the SMS provider based on the country code of the phone number.
    If the phone number starts with +90, it is the country code of Turkey then use NETGSM
    If it is other than +90, it is the country code of another country then use TWILIO
    */

  public static async MultiVendorSelector(
    phone: string,
    message: string,
  ): Promise<void> {
    // PHONE_NUMBER is the phone number of the recipient and starts with the country code with plus sign
    // For example, +905555555555
    // if it is +90, it is the country code of Turkey then use NETGSM
    // if it is other than +90, it is the country code of another country then use TWILIO

    if (phone.startsWith("90")) {
      const targetPhone = phone.replace("90", "");
      await this.sendOTPbyNETGSM(phone, message);
    } else {
      const targetPhone = phone;
      await this.sendOTPbyTwillo(phone, message);
    }
  }

  /*
    This function is responsible for sending the OTP code to the user using Twilio.
    It uses the Twilio API to send the SMS.
    */
  
  public static async sendOTPbyTwillo(
    phone: string,
    message: string,
  ): Promise<void> {
    if (
      !process.env.TWILIO_ACCOUNT_SID ||
      !process.env.TWILIO_AUTH_TOKEN ||
      !process.env.TWILIO_PHONE_NUMBER
    ) {
      console.error("Twilio credentials not found");
      throw new Error("ERROR_SENDING_SMS");
    }

    const client = new Twilio(
      process.env.TWILIO_ACCOUNT_SID,
      process.env.TWILIO_AUTH_TOKEN,
    );

    await client.messages
      .create({
        body: message,
        from: process.env.TWILIO_PHONE_NUMBER,
        to: phone,
      })
      .then((message) => {

      }) 
      .catch((err) => {
        console.error(err);
        throw new Error("ERROR_SENDING_SMS");
      });
  }

  /*
    This function is responsible for sending the OTP code to the user using NETGSM.
    It uses the NETGSM API to send the SMS.
    */

  public static async sendOTPbyNETGSM(
    phone: string,
    message: string,
  ): Promise<void> {
    if (
      !process.env.NETGSM_USER_CODE ||
      !process.env.NETGSM_SECRET_CODE ||
      !process.env.NETGSM_PHONE_NUMBER
    ) {
      console.error("NETGSM credentials not found");
      throw new Error("ERROR_SENDING_SMS");
    }

    if (!process.env.NETGSM_APP_KEY) {
      console.error("NETGSM APP KEY not found");
      throw new Error("ERROR_SENDING_SMS");
    }

    const formData = new FormData();

    /*
        usercode : 850XXXXXXX
        password : XXXX
        gsmno : 5XXXXXXXXXX
        message : testmesajı
        msgheader : mesajbaşlığı
        filter : 0
        appkey : xxx
        */

    formData.append("usercode", process.env.NETGSM_USER_CODE);
    formData.append("password", process.env.NETGSM_SECRET_CODE);
    formData.append("gsmno", phone);
    formData.append("message", "Your verification code is: " + message);
    formData.append("msgheader", process.env.NETGSM_PHONE_NUMBER);
    formData.append("filter", "0");
    formData.append("appkey", process.env.NETGSM_APP_KEY);

    try {
      await axios
        .post("https://api.netgsm.com.tr/sms/send/get", formData)
        .then((response) => {
        })
        .catch((err) => {
          console.error(err);
          throw new Error("ERROR_SENDING_SMS");
        });
    } catch (error) {
      console.error(error);
      throw new Error("ERROR_SENDING_SMS");
    }
  }
}


=== ./helpers/SMSTemplates/Admin/AdminContactUsSMSTemplate.tsx ===
const AdminContactUsSMSTemplate = (props: { name?: string, language?: string }) => {
  const { name } = props;

  if (!name) {
    return "Someone contacted you. Please check your email.";
  }

  
  const INFORM_NAME = process.env.INFORM_NAME as string;
  const INFORM_TITLE = process.env.INFORM_TITLE as string;
  const INFORM_MAIL = process.env.INFORM_MAIL as string;
  const INFORM_PHONE = process.env.INFORM_PHONE as string;

  const smsBody = `Hi ${INFORM_NAME}, ${name} contacted you. Please check your email. `;

  return smsBody;
}

export default AdminContactUsSMSTemplate;

=== ./helpers/SMSTemplates/Customer/CustomerContactUsSMSTemplate.tsx ===
const ContactUsSMSTemplate = (props: { name?: string, language?: string }) => {
  const { name } = props;

  if (!name) {
    return 'Hi, thank you for contacting me. I will get back to you as soon as possible.';
  }

  const smsBody = `Hi ${name}, thank you for contacting me. I will get back to you as soon as possible.`;

  return smsBody;
}

export default ContactUsSMSTemplate;

=== ./helpers/TimeHelper.ts ===
import { format, parseISO } from 'date-fns'
import { toZonedTime } from 'date-fns-tz'
import Logger from '@/libs/logger'

export function separateDateTimeWithTimeZone(
    datetime: Date,
    timeZone = 'UTC'
  ): { date: string; time: string } {
    try {
      const zoned = toZonedTime(datetime, timeZone)
      const date = format(zoned, 'yyyy-MM-dd')
      const time = format(zoned, 'HH:mm')
      return { date, time }
    } catch (err: any) {
      Logger.error('Failed to parse datetime:' + err.message)
      throw new Error(`Invalid datetime format: ${datetime}`)
    }
  }


